<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>OTPAPSampleServer - /PAPServerSample.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../samplecode/LegacyTechnologies/idxNetworking-date.html">Networking</a> &gt; <A HREF="javascript:location.replace('index.html');">OTPAPSampleServer</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/Networking/idxPrinting-date.html" target="_blank">Networking > Printing</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">OTPAPSampleServer</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/PAPServerSample.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/ATalkSampleUtils.c</option>
<option value="listing2.html">/ATalkSampleUtils.h</option>
<option value="listing3.html">/EnableEOMSample.c</option>
<option value="listing4.html">/EnableSelfSendSample.c</option>
<option value="listing5.html">/OTDebug.h</option>
<option value="listing6.html">/PAPPostScriptStuff.c</option>
<option value="listing7.html">/PAPPostScriptStuff.h</option>
<option value="listing8.html">/PAPServerSample.c</option>
<option value="listing9.html">/PAPServerSample.h</option>
<option value="listing10.html">/PAPServerUtilities.c</option>
<option value="listing11.html">/PAPServerUtilities.h</option>
<option value="listing12.html">/SetServerStatusOption.c</option>
<option value="listing13.html">/StringUtils.c</option>
<option value="listing14.html">/StringUtils.h</option></select>
				</p>
				</form>
				<p><strong><a href="OTPAPSampleServer.zip">Download Sample</a></strong> (&#147;OTPAPSampleServer.zip&#148;, 87.7K)<BR>
<strong><a href="OTPAPSampleServer.dmg">Download Sample</a></strong> (&#147;OTPAPSampleServer.dmg&#148;, 163.8K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/*  file: PAPServerSample.c    This sample demonstrates the implementation of a PAP server using Open Transport.    Issues:  1. PostScript Query responses are default only  To respond to the LaserWriter client, the PostScript query handler code is   designed to return the default responses.  A real PAP spooler would have to  respond more appropriately for the printer that it is supporting.  This could mean  delaying the response back to the client until the spooler can actually  pass the query to the printer and get a real response.  The code for detecting  a PostScript query is not very robust.  The purpose of this sample was not to  demonstrate PostScript support, but to packet flow via OT.    2. If the received data is not part of a PostScript query, the spooler sample  assumes that all of the incoming data is part of the same job.  There is no check  for the PostScript EOF indicator to distinguish different spooler jobs.  All of the   incoming data is saved to a temporary disk file at the root of the boot hard drive.  The code does not try to preflight the amount of storage present, nor protect    some minimum hard drive storage in case the hard drive is close to full.    3.  This sample requires OT 1.1.2 or greater.    4. This sample support multiple handoff endpoints.  The constant kMaxHandoffEPs  defines the maximum number of handoff endpoints that this sample supports.  I have  tested that the server supports 2 endpoint connections at the same time, but have not  gone into testing more simultaneous connections.        Change history  RRK 5/28/99 modified code to look for eof and respond to client with an empty packet with      the eof bit set.    RRK 3/9/99 add new code to protect against multiple unbind calls on an endpoint  *  Renamed DoDisconnect to DoRcvDisconnect and implemented  *  Implemented DoSndDisconnect  *  Check for errors in hanlder  *  implemented OTLookHandler function  *  implemented the ActivateHandoffEndpoint function where the handoff endpoint is initialized, and bound  *  fixed bug to OTRcvDisconnect where we were passing unit'd &amp;discon parameters.  *  set flags before making OT calls instead of after the call success to fix timing issues.    by:    Rich Kubota      Developer Technical Support      */#define  qDebug        1#define  HANDOFF_EP      1  // set to to to indicate use of handoff endpoint#include &lt;Types.h&gt;#include &lt;Errors.h&gt;#include &lt;String.h&gt;#include &lt;ToolUtils.h&gt;#include &quot;StringUtils.h&quot;#include &lt;AppleTalk.h&gt;#include &lt;DiskInit.h&gt;#include &lt;TextUtils.h&gt;#include &lt;Gestalt.h&gt;#include &lt;Files.h&gt;#include &lt;NumberFormatting.h&gt;#include &quot;OpenTransport.h&quot;#include &quot;OpenTptAppleTalk.h&quot;#include &quot;ATalkSampleUtils.h&quot;#include &quot;PAPServerUtilities.h&quot;#include &quot;PAPServerSample.h&quot;#include &quot;PAPPostScriptStuff.h&quot;#include &quot;OTDebug.h&quot;#include &quot;StrOpts.h&quot;extern  OSStatus OTSetMemoryLimits(size_t growSize, size_t maxSize);/********************//*   globals      *//********************/DDPAddress    gAddr;MyEndpointRef  gEp;#if HANDOFF_EPMyEndpointRef  gHandoffEp[kMaxHandoffEPs];#endifOTLIFO*      gFreeQ;      // note that an OTLIFO structure must be on a 4-byte boundary                // instead of trying to force it to be on a 4-byte boundary in                // global memory, we use a pointer, then allocate memory                // which will force the global to be on a 4-byte boundary.UInt32      gFlags  = 0;UInt32      gBufsAvail;PacketPtr    gTempPackPtr;short      gFRefNumToClose = 0;Boolean      gDone  = false;Str255      gIdleStr;Str255      gBusyStr;Str255      gServerNBPNameStr;UInt32      gOptionCompleted; // used to flag completion of Option Management callsextern char    gEOFStr[8];extern char    gBeginPSStr[8];extern char    qBeginQueryStr[8];extern char    gEndStr[8];extern char    gQueryStr[8];OSType      gOTVersionSelector  = 'otvr';UInt32      gOTVersion;/********************************************************************************* Prototypes********************************************************************************/pascal  void  EventHandler(void*, OTEventCode, OTResult, void*);OSStatus    HandleOTLookErr(MyEndpointRef *myEp);static void   EnterListenAccept(MyEndpointRef *myServerEp);void      DoListenAccept(MyEndpointRef *myServerEp);Boolean     ReceiveOnePacket(MyEndpointRef *myEp, PacketPtr packetPtr);void       DoReceiveData(MyEndpointRef *myEp);OSStatus     DoSndDisconnect(MyEndpointRef *myEp);OSStatus     DoDisconnect(MyEndpointRef *myEp);OSStatus     DoRcvDisconnect(MyEndpointRef *myEp);OSStatus     DoRcvOrderlyDisconnect(MyEndpointRef *myEp);OSStatus     PollQueueList(void);OSErr       ProcessIncomingDataFile(MyEndpointRef *theEp, PacketPtr packetPtr);Boolean     TestDataIsPSQuery(PacketPtr packetPtr);OSStatus     ProcessPSQuery(PacketPtr packetPtr);Boolean      DoProcessPSQuery(PacketPtr packetPtr);OSErr       CheckFileToClose(void);void      DoServer(void);void      DoEvent(EventRecord *event);OSStatus     DoOTUnbind(MyEndpointRef *theEp);OSStatus     DoBind(EndpointRef ep, UInt8 socket, UInt8 type, OTQLen qlen,             char *nbpName, UInt32 nbpNameLen);OSStatus     StartAbortiveDisconnect(MyEndpointRef *myEp);OSStatus     ActivatePAPEndpoint(MyEndpointRef *myEp);OSStatus     ActivateHandoffEndpoint(MyEndpointRef *myEp);OSStatus     InitPAPServerStuff(void);void      ClosePAPServerStuff(void);OSStatus      InitMyEndpointRef(MyEndpointRef *myEp);OSStatus     InitPAPBuffers(void);void       ReleasePAPMemory(void);extern OSStatus DoNegotiateEOMOption(EndpointRef ep, Boolean enableEOM);extern OSStatus DoSetServerStatusOption(EndpointRef ep, char *statusStr);extern OSStatus DoNegotiateSelfSendOption(EndpointRef ep, long enableSelfSend);void       DoValueBreak(long value, const char* message);OSStatus     BeginSetServerStatusOption(EndpointRef ep, UInt16 whichStr);UInt32       GetYesNoOption(void);Boolean     EndpointsAllBusy(void);#if HANDOFF_EPMyEndpointRef*  FindFreeHandoffEp(void);#endifstatic pascal void OTDebugStr(const char *msg){  UInt8 pMsg[256];    pMsg[0] = OTStrLength(msg);  OTMemcpy(&amp;pMsg[1], msg, pMsg[0]);  DebugStr(pMsg);}/********************************************************************************* EventHandler**  The event handler can be called at times when it is not safe to do console I/O,**  so this routine takes the event and jams it on a list to be handled when**  we know it's safe to print informative messages********************************************************************************/pascal void EventHandler(void* contextPtr, OTEventCode code,                    OTResult result, void* cookie){#pragma unused (cookie)      switch (code)  {    case T_LISTEN:        /* An connection request is available   */      SetListenPendFlag(((MyEndpointRef*)contextPtr)-&gt;flags);      DoListenAccept(contextPtr);      break;          //  T_DATA:    //    //  The main rule for processing T_DATA's is to remember that once you have    //  a T_DATA, you won't get another one until you have read to a kOTNoDataErr.    //  The advanced rule is to remember that you could get another T_DATA    //  during an OTRcv() which will eventually return kOTNoDataErr, presenting    //  the application with a synchronization issue to be most careful about.    //      //  In this application, since an OTRcv() calls are made from inside the notifier,    //  this particular synchronization issue doesn't become a problem.    //    case T_DATA:        /* Standard data is available      */                  // check that we are in the DATAXFER state      SetHasDataFlag(((MyEndpointRef*)contextPtr)-&gt;flags);      if (TstPassconFlag(((MyEndpointRef*)contextPtr)-&gt;flags))        DoReceiveData(contextPtr);      break;    case T_DISCONNECT:      /* A disconnect is available      */        // check whether there is a file open on this endpoint      DoRcvDisconnect(contextPtr);      break;          case T_ERROR:        /* obsolete/unused in library      */    case T_UDERR:        /* A Unit Data Error has occurred    */      OTDebugStr((const char *)&quot;T_ERROR called;g&quot;);      break;    case T_ORDREL:        /* An orderly release is available    */      DoRcvOrderlyDisconnect(contextPtr);      break;    case T_GODATA:        /* Flow control lifted on standard data  */                  // for this sample, I do not expect this event to occur.      OTDebugStr((const char *)&quot;T_GODATA called;g&quot;);      break;    case T_GOEXDATA:      /* Flow control lifted on expedited data*/                  // for this sample, I do not expect this event to occur.      OTDebugStr((const char *)&quot;T_GOEXDATA called;g&quot;);      break;    case T_PASSCON:        /* State is now case T_DATAXFER      */          // set the passcon flag        // set flag to indicate that the endpoint is busy      SetEPBusyFlag(((MyEndpointRef*)contextPtr)-&gt;flags);        // Set flag to indicate that the endpoint is bound        // RRK addition 3/10/99      SetEPBoundFlag(((MyEndpointRef*)contextPtr)-&gt;flags);        // set flag to tell system to set server status flag appropriately        // for multiple handoff endpoint servers, this would need to be        // handled differently.      SetCheckOptFlag(gFlags);      SetFirstPktFlag(((MyEndpointRef*)contextPtr)-&gt;flags);      SetPassconFlag(((MyEndpointRef*)contextPtr)-&gt;flags);            // Set the timer for this connection      OTGetTimeStamp(&amp;((MyEndpointRef*)contextPtr)-&gt;timerDog);          // check to see if there is any data to process      DoReceiveData(contextPtr);      break;          case T_RESET:        /* Protocol has been reset        */      OTDebugStr((const char *)&quot;T_RESET called;g&quot;);      break;    case T_ACCEPTCOMPLETE:    /* Accept call is complete        */      OTDebugStr((const char *)&quot;T_ACCEPTCOMPLETE called;g&quot;);      ClrAcceptPendFlag(((MyEndpointRef*)contextPtr)-&gt;flags);      SetFirstPktFlag(((MyEndpointRef*)contextPtr)-&gt;flags);              // RRK 3/9/99        // check for an error result      if (result != kOTNoError)      {        OTDebugStr(&quot;Error occured with T_ACCEPTCOMPLETE event&quot;);        if (result == kOTLookErr )        {          HandleOTLookErr(contextPtr);        }      }      break;    case T_DISCONNECTCOMPLETE:  /* Disconnect call is complete      */      OTDebugStr(&quot;T_DISCONNECTCOMPLETE event occurred;g&quot;);      ClrDisconPendFlag(((MyEndpointRef*)contextPtr)-&gt;flags);  // is the server endpoint bound      ClrEPBusyFlag(((MyEndpointRef*)contextPtr)-&gt;flags);      ClrAcceptPendFlag(((MyEndpointRef*)contextPtr)-&gt;flags);      ClrListenPendFlag(((MyEndpointRef*)contextPtr)-&gt;flags);      break;        case T_UNBINDCOMPLETE:                    // RRK 3/9/99 add code to protect against multiple unbind calls//      OTDebugStr((const char *)&quot;T_UNBINDCOMPLETE called;g&quot;);      DoValueBreak((long)contextPtr, &quot;T_UNBINDCOMPLETE called #&quot;);      SetCheckOptFlag(gFlags);                // set flag to force the server to determine                                  // whether to change the server message      ClrEPBusyFlag(((MyEndpointRef*)contextPtr)-&gt;flags);    // no longer waiting for T_UNBINDCOMPLETE message      ClrUnbindPendFlag(((MyEndpointRef*)contextPtr)-&gt;flags);      ClrEPBoundFlag(((MyEndpointRef*)contextPtr)-&gt;flags);  // is the server endpoint bound      SetStatusIdleFlag(gFlags);      break;          //    //  kStreamIoctlEvent:    //    //  This event is returned when an I_FLUSH ioctl has completed.    //  The flush was done in an attempt to get back all T_MEMORYRELEASED events    //  for outstanding OTSnd() calls with Ack Sends.   Errors are ignored at this point since it is    //  possible that the connection will already be gone, etc.    //    case kStreamIoctlEvent:    // the flush is complete      DoSndDisconnect (contextPtr); /* safe to disconnect */      break;        case T_OPTMGMTCOMPLETE:      if (result != kOTNoError)      {        OTDebugStr(&quot;Error occured with T_OPTMGMTCOMPLETE event&quot;);      }            gOptionCompleted = 1;      break;    default:      break;  }}/***********************************************************  RRK 3/9/99 addition  HandleOTLookErr implemented to handle OTLookErr in a  central place - only call this function in response  to a OTLookErr for a function call  ************************************************************/OSStatus HandleOTLookErr(MyEndpointRef *myEp){  OSStatus    err = kOTNoError;  OTResult    result;    result = OTLook(myEp-&gt;ep);    switch (result)  {    case T_DISCONNECT:      err = DoRcvDisconnect(myEp);      if (err == kOTNoError)      {        ClrInPSQueryFlag(myEp-&gt;flags);      }      else      {        DoValueBreak(err, &quot;Error calling DoRcvDisconnect from HandleOTLookErr #&quot;);        SetForceCloseFlag(myEp-&gt;flags);      }      break;        case T_ORDREL:      err = DoRcvOrderlyDisconnect(myEp);        // if successful, then we enter T_INREL state      if (err != kOTNoError)      {        DoValueBreak(err, &quot;Error calling DoRcvOrderlyDisconnect from HandleOTLookErr #&quot;);        SetForceCloseFlag(myEp-&gt;flags);      }      break;              default:        // The use of this function in this instance is to handle        // T_DISCONNECT events that can happen.  This call will        // need to be customized for other use, like handling         // T_DATA events which is not implemented in this sample.        // Pass a debugStr call to show what event was not handled here      DoValueBreak((long)result, &quot;HandleOTLookErr passed unprocessed event - #&quot;);            break;      }    return err;}////  EnterListenAccept////  This is a front end to DoListenAccept() which is used whenever //  it is not being called from inside the listener endpoint's notifier.//  We do this for syncrhonization.   If we were processing an OTListen()//  or an OTAccept() and we were interrupted at the listener endpoint's//  notifier with a T_LISTEN, etc, it would be inconvenient and would require//  some more sophisticated synchronization code to deal with the problem.//  The easy way to avoid this is to do an OTEnterNotifier() on the listener's//  endpoint.   ////  Important note - doing OTEnterNotifier on one endpoint only prevents that//  endpoint's notifier for interrupting us.   Since the same notifier code//  is used for lots of endpoints here, remember that the one endpoint's //  notifier can interrupt another.   Doing an OTEnterNotifier() on the//  listener endpoint prevents the listener from interrupting us, but it//  does not prevent the Notifier() routine from interrupting us via //  another endpoint which also uses the same routine.////  Important note #2 - Don't ever do an OTEnterNotifier on an acceptor endpoint//  before doing the OTAccept().   This confuses OT and creates problems.//static void EnterListenAccept(MyEndpointRef *myServerEp){  Boolean  doLeave;    doLeave = OTEnterNotifier(myServerEp-&gt;ep);  DoListenAccept(myServerEp);  if (doLeave)    OTLeaveNotifier(myServerEp-&gt;ep);}/*  DoListenAccept is designed to handle an incoming connect request.  This module demonstrates a  very complex task that all X/OPEN style acceptors must implement.  The problem stems from  fact that an endpoint may be hit by a number of simultaneous connect requests.  In addition  if there is a connection already established and the endpoint handles multiple  handoff endpoints, then there could also be an incoming disconnect request to process before  one can issue either an Accept or Disconnect response, all pending Connect requests must  be consumed from the streamhead first.  This places a burden on the accept routine to have  a place to temporarily stash all of the addresses to which discon messages will have to be  sent.    Refer to Tech Note 1059 for the 8 steps to handling an incoming connection request.    Note that once all of the connect request have been consumed and we are in the process of  sending discon responses, it could be that there will again be an kOTLookErr, which  indicates that another incoming connect request heeds to be consumed before  resuming with the discon responses.    In this sample we consume the first listen request.  We then check whether we can accept  the incoming request, If so, then call OTAccept.  If OTAccept fails with a lookErr, then   there is another connect request to be consumed.    processed.  */void DoListenAccept(MyEndpointRef *myServerEp){  MyEndpointRef  *myAcceptEp;  OSStatus  err;  TCall    call;  Boolean    done = false;      // check we have already entered DoListenAccept from the main event loop and are     // trying to do so again from the secondary interrupt  if (OTAtomicSetBit(&amp;myServerEp-&gt;semaphore, kInListenLoop))    return;  // if the bit was previous set, then we already have entered, but not exitted        // this proc from the main event loop  if (TstAcceptPendFlag(myServerEp-&gt;flags))  {      // we're waiting for an Accept call to complete, so don't accept a new      // connection request as we will get an out of state error      // set the ListenPendFlag so we will check the server endpoint later        SetListenPendFlag(myServerEp-&gt;flags);    done = true;  }  else    ClrListenPendFlag(myServerEp-&gt;flags);    if (done == false)  {      // clear out the TCall structure    memset(&amp;call, 0, sizeof(TCall));          // set up the TCall structure    call.addr.maxlen = sizeof(struct DDPAddress);    call.addr.len = sizeof(struct DDPAddress);    call.addr.buf = (unsigned char *) &amp;gAddr;            if (OTIsSynchronous(myServerEp-&gt;ep) == true)      OTSetAsynchronous(myServerEp-&gt;ep);            // step 1 for handling an incoming connection request    err = OTListen(myServerEp-&gt;ep, &amp;call);        if (err == kOTNoDataErr)    {      OTDebugStr((const char*)&quot;kOTNoDataErr returned by OTListen&quot;);        // don't need to do anything    }    else if (err == kOTLookErr)    {        // step 2 for handling incoming connection requests        // handle disconnect indications for a pending connection request        // the only look indication allowed on an OTListen call is        // T_DISCONNECT      HandleOTLookErr(myServerEp);      done = true;           }    else if (err != kOTNoError) // there was an unknown error in doing the listen    {      DoValueBreak((long)err, &quot;error occured on OTListen #&quot;);      done = true;    }  }    if (done == false)  {#if HANDOFF_EP    myAcceptEp = FindFreeHandoffEp();#else    if (TstEPBusyFlag(myServerEp.flags) == false)      myAcceptEp = myServerEp;    else      myAcceptEp = nil;#endif       }    if (myAcceptEp == nil)  {      OTDebugStr((const char *)&quot;rejecting T_LISTEN - no free handoff endpoints&quot;);      // if there are no available handoff endpoints, then send the disconnect    OTSndDisconnect(myServerEp-&gt;ep, &amp;call);    done = true;  }    if (done == false)  {        // set a flag to indicate that an accept call is pending      // if we try to accept another connection before this      // accept call is completed, an out of state error results       // need to do this before we make the OTAccept call    SetAcceptPendFlag(myServerEp-&gt;flags);          // make the accept call and handoff the connection    err = OTAccept(myServerEp-&gt;ep, myAcceptEp-&gt;ep, &amp;call);    if (err == kOTNoError)    {      SetEPBusyFlag(myAcceptEp-&gt;flags);        // set flag to have server check the serverstatus      TstCheckOptFlag(gFlags);                }    else if (err == kOTLookErr)    {      HandleOTLookErr(myServerEp);    }    else    {#if HANDOFF_EP      DoValueBreak((long)err, &quot;error occured on OTAccept for handoff #&quot;);#else      DoValueBreak((long)err, &quot;error occured on OTAccept #&quot;);#endif    }  }        OTAtomicClearBit(&amp;myServerEp-&gt;semaphore, kInListenLoop);  // clear the bit that indicates we're in this loop  }/********************************************************************************* ReceiveOnePacket - makes the call to receive just one packet** If there is data, then the data is placed into the packetPtr** and the incoming byte count is incremented** if the kOTNoDataErr occurs, then the HasDataFlag is cleared.** **   ********************************************************************************/Boolean ReceiveOnePacket(MyEndpointRef *myEp, PacketPtr packetPtr){  OTResult   result;  Boolean    done = false;            result = OTRcv(myEp-&gt;ep, &amp;packetPtr-&gt;data, kPAPDataSize, &amp;packetPtr-&gt;flags);  if (result &lt; 0)  {      // requeue the buffer to the freeq    OTLIFOEnqueue(gFreeQ, &amp;(packetPtr-&gt;fLink));    done = true;        if (result == kOTLookErr)    {      HandleOTLookErr(myEp-&gt;ep);          }    else if (result == kOTOutStateErr)    {        // client could have issued a disconnect call while this call was about to        // to be processed      ClrHasDataFlag(myEp-&gt;flags);    }        else if (result == kOTNoDataErr)    {        // no more data so clr the flag      ClrHasDataFlag(myEp-&gt;flags);    }    else     {      DoValueBreak(result, &quot;Unknown error occurred in OTRcv #&quot;);    }  }  else if (result == 0)  {    OTDebugStr((const char *)&quot;OTRcv got nothing ;g&quot;);        if (TstInPSQueryFlag(myEp-&gt;flags))  // check if the endpoint is already processing a postscript    {      OTDebugStr((const char *)&quot;0 byte packet while processing ps query ;g&quot;);      if (packetPtr-&gt;flags &amp; T_MORE == 0)        OTDebugStr((const char *)&quot;T_MORE was not set;g&quot;);      else        OTDebugStr((const char *)&quot;T_MORE was set;g&quot;);                // send an empty response with EOF flags set since it appears that this is what the Laserwriter         // client wants to see. At this point, we have already processed any preceding         // ps queries.  It is important to not respond with an empty packet and EOF bit set if        // there is still a ps query response outstanding.      packetPtr-&gt;theEp = myEp;      SendEmptyPacket(packetPtr);        // clear bit that indicates we are processing a postscript query      ClrInPSQueryFlag(myEp-&gt;flags);        OTDebugStr((const char *)&quot;Have finished ps query;g&quot;);              // queue the buffer to the freeQ associated with the endpoint      OTLIFOEnqueue(gFreeQ, &amp;(packetPtr-&gt;fLink));    }    else    {              // pass this packet on to the event loop so that we can send a null response        // save the endpoint ref associated with this data.        // While we could send the empty packet here, this example waits until the        // data is processed in the main event loop to send the null packet.      packetPtr-&gt;theEp = myEp;                  // save the amount of data read       packetPtr-&gt;numBytes = result;                  // intialize the lastPos field      packetPtr-&gt;lastPos = 0;                  // get the timestamp for this packet      OTGetTimeStamp(&amp;packetPtr-&gt;timeStamp);                  // Set the timer for this connection      OTGetTimeStamp(&amp;myEp-&gt;timerDog);        // queue the buffer to the usedQ associated with the endpoint      OTLIFOEnqueue(myEp-&gt;usedQ, &amp;(packetPtr-&gt;fLink));    }            }  else  {      // check if this is the first packet for this endpoint and set the time in timestamp    if (TstFirstPktFlag(myEp-&gt;flags))    {      ClrFirstPktFlag(myEp-&gt;flags);                // set the time Data In timestamp field      OTGetTimeStamp(&amp;myEp-&gt;timeDataIn);              // zero out the numByteIn field      myEp-&gt;numBytesIn = 0;          }      // save the number of bytes read    myEp-&gt;numBytesIn += result;      // set the time data end timestamp field    OTGetTimeStamp(&amp;myEp-&gt;timeDataEnd);    if (TstdumpAllPktsFlag(gFlags))    {      OTLIFOEnqueue(gFreeQ, &amp;(packetPtr-&gt;fLink));    }    else    {                  // save the endpoint ref associated with this data      packetPtr-&gt;theEp = myEp;                  // save the amount of data read       packetPtr-&gt;numBytes = result;                  // intialize the lastPos field      packetPtr-&gt;lastPos = 0;                  // get the timestamp for this packet      OTGetTimeStamp(&amp;packetPtr-&gt;timeStamp);                  // Set the timer for this connection      OTGetTimeStamp(&amp;myEp-&gt;timerDog);            if (!DoProcessPSQuery(packetPtr))      {          // packet is not a postscript query so queue to the endpoint usedQ          // queue the buffer to the usedQ associated with the endpoint        OTLIFOEnqueue(myEp-&gt;usedQ, &amp;(packetPtr-&gt;fLink));              }        }  }    return done;    }/********************************************************************************* DoReceiveData**   ********************************************************************************/void DoReceiveData(MyEndpointRef *myEp){  PacketPtr  packetPtr;  OTFlags    flags = 0;  Boolean    done;      // check we have already entered DoReceiveData from the main event loop    // or from the event handler and are     // trying to do so again a second time  if (OTAtomicSetBit(&amp;myEp-&gt;semaphore, kInRcvDataFlag))    return;  // if the bit was previous set, then we already have entered, but not exitted        // this proc from the main event loop  done = gDone;  while (done == false)  {    if (gFreeQ-&gt;fHead != nil)    {      packetPtr = (PacketPtr)OTLIFODequeue(gFreeQ);      done = ReceiveOnePacket(myEp, packetPtr);    }    else    {            done = true;    }            }  OTAtomicClearBit(&amp;myEp-&gt;semaphore, kInRcvDataFlag);          // clear the bit that indicates we're in this loop            }OSStatus DoSndDisconnect(MyEndpointRef *myEp){  OSStatus    err;  err = OTSndDisconnect(myEp-&gt;ep, NULL);  if (err != kOTNoError)  {    DoValueBreak((long)err, &quot;error occured on OTSndDisconnect #&quot;);  }  else  {    ClrAcceptPendFlag(myEp-&gt;flags);  }  return err;}OSStatus DoRcvDisconnect(MyEndpointRef *myEp){  OSStatus    err = kOTNoError;    if (TstDisconPendFlag(myEp-&gt;flags))  {      // set discon flag before making the call and clear it if the call      // fails so that we don't have a race condition with the handler routine    SetDisconPendFlag(myEp-&gt;flags);    err = OTRcvDisconnect(myEp-&gt;ep, NULL);    if (err != kOTNoError)    {      DoValueBreak((long)err, &quot;error occured on OTRcvDisconnect #&quot;);      ClrDisconPendFlag(myEp-&gt;flags);    }  }  return err;}OSStatus DoRcvOrderlyDisconnect(MyEndpointRef *myEp){  OSStatus    err;    err = OTRcvOrderlyDisconnect(myEp-&gt;ep);  if (err &lt; kOTNoError)  {    DoValueBreak((long)err, &quot;error occured on OTRcvOrderlyDisconnect #&quot;);  }  else if (err &gt; 0)  {          OTDebugStr((const char *)&quot;OTRcvOrderlyDisconnect returned positive result;g&quot;);  }    return err;}/********************************************************************************* PollEventList**  This routine checks the used queue to see whether the handler has processed  incoming PAP data from the client.**  If the used queue is not empty, there are two different options to deal with.  First we check whether we are in the middle of processing a postscript data  file.  If so, we continue to read the data into a file which we have created.  If not currently processing postscript data, we then check to see if the incoming  packet is part of a postscript query in progress or is the beginning of a   postscript query.  If so, we continue to read the query and respond as appropriate.  If not a query, then this must be the first packet of postscript data being sent.  ********************************************************************************/OSStatus PollQueueList(void){  PacketPtr  packetPtr, nextPacketPtr;  MyEndpointRef *theEp;  OSStatus  err = kOTNoError;  short    i = 0;  Boolean    done = false;  #if HANDOFF_EP  for (i = 0; (i &lt; kMaxHandoffEPs) &amp;&amp; (err == kOTNoError); i++)  {    theEp = &amp;gHandoffEp[i];#else    theEp = &amp;gEp;#endif    packetPtr = (PacketPtr)OTLIFOStealList(theEp-&gt;usedQ);    while (packetPtr != nil)    {      packetPtr = (PacketPtr)OTReverseList((OTLink*)packetPtr);      do      {        nextPacketPtr = (PacketPtr)packetPtr-&gt;fLink.fNext;                err = ProcessIncomingDataFile(theEp, packetPtr);              // queue the packetPtr back to the freeQ        OTLIFOEnqueue(gFreeQ, &amp;(packetPtr-&gt;fLink));        packetPtr = nextPacketPtr;              } while((packetPtr != nil) &amp;&amp; (err == kOTNoError));            packetPtr = (PacketPtr)OTLIFOStealList(theEp-&gt;usedQ);    }#if HANDOFF_EP  }#endif            return err;}OSErr ProcessIncomingDataFile(MyEndpointRef *theEp, PacketPtr packetPtr){  OSStatus    err = noErr;  short      fRefNum;  Boolean      eofFlag = false;        // For each incoming packet, we need to check whether the EOF    // bit was set by looking at whether the T_MORE flag was clear  if ((packetPtr-&gt;flags &amp; T_MORE) == 0)  {    fprintf(stdout, &quot;\nT_MORE flag not set \n&quot;);    if (TstEOMOnFlag(theEp-&gt;flags))    {        // send empty packet response to the sender to acknowledge that we        // have received the last packet        // this is       fprintf(stdout, &quot;Sending empty response packet \n&quot;);      SendEmptyPacket(packetPtr);      eofFlag = true;    }    else    {      fprintf(stdout, &quot;EOM option not enabled - cannot tell if EOF message sent \n&quot;);    }  }      if (!TstdumpAllPktsFlag(gFlags) &amp;&amp; !TstDumpPktsFlag(theEp-&gt;flags))  // check if we are dumping the packets  {    if (!TstTempFileFlag(theEp-&gt;flags)) // is there a temp file opened for this endpoint    {        // no, so create one      err = OpenTempFile(&amp;fRefNum);      if (err == noErr)      {        fprintf(stdout, &quot;\nprocessing incoming file\n&quot;);        theEp-&gt;fRefNum = fRefNum;    // save the refnum of the temp file;        SetTempFileFlag(theEp-&gt;flags);  // indicate that there is a temp file associated                        // with this endpoint.      }      else      {        fprintf(stdout, &quot;Error occurred opening a temp file %d\n&quot;, err);        fprintf(stdout, &quot;The packets will be dumped%d\n&quot;, err);      }          }    if (err == noErr)    {              // the temp file has been created or already exists, so read the data and write it        // to the temp file      err = WriteDataToTempFile(theEp-&gt;fRefNum, packetPtr-&gt;data, packetPtr-&gt;numBytes);      if (err != noErr)      {        fprintf(stdout, &quot;Error occurred writing to temp file %d\n&quot;, err);        fprintf(stdout, &quot;All remaining packets will be dumped for this endpoint\n&quot;);        SetDumpPktsFlag(theEp-&gt;flags);          // set err to noErr otherwise the error would force the close of the          // program        err = noErr;        }        // check if the eof bit was set, and close the file if so      if (eofFlag == true)      {        err = CloseTempFile(theEp-&gt;fRefNum);        if (err != noErr)          fprintf(stdout, &quot;\n\nError occurred closing file - error %ld.\n&quot;, err);            else          ClrTempFileFlag(theEp-&gt;flags);      }    }  }    return err;}OSErr CheckFileToClose(void){  OSErr  err = noErr;    if (gFRefNumToClose != 0)  {    fprintf(stdout, &quot;Am about to close file with fRefNum %ld.\n&quot;, gFRefNumToClose);        err = CloseTempFile(gFRefNumToClose);    if (err != noErr)      fprintf(stdout, &quot;\n\nError occurred closing file - error %ld.\n&quot;, err);              // reset the tempfile to close so that we don't close this file again    gFRefNumToClose = 0;  }    return err;}/********************************************************************************* DoServer********************************************************************************/void DoServer(void){  EventRecord    theEvent;  OTTimeStamp    eTime;  OTResult    state;  UInt32      eTimeMSec, sec, msec, rate;  MyEndpointRef  *theEp;  OSStatus     err1, err = kOTNoError;#if HANDOFF_EP  short      i = 0;#endif    while (gDone == false)  {    if (!WaitNextEvent(everyEvent, &amp;theEvent, 15, nil))      theEvent.what = nullEvent;          DoEvent(&amp;theEvent);        if (TstListenPendFlag(gEp.flags))    // are there incoming connect requests to process    {      fprintf(stdout, &quot;\n processing EnterListenAccept from even tloop&quot;);      EnterListenAccept(&amp;gEp);    }          err = PollQueueList();    if (err != kOTNoError)    // we're outta here if an error occurred.      gDone = true;#if HANDOFF_EP    theEp = &amp;gHandoffEp[i];    i++;    if (i &gt;= kMaxHandoffEPs)      i = 0;#else    theEp = &amp;gEp;#endif    if (TstForceCloseFlag(theEp-&gt;flags))    {      state = kForceClose;    }    else    {        // get the current endpoint state      state = OTGetEndpointState(theEp-&gt;ep);    }        switch (state)    {      case T_DATAXFER:                    // check if we haven't completed reading data from OT.          DoReceiveData(theEp);        break;              case T_INREL:  // we've processed an incoming Orderly Release request              // but have not issued our own orderly disconnect                  // note that since we have already processed an incoming orderly disconnect          // we are in the INREL state.  After making the OTSndOrderlyDisconnect          // call, there will not be a T_DISCONNECTCOMPLETE call, since we complete          // the orderly release with the above call.  We go ahead and reset our flags          // and issue the OTUnbind call if we are using a handoff endpoint.          // if we did get the orderly release indication, then make sure we have          // drained the receive queue - PollQueueList does this                    // A PAPServer does not normally issue an OrderlyDisconnect request.  Typically,          // the client issues the orderly release, at which point the server must accept the          // T_ORDREL event. At this point the server is         do        {          fprintf(stdout, &quot;processing some last data\n&quot;);          PollQueueList();                }while( (TstHasDataFlag(theEp-&gt;flags)) || (theEp-&gt;usedQ-&gt;fHead != nil));        fprintf(stdout, &quot;Calling OTSndOrderlyDisconnect\n&quot;);          // clear the flag and send a corresponding disconnect        err = OTSndOrderlyDisconnect(theEp-&gt;ep);        if (err)        {          // the only error that makes sense here is the kOTLookErr          //  which the only event is the T_DISCONNECT event.  This should not happen,          // however, if there are multiple handoffs, this may be an issue.  Given the way          // incoming requests are handled, I don't expect that there would be an           // unresponded listen request here that would warrant a possible T_DISCONNECT          // however some implementation will need to consider this possibility.          DoValueBreak((long)err, &quot;error occured on OTSndOrderlyDisconnect #&quot;);                    gDone = true;        }                            if (TstTempFileFlag(theEp-&gt;flags))        {                              // is there an open spool file associated with this endpoint          gFRefNumToClose = theEp-&gt;fRefNum;  // set the global to have this file closed                          // note that this method of signalling for a file to                          // get closed is a quick and dirty method and assumes th                          // that only one file at a time is being processed here.          CheckFileToClose();        }                ClrTempFileFlag(theEp-&gt;flags);        ClrPassconFlag(theEp-&gt;flags);#if HANDOFF_EP          // in order to re-use a handoff endpoint, it must be unbound.  Unbinding the           // endpoint clears the connection information that allows to to know which          // endpoint, incoming PAP data is routed to.        if (theEp-&gt;ep != gEp.ep)        {          if (TstEPBoundFlag(theEp-&gt;flags))          {            OTDebugStr(&quot;Entered DoOTUnbind for T_INREL&quot;);            DoOTUnbind(theEp);    // RRK 3/9/99 change to protect against multiple unbinds          }        }#else          // indicate that we are no longer busy        ClrEPBusyFlag(theEp-&gt;flags);          // set flag so that we will check the status        SetCheckOptFlag(gFlags);        SetStatusIdleFlag(gFlags);          #endif                            // calculate the elapsed time        OTSubtractTimeStamps(&amp;eTime, &amp;theEp-&gt;timeDataIn, &amp;theEp-&gt;timeDataEnd);          // convert to millisecs        eTimeMSec = OTTimeStampInMilliseconds(&amp;eTime);        sec = eTimeMSec / (UInt32)1000;        msec = eTimeMSec %(UInt32)1000;        fprintf(stdout, &quot;Time to transfer file was %ld . %ld seconds.\n&quot;, sec, msec);        fprintf(stdout, &quot;Bytes transferred was - %ld.\n&quot;, theEp-&gt;numBytesIn);        if (sec != 0)        {          rate = (theEp-&gt;numBytesIn / sec) / 1024;          fprintf(stdout, &quot;Transfer rate - %ld KBytes/Sec. \n&quot;, rate);        }        else         {          rate = (theEp-&gt;numBytesIn *1000 / msec) / 1024;          fprintf(stdout, &quot;Transfer rate - %ld KBytes/Sec. \n&quot;, rate);        }        break;              case T_IDLE:  // we're either really idle, or the we've processed a disconnect event              // if we processed a disconnect event then the busy flag for the ep would still be set        fprintf(stdout, &quot;i&quot;);        fflush(stdout);                if (TstEPBusyFlag(theEp-&gt;flags))  // we're we previously connected        {          ClrPassconFlag(theEp-&gt;flags);  // clear the flag so that we can accept a new connection                    ClrTempFileFlag(theEp-&gt;flags);          ClrPassconFlag(theEp-&gt;flags);          if (TstTempFileFlag(theEp-&gt;flags))                                // is there an open spool file associated with this endpoint            gFRefNumToClose = theEp-&gt;fRefNum;  // set the global to have this file closed                            // note that this method of signalling for a file to                            // get closed is a quick and dirty method and assumes th                            // that only one file at a time is being processed here.#if HANDOFF_EP            // in order to re-use a handoff endpoint, it must be unbound.  Unbinding the             // endpoint clears the connection information that allows to to know which            // endpoint, incoming PAP data is routed to.          if (theEp-&gt;ep != gEp.ep)          {            DoOTUnbind(theEp-&gt;ep);  // RRK 3/9/99 change to protect against multiple unbinds              }#else            // set flag so that we will check the status          SetCheckOptFlag(gFlags);            // indicate that we are no longer busy          ClrEPBusyFlag(theEp-&gt;flags);          SetStatusIdleFlag(gFlags);#endif        }        break;            case kForceClose:  // our endpoint is really hosed so close it an reopen it        ClrForceCloseFlag(theEp-&gt;flags);        OTCloseProvider(theEp-&gt;ep);#if HANDOFF_EP        err = ActivateHandoffEndpoint(theEp);#else        err = ActivatePAPEndpoint(theEp);#endif        if (err != kOTNoError)        {          fprintf(stdout, &quot;\n Error activating endpoint - %ld.\n&quot;, err);          fprintf(stdout, &quot;\n Quitting.\n&quot;);          gDone = true;        }        break;            }            err1 = CheckFileToClose();    if (err1 != noErr)      fprintf(stdout, &quot;\n\nCheckFileToClose error - %ld.\n&quot;, err1);      if (TstCheckOptFlag(gFlags))    {            if (EndpointsAllBusy())      {        if (TstStatusBusyFlag(gFlags) == false)        {          BeginSetServerStatusOption(gEp.ep, kSetBusyStr);          SetStatusBusyFlag(gFlags);        }      }      else      {        if (TstStatusBusyFlag(gFlags) == true)        {          BeginSetServerStatusOption(gEp.ep, kSetIdleStr);          ClrStatusBusyFlag(gFlags);        }      }      ClrCheckOptFlag(gFlags);    }            }}/* Do the right thing for an event.  Determine what kind of event it is, and** call the appropriate routines. */void  DoEvent(EventRecord *event){  Point  pt;  char  key;  switch(event-&gt;what)   {    case nullEvent:    case mouseDown:    case activateEvt:    case updateEvt:    case kHighLevelEvent:      break;    case autoKey:    case keyDown:      key = event-&gt;message &amp; charCodeMask;      switch (key)      {        case 'q':        case 'Q':          if (event-&gt;modifiers &amp; cmdKey)          gDone = true;          break;      }      break;    case osEvt:      switch ((event-&gt;message &gt;&gt; 24) &amp; 0xFF)       {          /* Must logical and with 0xFF to get only low byte. */          /* High byte of message. */        case mouseMovedMessage:          break;        case suspendResumeMessage:            /* Suspend/resume is also an activate/deactivate. */          if ((event-&gt;message) &amp; resumeFlag)            ClrInBackGndFlag(gFlags);  // process has come to the foreground          else            SetInBackGndFlag(gFlags);  // process has gone into background          break;      }      break;    case diskEvt:      if (HiWord(event-&gt;message) != noErr)       {        SetPt(&amp;pt, kDILeft, kDITop);        DIBadMount(pt, event-&gt;message);      }    /* It is not a bad idea to at least call DIBadMount in response to */      break;  /* a diskEvt, so that the user can format a floppy. */  }}/*******************************************************************************  DoOTUnbind  Call to make the OTUnbind request and check for an error result.  Once this call is made, we don't want to protect against the OTUnbind  from being called a second time.  If the OTUnbind call is made a second time  before the T_UNBINDCOMPLETE event has occurred, then the call results in an  StateChangeErr    // RRK 3/9/99 add new code to protect against multiple unbind calls  ********************************************************************************/OSStatus DoOTUnbind(MyEndpointRef *theEp){  OSStatus  err = kOTNoError;  Boolean    isSync;  //  OTDebugStr(&quot;Entered DoOTUnbind&quot;);    if (TstEPBoundFlag(theEp-&gt;flags) &amp;&amp; !TstUnbindPendFlag(theEp-&gt;flags))  {      // check whether the ep is asynch and set a flag to indicate we are waiting for the      // unbind to complete.  We have to set the flag before we issue the call as      // the T_UNBINDCOMPLETE call could occur before we could set the flag is done      // after the OTUnbind call    isSync = OTIsSynchronous(theEp-&gt;ep);        if (isSync == false)    {      SetUnbindPendFlag(theEp-&gt;flags);    }          OTDebugStr(&quot;About to call OTUnbind&quot;);    err = OTUnbind(theEp-&gt;ep);    if (err != kOTNoError)    {      DoValueBreak(err, &quot;Error calling OTUnbind #&quot;);      SetForceCloseFlag(theEp-&gt;flags);        // on err clear the UnbindPendFlag      ClrUnbindPendFlag(theEp-&gt;flags);    }    else    {      if (isSync == true)      {        ClrEPBusyFlag(theEp-&gt;flags);        ClrEPBoundFlag(theEp-&gt;flags);      }    }  }  return err;}/********************************************************************************* DoBind**  Implements the option to set the qlen field and to bing with an nbpName**  by setting the nbpName field with a pointer to an entity name.**   If nbpName is not nil, you must also set the nbpNameLen to the size of the**  nbpName field. Note, nbpName is not a pascal nor a C string.  ********************************************************************************/OSStatus DoBind(EndpointRef ep, UInt8 socket, UInt8 type, OTQLen qlen,           char *nbpName, UInt32 nbpNameLen){  TBind      req, ret;  OSStatus     err = kOTNoError;  DDPNBPAddress  addr;    // init the DDPAddress variable    if (nbpName == nil)    // are we registering with no nbp name  {    addr.fAddressType = AF_ATALK_DDP;    // set the address type    req.addr.len  = kDDPAddressLength;  }  else  {    addr.fAddressType = AF_ATALK_DDPNBP;  // registering with an nbp name                        // copy the name to the name buffer    BlockMove(nbpName, &amp;addr.fNBPNameBuffer, nbpNameLen);                        // set the request length to include the name len    req.addr.len  = kDDPAddressLength + nbpNameLen;  }    addr.fNetwork = 0;  addr.fNodeID = 0;  addr.fSocket = socket;  addr.fDDPType = type;    // set up the request  req.addr.buf  = (UInt8*)&amp;addr;  req.qlen    = qlen;    // set up the response  ret.addr.buf  = (UInt8*)&amp;addr;  ret.addr.maxlen  = sizeof(addr);  fprintf(stderr, &quot;Doing Bind\n&quot;);  //  // Try to bind  //   err = OTBind(ep, &amp;req, &amp;ret);  if ( err != kOTNoError )  {    fprintf(stderr, &quot;PAPSample: DoBind returns error %ld\n&quot;, err);    return err;  }  fprintf(stderr, &quot;Bound address = &quot;);  ShowDDPAddress((DDPAddress*)&amp;addr);  fprintf(stderr, &quot;\n&quot;);  fprintf(stderr, &quot;Bound queue len is %ld\n&quot;, ret.qlen);  fprintf(stderr, &quot;After Bind, &quot;);  ShowEndpointState(ep, &quot;&quot;);  return err;}/********************************************************************************* StartAbortiveDisconnect    RRK 3/9/99 addition**  starts an abortive disconnect of the endpoint by first forcing a flush of the    cache, which results in a kStreamIoctlEvent handler event********************************************************************************/OSStatus StartAbortiveDisconnect(MyEndpointRef *myEp){  OSStatus  err = kOTNoError;    err = OTIoctl(myEp-&gt;ep, I_FLUSH, (void*) FLUSHRW);  if (err)     DoOTUnbind(myEp-&gt;ep);    return err;}/********************************************************************************* ActivatePAPEndpoint** ********************************************************************************/OSStatus ActivatePAPEndpoint(MyEndpointRef *myEp){  OSStatus  err = kOTNoError;  OTResult  result;    //  // Create a PAP endpoint  // Open listener, using the tilisten module to make   // listen/accept/disconnect processing much simpler.  //  myEp-&gt;ep = OTOpenEndpoint(OTCreateConfiguration(&quot;tilisten, pap&quot;), 0, NULL, &amp;err);  if ( myEp-&gt;ep == NULL || err != kOTNoError )  {    myEp-&gt;ep = NULL;        if (err == kOTNoError)      err = memFullErr;          fprintf(stderr,&quot;ERROR: OpenEndpoint(\&quot;pap\&quot;) failed with %ld\n&quot;, err);  }  else  {    SetEPActiveFlag(myEp-&gt;flags);  }#if HANDOFF_EP#else  if (err == kOTNoError)  {      // turn on the EOM option    err = DoNegotiateEOMOption(myEp-&gt;ep, true);    if (err != kOTNoError)    {      ClrEOMOnFlag(myEp-&gt;flags);      fprintf(stderr, &quot;\n\nError setting EOM option!\n&quot;);    }    else    {      SetEOMOnFlag(myEp-&gt;flags);    }  }#endif    if (err == kOTNoError)  {    //    // Install notifier we're going to use for testing - we do this before    //     binding - at this point, we're still synchronous    //    err = OTInstallNotifier(myEp-&gt;ep, EventHandler, (void*)myEp);    if ( err != kOTNoError )    {      fprintf(stderr, &quot;ERROR: InstallNotifier() failed with %ld\n for server endpoint&quot;, err);    }  }      if (err == kOTNoError)  {    /*-------------------------------------------------------------------------    Bind the endpoint endpoint using NBP    ------------------------------------------------------------------------- */#if HANDOFF_EP    err = DoBind(myEp-&gt;ep, kDynamicSocket, kATPType, kMaxHandoffEPs, (char*)gServerNBPNameStr, clen((char*)gServerNBPNameStr));#else    err = DoBind(myEp-&gt;ep, kDynamicSocket, kATPType, 1, (char*)gServerNBPNameStr, clen((char*)gServerNBPNameStr));#endif    if ( err != kOTNoError )    {      fprintf(stderr, &quot;PAPSample: bind of server endpoint failed.\n&quot;);    }    else    {      SetEPBoundFlag(myEp-&gt;flags);    }  }  /*-------------------------------------------------------------------------  Enable self send    have to do this before we set the endpoint into async mode.  ------------------------------------------------------------------------- */  if (err == kOTNoError)  {    err = DoNegotiateSelfSendOption(myEp-&gt;ep, 1);        if (err &lt; kOTNoError)    {      fprintf(stderr, &quot;error negotiating selfsend on main endpoint\n&quot;);      err = kOTNoError;  // don't let this stop the app.    }    else if (err &gt; kOTNoError)    {      fprintf(stderr, &quot;selfsend previously enable\n&quot;);      err = kOTNoError;  // don't let this stop the app.    }    else    {      fprintf(stderr, &quot;selfsend enabled\n&quot;);    }  }      // lastly, set endpoint into async modez  if (err == kOTNoError)    OTSetAsynchronous(myEp-&gt;ep);    /*-------------------------------------------------------------------------  Set the server status string  ------------------------------------------------------------------------- */  if (err == kOTNoError)    BeginSetServerStatusOption(myEp-&gt;ep, kSetIdleStr);        return err;}#if HANDOFF_EP/********************************************************************************* ActivateHandoffEndpoint function - Open prepare a handoff endpoint for the   PAP server********************************************************************************/OSStatus ActivateHandoffEndpoint(MyEndpointRef *myEp){  OSStatus  err;    myEp-&gt;ep = OTOpenEndpoint(OTCreateConfiguration(kPAPName), (OTOpenFlags)NULL, NULL, &amp;err);  if (err == kOTNoError)  {    SetEPActiveFlag(myEp-&gt;flags);      // turn on the EOM option    err = DoNegotiateEOMOption(myEp-&gt;ep, true);    if (err != kOTNoError)    {      ClrEOMOnFlag(myEp-&gt;flags);      fprintf(stderr, &quot;\nError setting EOM option %d\n&quot;, err);    }    else    {      SetEOMOnFlag(myEp-&gt;flags);    }  }  if (err == kOTNoError)  {    err = OTInstallNotifier(myEp-&gt;ep, EventHandler, (void*)myEp);    if ( err != kOTNoError )    {      fprintf(stderr, &quot;ERROR: InstallNotifier() failed with %ld\n for handoff endpoint &amp;d\n&quot;, err);    }    else      OTSetAsynchronous(myEp-&gt;ep);  }  return err;    }#endif/********************************************************************************* InitMyEndpointRef function - zero out the MyEndpointRef structure**   Course we could use the memset function here.********************************************************************************/OSStatus InitMyEndpointRef(MyEndpointRef *myEp){  myEp-&gt;ep = nil;  myEp-&gt;flags = 0;  myEp-&gt;usedQ = OTAllocMem(sizeof(OTLIFO));  if (myEp-&gt;usedQ == nil)    return memFullErr;    myEp-&gt;usedQ-&gt;fHead = nil;    // no packets with this endpoint.    return kOTNoError;}OSStatus InitPAPBuffers(void){  PacketPtr    packetPtr;  OSStatus    err = kOTNoError;  short      i;      // allocate memory for the freeQ  gFreeQ = OTAllocMem(sizeof(OTLIFO));  if (gFreeQ == nil)    return memFullErr;      /* set up the free queue */  gFreeQ-&gt;fHead = nil;      // allocate a temp buffer to be used when packet data overlaps.  gTempPackPtr = OTAllocMem(sizeof(PacketBuffer) + kPAPDataSize);    if (gTempPackPtr == nil)    err = memFullErr;  /* enqueue the packet buffer records to the free queue */  for (i=0; (i&lt;kNumBuffers) &amp;&amp; (err == kOTNoError); i++)  {      // before calling OTAllocMem, we must have already have called      // InitOpenTransport          packetPtr = OTAllocMem(sizeof(PacketBuffer));    if (packetPtr != nil)    {      packetPtr-&gt;flags = 0;      packetPtr-&gt;fLink.fNext = nil;      OTLIFOEnqueue(gFreeQ, &amp;(packetPtr-&gt;fLink));  // first field is fLink field          }    else      err = memFullErr;  }    if (err == kOTNoError)  {    /* show that the buffers have been init'd */    SetBufsInitdFlag(gFlags);    /* note that we don't need to worry about holding memory in the      presence of VM.  The notifier routine will be called at      deferred task time when it is safe to page memory     */      }  else  {    fprintf(stderr, &quot;\n\nError allocating receive buffers!\n&quot;);    fprintf(stderr, &quot;\nBye Bye.\n&quot;);  }      return(err);}  /********************************************************************************* Initialize OpenTransport and call DoTest function********************************************************************************/OSStatus InitPAPServerStuff(void){  OSStatus  err = kOTNoError;  UInt32    growAmt, selection;  UInt32    i;  char    mystr[255];              // register ourselves with OT  OTRegisterAsClient((OTClientName) &quot;PAPServerSample&quot;, nil);    // ask whether to alter current options  fprintf(stdout, &quot;\nDo you want to change the current options?&quot;);  fprintf(stdout, &quot;\n  Options which can be changed:&quot;);  fprintf(stdout, &quot;\n                    1. SetMemoryLimits&quot;);  fprintf(stdout, &quot;\n                    2. Dump packets&quot;);  fprintf(stdout, &quot;\n    Enter - n to use default settings&quot;);  fprintf(stdout, &quot;\n    Enter - y to alter above settings&quot;);  selection = GetYesNoOption();  if (selection == kQuitTest)    err = -1;  else if (selection == kAcceptOption)  {      // ask whether to use the set memory limits option or not    fprintf(stdout, &quot;\nDo you want to set memory limits?&quot;);    selection = GetYesNoOption();        if (selection == kQuitTest)      err = -1;    else if (selection == kAcceptOption)    {      fprintf(stderr, &quot;How much memory to grow heap ?\n&quot;);      fprintf(stdout, &quot;\n  Enter - n to use default setting&quot;);      fprintf(stdout, &quot;\n  Enter - y to set heap growth&quot;);      if (gets(mystr) != 0)      {        stringtonum(mystr, (long*)&amp;growAmt);        OTSetMemoryLimits(growAmt, 0);              }    }        if (err == kOTNoError)    {        // ask whether to use the set memory limits option or not      fprintf(stdout, &quot;\nDo you want to just dump packets?&quot;);      fprintf(stdout, &quot;\n  Enter - n to save packets to default file&quot;);      fprintf(stdout, &quot;\n  Enter - y to dump packets&quot;);      selection = GetYesNoOption();      if (selection == kQuitTest)        err = -1;      else if (selection == kAcceptOption)      {        SetdumpAllPktsFlag(gFlags);      }    }  }  if (err == kOTNoError)  {      // load in the various strings    GetIndString((unsigned char*)&amp;gIdleStr, kServerStrID, kIdleStrID);    GetIndString((unsigned char*)&amp;gBusyStr, kServerStrID, kBusyStrID);    GetIndString((unsigned char*)&amp;gServerNBPNameStr, kServerStrID, kServerNBPStrID);      // covert each string to c    p2c(gIdleStr);    p2c(gBusyStr);    p2c(gServerNBPNameStr);      // initialize the endpoint ref    err = InitMyEndpointRef(&amp;gEp);  }    if (err == kOTNoError)  {#if HANDOFF_EP    for (i = 0; (i &lt; kMaxHandoffEPs) &amp;&amp; (err == kOTNoError) ; i++)      err = InitMyEndpointRef(&amp;gHandoffEp[i]);#endif  }  if (err == kOTNoError)  {    //    // Initialize the buffers    //    err = InitPAPBuffers();  }        if (err == kOTNoError)  {    //    //  Init the server endpoint    //    err = ActivatePAPEndpoint(&amp;gEp);  }#if HANDOFF_EP  if (err == kOTNoError)  {    //    //  Init the handoff endpoint    //    for (i = 0; (i &lt; kMaxHandoffEPs) &amp;&amp; (err == kOTNoError); i++)      err = ActivateHandoffEndpoint(&amp;gHandoffEp[i]);    // RRK 3/10/99 call ActivateHandoffEndpoint    if (err != kOTNoError)    {      fprintf(stderr, &quot;\n\nError opening the handoff endpoint!\n&quot;);      fprintf(stderr, &quot;\nBye Bye.\n&quot;);    }  }#endif    // HANDOFF_EP        return err;  }/********************************************************************************* ReleasePAPMemory********************************************************************************/void ReleasePAPMemory(void){  PacketPtr  packetPtr;  OTLIFO    *otLIFOPtr;  short    i;    if (gTempPackPtr)    OTFreeMem(gTempPackPtr);        // first release the freeQ memory  otLIFOPtr = gFreeQ;  packetPtr = (PacketPtr)OTLIFODequeue(otLIFOPtr);    while (packetPtr != nil)  // while the queue is not empty  {        // free the packetbuffer    OTFreeMem(packetPtr);    packetPtr = (PacketPtr)OTLIFODequeue(otLIFOPtr);        }#if HANDOFF_EP  for (i = 0; i &lt; kMaxHandoffEPs; i++)    //   {    otLIFOPtr = gHandoffEp[i].usedQ;#else    otLIFOPtr = gEp.usedQ;#endif    if (otLIFOPtr-&gt;fHead)      fprintf(stderr, &quot;Am releasing buffer from the used queue.\n\n&quot;);        packetPtr = (PacketPtr)OTLIFODequeue(otLIFOPtr);        while (packetPtr != nil)  // while the queue is not empty    {          // free the packetbuffer      OTFreeMem(packetPtr);      packetPtr = (PacketPtr)OTLIFODequeue(otLIFOPtr);          }  #if HANDOFF_EP  }#endif    OTFreeMem(gFreeQ);  }/********************************************************************************* Close endpoints, and OpenTransport ********************************************************************************/void ClosePAPServerStuff(void){  short i;  if (gEp.ep)    OTSetSynchronous(gEp.ep);  // note that we don't check whether the endpoint is still connected.  Since  // we are leving anyway, let the UnBind call clear things up.  If we did do a  // disconnect here, we would meed to also implement a timer mechanism. so that  // we didn't get hung awaiting a DisconnectComplete event that might not come.  #if HANDOFF_EP  for (i = 0; i &lt; kMaxHandoffEPs; i++)  {    if (gHandoffEp[i].ep)      OTSetSynchronous(gHandoffEp[i].ep);        if (TstEPBoundFlag(gHandoffEp[i].flags))  // is the handoff endpoint bound      DoOTUnbind(gHandoffEp[i].ep);      // unbind the endpoint                          // RRK 3/9/99 change to protect against multiple unbinds        if (gHandoffEp[i].usedQ != nil)      // free allocated memory with usedQ.      OTFreeMem(gHandoffEp[i].usedQ);          if (TstEPActiveFlag(gHandoffEp[i].flags))  // is the handoff endpoint open      OTCloseProvider(gHandoffEp[i].ep);    // close the endpoint        }#endif        if (TstEPBoundFlag(gEp.flags))      // is the server endpoint bound    DoOTUnbind(gEp.ep);          // unbind the endpoint                      // RRK 3/9/99 change to protect against multiple unbinds      if (gEp.usedQ != nil)          // free allocated memory with usedQ.    OTFreeMem(gEp.usedQ);      if (TstEPActiveFlag(gEp.flags))      // is the server endpoint open    OTCloseProvider(gEp.ep);      // close the endpoint      // ReleasePAPMemory();            // release memory before OT goes away                      // not really necessary since we are just going to                       // exit after this.  if (gFreeQ != nil)    OTFreeMem(gFreeQ);    if (TstOTActiveFlag(gFlags))      // is OpenTransport active    CloseOpenTransport();        // shutdown OT services  }////  NetInit:////  This routine does various networking related startup tasks:////  (1) it does InitOpenTransport//  (2) it records the OT version for us.////  result - true - OpenTransport init'd and the correct version is present//         false - problem opening OT or OT version not correct//static Boolean NetInit(){  OSStatus err;  err = Gestalt(gOTVersionSelector, (long*) &amp;gOTVersion);  if (err || (gOTVersion &lt; kOTVersion111))  {    fprintf(stderr, &quot;Please install Open Transport 1.1.1 or later&quot;);    return false;  }    err = InitOpenTransport();  if (err)  {    fprintf(stderr, &quot;NetInit: InitOpenTransport error %d&quot;, err);    return false;  }  return true;}/********************************************************************************* main function********************************************************************************/main(void) {  OSStatus  osstatus;  //  InitGraf(&amp;qd.thePort);          // initialize quickdraw so we can use regions  fprintf(stderr, &quot;PAPServerSample showing implementation of PAP server.\n\n&quot;);  // init the flags variable  gFlags = 0;  if (NetInit() == false)    return 0;    //  // Initialize the OT and the global Endpoints  //  osstatus = InitPAPServerStuff();    if (osstatus == kOTNoError)  {      //    // Run the PAPServer code    //    DoServer();    //  }    //  // Close things down  //  ClosePAPServerStuff();    CheckFileToClose();    fprintf(stderr, &quot;\n\nDone\n&quot;);      return 0;}void DoValueBreak(long value, const char* message){  static short  sDoErrorBreak = 0;  {    Str255  s,        n = &quot;\p&quot;;    s[0] = strlen(message);    BlockMoveData(message,&amp;s[1],s[0]);    if (value &lt; 0)    {      s[0] += 1;      s[s[0]] = '-';      value = -value;    }    while (value)    {      if (n[0])        BlockMoveData(&amp;n[1],&amp;n[2],n[0]);      n[0]++;      n[1] = 48 + (value % 10);      value /= 10;    }    BlockMoveData(&amp;n[1],&amp;s[s[0]+1],n[0]);    s[0] += n[0];    sDoErrorBreak++;    {      short  cnt = sDoErrorBreak;      s[0]++;      s[s[0]] = ',';      s[0]++;      s[s[0]] = ' ';      n[0] = 0;      while (cnt)      {        if (n[0])          BlockMoveData(&amp;n[1],&amp;n[2],n[0]);        n[0]++;        n[1] = 48 + (cnt % 10);        cnt /= 10;      }      BlockMoveData(&amp;n[1],&amp;s[s[0]+1],n[0]);      s[0] += n[0];    }    OTDebugStr((const char *)s);  }}OSStatus BeginSetServerStatusOption(EndpointRef ep, UInt16 whichStr){  OSStatus  err;  unsigned char  *in = &quot;\p._in&quot;;    if (whichStr == kSetIdleStr)  {    err = DoSetServerStatusOption(ep, (char*)&amp;gIdleStr);  }  else  {    err = DoSetServerStatusOption(ep, (char*)&amp;gBusyStr);  }    if (err != kOTNoError)  {    fprintf(stderr, &quot;ServerStatus option call failed\n&quot;);    fprintf(stderr, &quot;however, this will not keep the server from running\n&quot;);    err = kOTNoError;  }    return err;}UInt32 GetYesNoOption(void){  UInt32  result;  char  selection[32];  Boolean  done;    fprintf(stdout, &quot;\n    Enter Q - To quit&quot;);  fprintf(stdout, &quot;\nYour selection -&gt; &quot;);  fflush(stdout);  done = false;  do  {    if (gets(selection) != 0)    {      switch (selection[0])      {        case 'y':        case 'Y':          result = kAcceptOption;          done = true;          break;                case 'n':        case 'N':          result = kDeclineOption;          done = true;          break;        case 'q':        case 'Q':          result = kQuitTest;          done = true;          break;                  default:          fprintf(stdout, &quot;\nInvalid entry - %c, try again -&gt; &quot;, selection);          fflush(stdout);          break;      }    }  } while (!done);    fflush (stdout);  return result;}#if HANDOFF_EP/*  Iterate through the handoff endpoints and find one that doesn't have the busy flag  set - return the pointer else return null*/MyEndpointRef*  FindFreeHandoffEp(void){  short  i;    for (i = 0; i &lt; kMaxHandoffEPs; i++)  {    // RRK 3/9/99 change to protect against the use of a handoff endpoint that is      // not active, will be forced to close, or is busy      // don't allow use of a handoff endpoint if the endpoint is      // busy, or if it will be closed, or if it not active    if ((TstEPBusyFlag(gHandoffEp[i].flags) == false) &amp;&amp;       (TstEPActiveFlag(gHandoffEp[i].flags) == true) &amp;&amp;      (TstOpenPendFlag(gHandoffEp[i].flags) == false) &amp;&amp;      (TstForceCloseFlag(gHandoffEp[i].flags) == false))      return &amp;gHandoffEp[i];  }    return nil;}#endifBoolean EndpointsAllBusy(void){  Boolean    result = true;  #if HANDOFF_EP  short    i;    for (i = 0; (i &lt; kMaxHandoffEPs) &amp;&amp; (result == true); i++)  {    if (TstEPBusyFlag(gHandoffEp[i].flags) == false)      result = false;  // any endpoint not busy means that not all eps are busy  }#else  result = TstEPBusyFlag(gEp.flags);    #endif    return result;}</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/OTPAPSampleServer/listing8.html%3Fid%3DDTS10000252-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/OTPAPSampleServer/listing8.html%3Fid%3DDTS10000252-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/OTPAPSampleServer/listing8.html%3Fid%3DDTS10000252-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>