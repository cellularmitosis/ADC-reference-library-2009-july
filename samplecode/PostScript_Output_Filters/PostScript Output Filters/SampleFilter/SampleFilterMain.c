/***	File:			SampleFilterMain.c****	Description:	The functions in this file control the**					Sample Filter PlugIn.****	Version:		1.0		****	Copyright 1999 Apple Computer. All rights reserved.****	You may incorporate this sample code into your applications without**	restriction, though the sample code has been provided "AS IS" and the**	responsibility for its operation is 100% yours.  However, what you are**	not permitted to do is to redistribute the source as "ABC Sample Code"**	after having made changes. If you're going to re-distribute the source,**	we require that you make it clear in the source that the code was**	descended from Apple Sample Code, but that you've made changes.***/#include <CodeFragments.h>#include <Collections.h>#include <Resources.h>#include <String.h>#include "DebugMisc.h"#include "Macros.h"#include "PSOutputFilters.h"#include "Hints.h"#include "SampleFilterMain.h"#include "SampleFilterPanel.h"#include "SampleFilterResources.h"#include "SampleFilterHints.h"/*	There are a couple of different ways we can build our sample depending on some defines.	If the define DOAPPLEPPDTEST is set to 1, then this filter 	looks at the value of current PPD's *PCFileName main keyword	and does not run the filter if it starts with 'APL'		If the define DOSPOOLERCHECK is set to 1, then this filter	checks the printer's default collection to determine whether the	set up printer is a spooler.  	If the define DYNAMICLW8UILOAD is set to 1, then this filter	dynamically resolves the symbol LWGetPrInfoCollection instead	of using the weak link to the LaserWriter8.Lib file containing	a LW8UILib stub library. This approach is more complex than simply	weak linking but gives more control to the filter. This define only	is used if the DOSPOOLERCHECK define is also set to 1.*/#define DOAPPLEPPDTEST 0#define DOSPOOLERCHECK 0#define DYNAMICLW8UILOAD 0// this sample only has one panel but if it had additional ones we'd// define them hereenum {	kFirstPanel,//	kSecondPanel,	kNumPanels};/* static Global data */OSErr InitLib(CFragInitBlockPtr initBlkPtr);void TerminateLib(void);static short panelCount;static PanelRef panelRefs[kNumPanels];static OSStatus checkPPDMatch(Collection criteriaCollection, Boolean *doesMatchP);static OSStatus checkIfSpooler(LWRef lwRef, Boolean *isSpoolerP);OSErr InitLib(CFragInitBlockPtr initBlkPtr){	Unused(initBlkPtr);		panelCount = 0;	return(noErr);}void TerminateLib(void){	panelCount = 0;}OSStatus psPanelPlugInLibInitData(LWRef lwRef, void **libDataH, short resFRef, unsigned long *libSignatureP){	OSStatus err = noErr;		Unused(lwRef);		*libDataH = (void *)resFRef;						// save our resource fork fRef for later use	*libSignatureP = kSampleFilterSignature;		return(err);}void psPanelPlugInLibCloseData(LWRef lwRef, void *libDataP, Collection jobInfo, Boolean *doItP){	OSStatus err = noErr;	kHintColorModeVar colorMode;	SInt32 size = sizeof(PSColorMode);	short holdResFile, resFRef = (short)libDataP;	Unused(lwRef);	/*		Just to demonstrate how to do this, we'll put up an alert that lets the user		back out if the color mode has been set to black and white. 	*/	// only bother if we are being called because the user clicked OK or Save in the dialog	if(*doItP){		err = GetCollectionItem(jobInfo, kHintColorModeTag, kHintColorModeId, &size, &colorMode);		if(err == collectionItemNotFoundErr){			err = noErr;			colorMode = kColorMode;		}				// need to make sure our resource fork is the current one if we are going to get resources		if(!err && resFRef != -1 && colorMode == kBlackAndWhiteMode) {			holdResFile = CurResFile();			UseResFile(resFRef);			if( CautionAlert(kSETTINGSALRT_ALRT, NULL) == cancel ) {				// cancel the print job if the user has cancelled our dialog				*doItP = false;			}			UseResFile(holdResFile);		}	}		// no need to dispose of anything in libDataP since we only stored	// the resource fork fRef there}OSStatus psPanelPlugInLibKeepRunning(LWRef lwRef, Collection criteriaCollection, Boolean *keepRunningP, void *libDataP){	OSStatus err = noErr;	Boolean keepRunning;	Unused(libDataP);		/*		Here we might potentially check 'criteriaCollection' for whether we want to run.				Let's see if the *PCFileName of the current PPD is one in our list.	*/	err = checkPPDMatch(criteriaCollection, &keepRunning);			/* 	good place to demonstrate that we can get the prefs collection and determine whether		to keep running. Note that the prefs collection may not reflect		settings we expect because the user may not have set up their printer or there		may not be bi-directional communication to the printer.				Here, just for fun, we'll disable ourselves if the printer represents a spooler.	*/	if(!err && keepRunning){		Boolean isSpooler;		err = checkIfSpooler(lwRef, &isSpooler);		if(!err && isSpooler)keepRunning = false;	} 		/*		If keepRunning is false then we'll tell LaserWriter 8 that we no longer want to 		run for this new printer.	*/	*keepRunningP = err ? false : keepRunning;			return(err);}OSStatus psPanelSetCriteria(LWRef lwRef, Collection criteriaCollection, short resFRef){	OSStatus err = noErr;	Handle resH;	kHintPanelDriverVersVar driverVers = 0x08000000;	// vers data for LaserWriter 8.0	Unused(lwRef);		// as an example, we'll advertise that we require LaserWriter 8.0 and later	err = AddCollectionItem	(criteriaCollection, kHintPanelDriverVersTag, kHintPanelDriverVersId, 														sizeof(kHintPanelDriverVersVar), &driverVers);	if(!err) {		if(resFRef != -1) {			short holdResFile = CurResFile();			UseResFile(resFRef);			resH = Get1Resource(kPluginInfoType, kPluginInfoID);			if(resH) {				err = AddCollectionItemHdl(criteriaCollection, kPluginInfoType, kPluginInfoID, resH);				ReleaseResource(resH);			} else {				err = ResError();				if(!err) {					err = resNotFound;				}			}			UseResFile(holdResFile);		}	}	return(err);}OSStatus psPanelAddMenu(LWRef lwRef, PanelRef panelRef, void *dataP, StringPtr panelName, 			unsigned long bufSize, Boolean *addItP){	OSStatus err = noErr;		Unused(lwRef);		*addItP = false;	if(panelRef == panelRefs[kFirstPanel]) {		err = sampleAddMenu(dataP, panelName, bufSize, addItP);	}else{#if 0		if(panelRef == panelRefs[kSecondPanel]){			err = sampleAddMenuTwo(dataP, panelName, bufSize, addItP);		}else#endif			ckAssert(false);	}			return(err);}OSStatus psPanelRegister(LWRef lwRef, PanelRef panelRef, Collection criteriaCollection, Boolean *addPanelP, 							const Rect *panelRectP,							short *ditlIDP, Handle *ditlHP, void **dataH, void *libDataP){	OSStatus err = noErr;	Boolean keepRunning = true;	Unused(panelRectP);	Unused(ditlHP);				switch(panelCount) {	 case kFirstPanel:		/*			Here we might potentially check 'criteriaCollection' for whether we want to run at all for this printer.						Let's see if the PCFileName of the current PPD is one in our list		*/		err = checkPPDMatch(criteriaCollection, &keepRunning);					/* 	good place to demonstrate that we can get the prefs collection and determine whether			to keep running. Note that the prefs collection may not reflect			settings we expect because the user may not have set up their printer or there			may not be bi-directional communication to the printer.						Here, just for fun, we'll disable ourselves if the printer represents a spooler.		*/		if(!err && keepRunning){			Boolean isSpooler;			err = checkIfSpooler(lwRef, &isSpooler);			if(!err && isSpooler)keepRunning = false;		}		/*			If keepRunning is false then we tell LaserWriter 8 that we are not adding any panels. Note that			we check the PPD match and spooler in psPanelRegister AND psPanelPlugInLibKeepRunning. This is			done since psPanelPlugInLibKeepRunning is only called if we're already been running and the			user switches printers. By also using psPanelRegister, we can show no panels if the first			printer we are loaded for is one we aren't interested in.		*/		if(!err && keepRunning){	 		panelRefs[kFirstPanel] = panelRef;	 		err = sampleRegisterPanel(ditlIDP, dataH, libDataP);	 		*addPanelP = err ? false : true;	 	}else{	 		*addPanelP = false;	 	}	 	break;#if 0	 case kSecondPanel:	 	panelRefs[kSecondPanel] = panelRef;	 	err = sampleRegisterPanelTwo(ditlIDP, dataH, libDataP);	 	*addPanelP = err ? false : true;	 	 	break;#endif	 default:	 	*addPanelP = false;	 	break;	}	panelCount++;		return(err);}OSStatus psPanelPrSpecificInitData(LWRef lwRef, PanelRef panelRef, void *dataP, Collection plugInPrInfo){	OSStatus err = noErr;	Unused(lwRef);		if(panelRef == panelRefs[kFirstPanel]) {		err = samplePrSpecificInitData(dataP, plugInPrInfo);	}else{#if 0		if(panelRef == panelRefs[kSecondPanel]){			err = samplePrSpecificInitDataTwo(dataP, plugInPrInfo);		}else#endif			ckAssert(false);	}		return(err);}OSStatus psPanelPrSpecificCloseData(LWRef lwRef, PanelRef panelRef, void *dataP, Boolean doIt){	OSStatus err = noErr;	Unused(lwRef);	Unused(dataP);	Unused(doIt);		if(panelRef == panelRefs[kFirstPanel]) {	}else{#if 0		if(panelRef == panelRefs[kSecondPanel]{		}else#endif			ckAssert(false);	}			return(err);}OSStatus psPanelInitData(LWRef lwRef, PanelRef panelRef, void *dataP, Collection plugInHints){	OSStatus err = noErr;		Unused(lwRef);	Unused(panelRef);	Unused(dataP);	Unused(plugInHints);		err = sampleInitData(dataP, plugInHints);			return(err);}OSStatus psPanelCloseData(LWRef lwRef, PanelRef panelRef, void *dataP, Boolean doIt){	OSStatus err = noErr;	Unused(lwRef);		if(panelRef == panelRefs[kFirstPanel]) {		err =  sampleCloseData(dataP, doIt);	} else		ckAssert(false);			return(err);}OSStatus psPanelPrSpecificInit(LWRef lwRef, PanelRef panelRef, void *dataP, DialogPtr dp, short offset){	OSStatus err = noErr;	Unused(lwRef);		if(panelRef == panelRefs[kFirstPanel]) {		err =  samplePrSpecificInit(dataP, dp, offset);	}else{#if 0		if(panelRef == panelRefs[kSecondPanel]{			err = samplePrSpecificInitTwo(dataP, dp, offset);		}else#endif			ckAssert(false);	}		return err;}OSStatus psPanelPrSpecificClose(LWRef lwRef, PanelRef panelRef, void *dataP, DialogPtr dp, short offset){	OSStatus err = noErr;		Unused(lwRef);	Unused(panelRef);	Unused(dataP);			Unused(dp);	Unused(offset);		return err;}OSStatus psPanelInit(LWRef lwRef, PanelRef panelRef, void *dataP, DialogPtr dp, short offset){	OSStatus err = noErr;	Unused(lwRef);		if(panelRef == panelRefs[kFirstPanel]) {		err = sampleInit(dataP, dp, offset);	}else{#if 0		if(panelRef == panelRefs[kSecondPanel]{			err = sampleInitTwo(dataP, dp, offset);		}else#endif			ckAssert(false);	}		return err;}OSStatus psPanelClose(LWRef lwRef, PanelRef panelRef, void *dataP, DialogPtr dp, short offset){	OSStatus err = noErr;	Unused(lwRef);		Unused(panelRef);	Unused(dataP);			Unused(dp);	Unused(offset);		if(panelRef == panelRefs[kFirstPanel]) {		err = sampleClose(dataP, dp, offset);	}else{#if 0		if(panelRef == panelRefs[kSecondPanel]{		}else#endif			ckAssert(false);	}		return(err);}OSStatus psPanelItem(LWRef lwRef, PanelRef panelRef, void *dataP, DialogPtr dp, short item, 								short offset, short ctlVal){	OSStatus err = noErr;	Unused(lwRef);		if(panelRef == panelRefs[kFirstPanel]) {		err = sampleItem(dataP, dp,item, offset, ctlVal);	}else{#if 0		if(panelRef == panelRefs[kSecondPanel]{			err = sampleItemTwo(dataP, dp,item, offset, ctlVal);		}else#endif			ckAssert(false);	}		return(err);}OSStatus psPanelFilter(LWRef lwRef, PanelRef panelRef, void *dataP, DialogPtr dp, short offset, EventRecord *ep, 								short *itemHitP, Boolean *weHandledItP){	OSStatus err = noErr;	Unused(lwRef);		if(panelRef == panelRefs[kFirstPanel]) {		err = sampleFilter(dataP, dp,offset, ep, itemHitP, weHandledItP);	}else{#if 0		if(panelRef == panelRefs[kSecondPanel]{			err = sampleFilterTwo(dataP, dp,offset, ep, itemHitP, weHandledItP);		}else#endif			ckAssert(false);	}		return(err);}OSStatus psPanelCheckRange(LWRef lwRef, PanelRef panelRef, void *dataP, 										DialogPtr dp, short offset, Boolean *doitP){	OSStatus err = noErr;	Unused(lwRef);		if(panelRef == panelRefs[kFirstPanel]) {		err = sampleCheckRange(dataP, dp, offset, doitP);	}else{#if 0		if(panelRef == panelRefs[kSecondPanel]{			err = sampleCheckRangeTwo(dataP, dp,offset, ep, itemP, weHandledItP);		}else#endif			ckAssert(false);	}		return(err);}OSStatus psPanelSaveButton(LWRef lwRef, PanelRef panelRef, void *dataP, Collection plugInPrInfo){	OSStatus err = noErr;	Unused(lwRef);		if(panelRef == panelRefs[kFirstPanel]) {		err = sampleSaveButton(dataP, plugInPrInfo);	}else{#if 0		if(panelRef == panelRefs[kSecondPanel]{			err = sampleSaveButtonTwo(dataP, plugInPrInfo);		}else#endif			ckAssert(false);	}	return(err);}static OSStatus checkPPDMatch(Collection criteriaCollection, Boolean *doesMatchP){	OSStatus err = noErr;	Boolean doesMatch = true;#if DOAPPLEPPDTEST	if(!err){			kHintPanelPCFileNameVar pcFileName;		SInt32 size = sizeof(kHintPanelPCFileNameVar);		char *applePPDPCFileName = "APL";		SInt32 appleSize = strlen(applePPDPCFileName);				// LaserWriter 8 stores this collection item in the criteriaCollection if the *PCFileName		// exists in the current PPD file for the current printer		err = GetCollectionItem(criteriaCollection, kHintPanelPCFileNameTag, kHintPanelPCFileNameId, 											&size, pcFileName+1);		if(!err){			pcFileName[0] = size;		}else{			if(err == collectionItemNotFoundErr){				err = noErr;				pcFileName[0] = 0;				doesMatch = false;			}		}				// do the first 3 characters match the PPD PC Filename?		if(!err && doesMatch){			if(pcFileName[0] >= appleSize){				short i;				unsigned char *theName = pcFileName;				theName++;	// point to the first character past the size byte				for(i = 0; i < appleSize; i++){					if(theName[i] != applePPDPCFileName[i]){						doesMatch = false;						break;					}				}			}		}	}#else	Unused(criteriaCollection);#endif	*doesMatchP = err ? false : doesMatch;	return err;}static OSStatus checkIfSpooler(LWRef lwRef, Boolean *isSpoolerP){	OSStatus err = noErr;	Boolean isSpooler = false;#if DOSPOOLERCHECK	Collection prefs = NULL;#if DYNAMICLW8UILOAD	OSStatus libErr = noErr;	CFragSymbolClass symClass;	CFragConnectionID connID;	Str255	buff;	Ptr mainAdr;	LWGetPrInfoCollectionProc lwGetPrInfoCollection;	libErr = GetSharedLibrary("\pLW8UILib", kCompiledCFragArch, kLoadCFrag, &connID, &mainAdr, buff);	if (!libErr) {		libErr = FindSymbol(connID, "\pLWGetPrInfoCollection", (Ptr *)&lwGetPrInfoCollection, &symClass);		if (!libErr)prefs = (*lwGetPrInfoCollection)(lwRef);		CloseConnection(&connID);	}#else	// if we are not dynamically loading LW8UILib but are weak linking instead, 	// we check that our weak link has been satisfied before calling the routine	if(LWGetPrInfoCollection != (void *)kUnresolvedCFragSymbolAddress){ 		prefs = LWGetPrInfoCollection(lwRef);	}else{		// this should not happen but lets generate an assert in our debug code if it does		ckAssert(false);	}#endif		// DYNAMICLW8UILOAD	// only continue with our test if we got a prefs collection from our code above	if(prefs){		kHintADOSpoolerVar checkSpooler;		SInt32 size = sizeof(checkSpooler);		// this hint will be in the printer's prefs collection if the printer was set up		// and there was bi-directional communication at the time		err = GetCollectionItem(prefs, kHintADOSpoolerTag, kHintADOSpoolerId, &size, &checkSpooler);				// be prepared for our spooler collection item to not exist		if(err == collectionItemNotFoundErr){			err = noErr;			checkSpooler = kTriUnknown;		// we don't know if the printer is a spooler or not		}				// only if we know for sure that the printer is a spooler do we act accordingly 		if(!err && checkSpooler == kTriTrue){			isSpooler = true;		}	}#else	Unused(lwRef);#endif		// DOSPOOLERCHECK	// here we are saying that if we got an error then the printer is not a spooler	// not very conservative but users of this sample code will have to decide for themselves	*isSpoolerP = err ? false : isSpooler;	return err;}short getControl(DialogPtr dialog, short item)/*	Return the value of item if item is a control.*/{	short itemType, result = 0;	Handle itemH;	Rect itemBox;		if(item > 0 && item < 100) {		GetDialogItem(dialog, item, &itemType, &itemH, &itemBox);		if(itemType & ctrlItem)				result = GetControlValue((ControlHandle)itemH);	}		return(result);}short setControl(DialogPtr dp, short item, short value)/*	Sets a control in a dialog's item list to the given	value. If the dialog item is not a control then this	function does nothing. If value == -1, the control value	is toggled (i.e., checkboxes).*/{	short type, curValue;	ControlHandle hC;	Rect r;		if(item > 0 && item < 100) {		GetDialogItem(dp, item, &type, (Handle *)&hC, &r);		if(type & ctrlItem) {			curValue = (*hC)->contrlValue;			if( (value == -1) ) {				value = !curValue;			}			if(curValue != value) {				SetControlValue(hC, value);			}		}	}		return(value);}void setRadio(DialogPtr dp, short first, short last, short which){	short item;		for(item = first; item <= last; item++) {		 setControl(dp, item, item == which);	}}OSStatus setText(DialogPtr dp, short item, ConstStr255Param text){	OSStatus err = noErr;	short type;	Rect r;	Handle h;	ControlRef controlRef = nil;		err = GetDialogItemAsControl(dp, item, &controlRef);		if(!err) {		err = SetControlData(controlRef, 0 , kControlStaticTextTextTag, *text, (Ptr)text + 1);		if(!err && controlRef)			Draw1Control(controlRef);	} else if(err == errItemNotControl) {		err = noErr;		GetDialogItem(dp, item, &type, &h, &r);		if( (type & statText) || (type & editText) ) {			SetDialogItemText(h, text);		} 	}		return(err);}OSStatus getText(DialogPtr dp, short item, Byte *text){	OSStatus err = noErr;	short type;	Handle h;	Rect r;	ControlRef controlRef;	long actualSize;		err = GetDialogItemAsControl(dp, item, &controlRef);		if(!err) {		err = GetControlData(controlRef, 0 , kControlStaticTextTextTag, sizeof(Str255), (Ptr)text + 1, &actualSize);		*text = actualSize;	} else if(err == errItemNotControl) {		err = noErr;		GetDialogItem(dp, item, &type, &h, &r);		if( (type & statText) || (type & editText) ) {			GetDialogItemText(h, text);		} 	}		return(err);}