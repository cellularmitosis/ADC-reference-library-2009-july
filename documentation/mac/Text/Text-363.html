<!-- Generated by Harlequin WebMaker 2.2.3 (23-Apr-1996)
LispWorks 3.2.2 -->
<HTML> <HEAD>
<TITLE>Converting Text(IM: Tx)</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING363></A>



<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->


<!-- Main Body -->

<CENTER>
<P>
<A HREF="Text-362.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="Text-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="Text-594.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="Text-364.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="Text-2.html"><B>Text</B></A> / <BR><DD><A HREF="Text-354.html"><B>Chapter 6 - Script Manager</B></A> / <A HREF="Text-359.html"><B>Using the Script Manager</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING363-0></A>
<H2>Converting Text</H2>
 The third principal use for the Script Manager is in converting text from one form to another, for two specific purposes: tokenization and transliteration. The routines described in this section are used by specialized applications only. You can use these Script Manager routines to<P>
<UL>
<LI>lexically convert text of the current script system into a series of language-independent tokens (tokenization)
<LI>phonetically convert text of one subscript into text of another subscript within the same script system (transliteration)<P>
</UL>
 Most text-processing applications have no need to perform either of these tasks. However, if your program needs to evaluate programming statements or logical or mathematical expressions in a script-independent fashion, you may want to use the Script Manager's tokenization facility. If your program performs phonetic conversion, for text input or for any other purpose, you may want to use the Script Manager's transliteration facility.<P>
<A NAME=HEADING363-5></A>
<H3><A NAME=MARKER-9-741></A>Tokenization</H3>
 <A NAME=MARKER-2-134></A>Programs that parse structured text expressions (such as compilers, assemblers, and scripting-language interpreters) usually assign sequences of characters to categories called<A NAME=MARKER-2-743></A> tokens<B>.</B> Tokens are abstract entities that stand for names, operators, and quoted literals without making assumptions that depend on a particular writing system.<P>
 The Script Manager provides support for this conversion, called <A NAME=MARKER-2-744></A><B>tokenization.</B> Each script system's international tokens resource (type <CODE>'itl4'</CODE>) contains tables of token information used by the Script Manager's <CODE>IntlTokenize</CODE> function to identify the elements in an arbitrary string of text and convert them to tokens. The token stream created by <CODE>IntlTokenize</CODE> can be used as input to a compiler or interpreter, or to an expression evaluator such as might be used by a spreadsheet or database program.<P>
 The <CODE>IntlTokenize</CODE> function allows your application to create a common set of tokens from text in any script system. For example, a whitespace character might have different character-code representations in different script systems. The <CODE>IntlTokenize</CODE> function can assign the token <CODE>tokenWhite</CODE> to any whitespace character, thus removing dependence on any character-encoding scheme.<P>
 When you call <CODE>IntlTokenize</CODE>, you pass it the source text to interpret. <CODE>IntlTokenize</CODE> parses the text and returns a list of the tokens that make up the text. Among the token types that it recognizes are whitespace characters; newline or return characters; sequences of alphabetic, numeric, and decimal characters; the end of a stream of characters; unknown characters; alternate digits and decimals; and many fixed token symbols, such as open parentheses, plus and minus signs, commas, and periods. See <A HREF=Text-370.html#MARKER-9-796>page 6-58</A> for a complete list of recognized tokens and their defined constants.<P>
 <CODE>IntlTokenize</CODE> can return not only a list of the token types found in your text but also a normalized copy of the text of each of the tokens, so that the content of your source text is preserved along with the tokens generated from it.<P>
 <A HREF=#MARKER-9-745>Figure 6-3</A> illustrates the process that occurs when <CODE>IntlTokenize</CODE> converts text into a sequence of tokens. It shows that very different text from two separate script systems can result in the same set of tokens.<P>
<B>Figure 6-3  <A NAME=MARKER-9-745></A>The action of <CODE>IntlTokenize</CODE></B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/SM_L-02.jpg">
 Because it uses the tokens resource belonging to the script system of the text being analyzed, <CODE>IntlTokenize</CODE> works on only one script run at a time. However, one way to process multiscript text is to make successive calls to <CODE>IntlTokenize</CODE> and append the results of each to the token list, thus building a single token stream from multiple calls.<P>
<DL>
<DT><B>Note</B>
<DD>The <CODE>IntlTokenize</CODE> function does not provide complete lexical analysis; it returns a simple, sequential list of tokens. If necessary, your application can then process the output of <CODE>IntlTokenize</CODE> at a more sophisticated lexical or syntactic level.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
 The rest of this section introduces the data structures used by <CODE>IntlTokenize</CODE>, discusses specific features and how it handles specific types of text, and gives an example.<P>
<A NAME=HEADING363-17></A>
<H4>Data Structures</H4>
 <A NAME=MARKER-2-171></A>When you call <CODE>IntlTokenize</CODE>, you supply it with a pointer to a <B>token block record,</B> a data structure that you have allocated. The token block record has a pointer to your source text and pointers to two other buffers you have allocated--one to hold the list of <B>token records</B> that <CODE>IntlTokenize</CODE> generates and the other to hold the string representations of those tokens, if you choose to have strings generated. See <A HREF=#MARKER-9-747>Figure 6-4</A>.<P>
 <CODE>IntlTokenize</CODE> fills in the token list and the string list, updates information in the token block record, and returns the information to you.<P>
<B>Figure 6-4  <CODE><A NAME=MARKER-9-747></A>IntlTokenize</CODE> data structures <A NAME=MARKER-2-748></A>(simplified)</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/SM_L-08.jpg">
<A NAME=HEADING363-22></A>
<H4>Delimiters for Literals and Comments</H4>
 <A NAME=MARKER-2-529></A>Your application may specify up to two pairs of delimiters each for quoted literals and for comments. Quoted literal delimiters consist of a single symbol, and comment delimiters may be either one or two symbols (including the newline character for notations whose comments automatically terminate at the end of a line). Each delimiter is represented by a token, as is the entire literal between the opening and closing delimiters--except when the literal contains an escape character; see <DFN><A HREF=#MARKER-9-751>"Escape Character"</A></DFN> (next).<P>
 <A NAME=MARKER-2-750></A>Limited support exists for nested comments. Comments may be nested if so specified by the <CODE>doNest</CODE> flag, with one restriction that must be strictly observed to prevent <CODE>IntlTokenize</CODE> from malfunctioning: nesting is legal only if both the left and right delimiters for the comment token are composed of two symbols each. If your application specifies two different sets of comment delimiters, then the <CODE>doNest</CODE> flag always applies to both.<P>
<DL>
<DT><B>IMPORTANT</B>
<DD>When using nested comments specified by the <CODE>doNest</CODE> flag, test thoroughly to ensure that the requirements of <CODE>IntlTokenize</CODE> are met.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
<A NAME=HEADING363-26></A>
<H4><A NAME=MARKER-9-751></A>Escape Character</H4>
 <A NAME=MARKER-8-163></A>The characters that compose literals within quotations and comments are normally defined to have no syntactic significance; however, the escape character within a quoted literal signals that the following character should not be treated as the closing delimiter. Outside of the limits of a quoted literal, the escape character has no significance and is not recognized as an escape character.<P>
 For example, if the backslash "\" (token type = <CODE>tokenBackSlash</CODE>) is defined as the escape character, the <CODE>IntlTokenize</CODE> function would consider it to be an escape character in the following string, and would not consider the second quotation mark to be a closing delimiter:<P>
<PRE>
&quot;This is a quote \&quot; within a quoted literal&quot;
</PRE>
 In the following string, however, <CODE>IntlTokenize</CODE> would not consider the backslash to be an escape character, and therefore would consider the first quotation mark to be an opening delimiter:<P>
<PRE>
This is a backslash \&quot; preceding a quoted literal&quot;
</PRE>
<A NAME=HEADING363-32></A>
<H4>Alphanumeric Tokens</H4>
 The <CODE><A NAME=MARKER-2-753></A>IntlTokenize</CODE> function allows you to specify that numeric characters do not have to be considered numbers when mixed with alphabetic characters. If a flag is set, alphabetic sequences may include digits, as long as first character is alphabetic. In that case the sequence <CODE>Highway61</CODE> would be converted to a single alphabetic token, instead of the alphabetic token <CODE>Highway</CODE> followed by the number <CODE>61</CODE>.<P>
<A NAME=HEADING363-34></A>
<H4>Alternate Numerals</H4>
 <A NAME=MARKER-2-754></A>Some script systems have not only Western digits (that is, the standard ASCII digits, the numerals 0 through 9), but also their own numeral codes. <CODE>IntlTokenize</CODE> recognizes these alternate numerals and constructs tokens from them, such as <CODE>tokenAltNum</CODE> and <CODE>tokenAltReal<B>.</B></CODE><P>
<A NAME=HEADING363-36></A>
<H4>String Generation</H4>
 <A NAME=MARKER-2-755></A>To preserve the content of your source text as well as the tokens generated from it, your application may instruct <CODE>IntlTokenize</CODE> to generate null-terminated, even-byte-boundaried Pascal strings corresponding to each token. <CODE>IntlTokenize</CODE> constructs the strings according to these rules:<P>
<UL>
<LI>If the token is anything but alphabetic or numeric, <CODE>IntlTokenize</CODE> copies the text of the token verbatim into the Pascal string.
<LI>If the token represents non-Roman alphanumeric characters, <CODE>IntlTokenize</CODE> copies the characters verbatim into the Pascal string.
<LI>If the token represents Roman alphabetic characters, <CODE>IntlTokenize</CODE> normalizes them to standard ASCII characters (such as by changing 2-byte Roman to 1-byte Roman) and writes them into the Pascal string.
<LI>If the token represents numeric characters--even if the script system uses an alternate set of digits--<CODE>IntlTokenize</CODE> normalizes them into standard ASCII numerical digits, with a period as the decimal separator, and creates a string from the result. This allows users of other script systems to transparently use their own numerals or Roman characters for numbers or keywords.<P>
</UL>
 The tokens resource includes a string-copy routine that performs the necessary string normalization.<A NAME=MARKER-2-756></A><P>
<A NAME=HEADING363-43></A>
<H4>Appending Results</H4>
 You can make a series of calls to <CODE>IntlTokenize</CODE> and append the results of each call to the results of previous calls. You can instruct <CODE>IntlTokenize</CODE> to use the output values for certain parameters from each call as input values to the next call. At the end of your sequence of calls you will have--in order--all the tokens and strings generated from the calls to <CODE>IntlTokenize</CODE>.<P>
 Appending results is the only way to use <CODE>IntlTokenize</CODE> to parse a body of text that has been written in two or more different script systems. Because <CODE>IntlTokenize</CODE> can operate only on a single script run at a time, you must first divide your text into script runs and pass each script's character stream separately to <CODE>IntlTokenize</CODE>.<P>
<A NAME=HEADING363-46></A>
<H4>Example</H4>
 Here is an example of how the <CODE>IntlTokenize</CODE> function breaks text into segments that that can be processed in a way that is meaningful in a particular script system. The source text is identical to that shown in <A HREF=#MARKER-9-745>Figure 6-3 on page 6-39</A>. Assume that you send this programming-language statement to <CODE>IntlTokenize</CODE>:<P>
<PRE>
total3=sum(A3:B9);{yearly totals}
</PRE>
 <CODE>IntlTokenize</CODE> might convert that into the following sequence of tokens and token strings:
<TABLE BORDER="0" CELLPADDING=3><TH ALIGN=LEFT>Token<TH>Token string<TR>
<TD>tokenAlpha<TD>'total3'<TR>
<TD>tokenEqual<TD>'='<TR>
<TD>tokenAlpha<TD>'sum'<TR>
<TD>tokenLeftParen<TD>'('<TR>
<TD>tokenAlpha<TD>'A3'<TR>
<TD>tokenColon<TD>':'<TR>
<TD>tokenAlpha<TD>'B9'<TR>
<TD>tokenRightParen<TD>')'<TR>
<TD>tokenSemicolon<TD>';'<TR>
<TD>tokenLeftComment<TD>'{'<TR>
<TD>tokenLiteral<TD>'yearly totals'<TR>
<TD>tokenRightComment<TD>'}'</TABLE>
<P>
 This token sequence could then be processed meaningfully by an expression evaluator. If the statement had been created under a different script system, in which comment delimiters, semicolons, or equality were represented with different character codes, the resulting token sequence would still be the same and could be evaluated identically--although the strings generated from the tokens would be different.<P>
 The <CODE>IntlTokenize</CODE> function is described further on <A HREF=Text-400.html#MARKER-9-980>page 6-92</A>.<A NAME=MARKER-2-758></A><P>
<A NAME=HEADING363-52></A>
<H3><A NAME=MARKER-9-759></A>Transliteration</H3>
 <A NAME=MARKER-2-760></A>The Script Manager provides support for <A NAME=MARKER-2-761></A><B>transliteration,</B> the automatic conversion of text from one form to another within a single script system. In the Roman script system, transliteration simply means case conversion. In Japanese, Chinese, and Korean script systems, it means the phonetic conversion of characters from one subscript to another.<P>
 The <CODE>TransliterateText</CODE> function performs the conversions. Tables that control transliteration for a 1-byte script system are in its international string-manipulation (<CODE>'itl2'</CODE>) resource; the tables for a 2-byte script system are in the script's transliteration (<CODE>'trsl'</CODE>) resource. This illustrates the difference in the meaning of transliteration for the two types of script systems: case conversion information is in the string-manipulation resource, whereas information needed for phonetic conversion is in the transliteration resource. The transliteration resource is available to all script systems, although currently no 1-byte script systems make use of it.<P>
 <A NAME=MARKER-2-762></A>Transliteration here does not mean translation; the Macintosh script management system cannot translate text from one language to another. Nor does it include context-sensitive conversion from one subscript to another; that can be accomplished with an input method. See, for example, the discussions of input methods in the chapters "Introduction to Text on the Macintosh" and "Text Services Manager" in this book. Transliteration can, however, be an initial step for those more complex conversions:<P>
<UL>
<LI>Within the Japanese script system, you can transliterate from Hiragana to Romaji (Roman) and from Romaji to Katakana, and vice versa. You cannot transliterate from Hiragana to Kanji (Chinese characters). However, transliteration from Romaji to Katakana or Hiragana could be an initial step for an input method that would complete the context-sensitive conversion to Kanji.
<LI>Within the (traditional) Chinese script system, you can transliterate from the Bopomofo or Zhuyinfuhao (phonetic) subscript to Roman, and vice versa. You cannot transliterate from Zhuyinfuhao to Hanzi (Chinese characters). However, transliteration from Zhuyinfuhao to Pinyin could be an initial step for an input method that would complete the context-sensitive conversion to Hanzi.
<LI>Within the Korean script system, you can transliterate from Roman to Jamo, from Jamo to Hangul, from Hangul to Jamo, and from Jamo to Roman. It is therefore possible to transliterate from Hangul to Roman and from Roman to Hangul by a two-step process. It is not possible to transliterate from Hangul into Hanja (Chinese characters). Transliteration from Jamo to Hangul is used by the input method supplied with the Korean script system; that transliteration is sufficient when Hanja characters are not used. To include Hanja characters requires additional context-sensitive processing by the input method.<P>
</UL>
 The Script Manager defines two basic types of transliteration you can perform: conversion to Roman characters, and conversion to a native subscript within the same non-Roman script system. Within those categories there are subtypes. For instance, in Roman text, case conversion can be either to uppercase or to lowercase; in Japanese text, native conversion can be to Romaji, Hiragana, or Katakana.<P>
 You can specify which types of text can undergo conversion. For example, in Japanese text you can, if you want to, limit transliteration to Hiragana characters only. Or you can restrict it to case conversion of Roman characters only.<P>
 Not all combinations of transliteration are possible, of course. Case conversion cannot take place in scripts or subscripts that do not have case; transliteration from one subscript to another cannot take place in scripts that do not have subscripts.<P>
 Transliteration is not perfect. Typically, it gives a unique result within a 2-byte script, although it may not always be the most phonetic or natural result. Transliterations may be incorrect in ambiguous situations; by analogy, in certain transliterations from English "th" could refer to the sound in the, the sound in <I>thick</I>, or the sounds in <I>boathouse</I>.<P>
 <A HREF=#MARKER-9-763>Figure 6-5</A> shows some of the possible effects of transliteration. Each string on the right side of the figure is the transliterated result of its equivalent string on the left.<P>
<UL>
<LI>Roman characters can be transposed from uppercase to lowercase and vice versa--even if they are embedded in text that also contains Kanji.
<LI>One-byte Roman characters can be converted to 2-byte Roman characters. (The glyphs for 2-byte Roman characters are typically larger and spaced farther apart, for better appearance when interspersed with ideographic glyphs.)
<LI>Katakana can be converted to Hiragana.
<LI>Hiragana can be converted to 1-byte Roman characters.<P>
</UL>
<B>Figure 6-5  <A NAME=MARKER-9-763></A>The effects of transliteration</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/SM_L-03.jpg">
 <A NAME=MARKER-2-764></A>When you call <CODE>TransliterateText</CODE>, you specify a<B> source mask,</B> a<B> target format,</B> and a <B>target modifier.</B> The source mask specifies which subscript or subscripts represented in the source text should be converted to the target format. The target modifier provides additional formatting instructions. For example, in Japanese text that contains Roman, Hiragana, Katakana, and Kanji characters, you could use the source mask to limit transliteration to Hiragana characters only. You could then use the target format to specify conversion to Roman, and you could use the target modifier to further specify that the converted text become uppercase.<P>
 <A NAME=MARKER-9-765></A>For all script systems, there are three currently defined values for source mask, with the following assigned constants:<A NAME=MARKER-2-766></A><B>
<TABLE BORDER="0" CELLPADDING=3><TH ALIGN=LEFT>Source mask constant<TH>Value<TH>Explanation<TR>
<TD><A NAME=MARKER-2-430></A>smMaskAscii<TD>1<TD>Convert from Roman text<TR>
<TD><A NAME=MARKER-2-36></A>smMaskNative<TD>2<TD>Convert from text native to current script<TR>
<TD><A NAME=MARKER-8-166></A>smMaskAll<TD>-1<TD>Convert from all text</TABLE>
</B><P>
 To specify that you want to convert only Roman characters, use <CODE>smMaskAscii</CODE>. To convert only native characters, use <CODE>smMaskNative</CODE>. Use the <CODE>smMaskAll</CODE> constant to specify that you want to transliterate all text. "Roman text" is defined as any Roman characters in the character set of a given script system. In most cases, this means the low-ASCII Roman characters, but--depending on the script system--it may also include certain characters in the high-ASCII range whose codes are not used for the script system's native character set,<EM> </EM>and it may include 2-byte Roman characters in 2-byte script systems. The definition of "native text" is also script-dependent.<P>
 <A NAME=MARKER-9-767></A>The 2-byte script systems recognize the following additional values for source mask:<A NAME=MARKER-2-768></A>
<TABLE BORDER="0" CELLPADDING=3><TH ALIGN=LEFT>Source mask constant<TH>Hex. value<TH>Explanation<TR>
<TD>All 2-byte scripts:<TD>&nbsp;<TD>&nbsp;<TR>
<TD><A NAME=MARKER-2-292></A>smMaskAscii1<TD>$04<TD>Convert from 1-byte Roman text<TR>
<TD><A NAME=MARKER-2-293></A>smMaskAscii2<TD>$08<TD>Convert from 2-byte Roman text<TR>
<TD>Japanese:<TD>&nbsp;<TD>&nbsp;<TR>
<TD><A NAME=MARKER-2-294></A>smMaskKana1<TD>$10<TD>Convert from 1-byte Katakana text<TR>
<TD><A NAME=MARKER-2-295></A>smMaskKana2<TD>$20<TD>Convert from 2-byte Katakana text<TR>
<TD><A NAME=MARKER-2-296></A>smMaskGana2<TD>$80<TD>Convert from 2-byte Hiragana text<TR>
<TD colspan=3>Korean:<TR>
<TD><A NAME=MARKER-2-297></A>smMaskHangul2<TD>$100<TD>Convert from 2-byte Hangul text<TR>
<TD><A NAME=MARKER-2-298></A>smMaskJamo2<TD>$200<TD>Convert from 2-byte Jamo text<TR>
<TD>Chinese:<TD>&nbsp;<TD>&nbsp;<TR>
<TD><A NAME=MARKER-2-299></A>smMaskBopomofo2<TD>$400<TD>Convert from 2-byte Zhuyinfuhao text<A NAME=MARKER-2-300></A></TABLE>
<P>
 <A NAME=MARKER-9-769></A>The low-order byte of the <CODE>target</CODE> parameter is the format; it determines what form the text should be transliterated to. For all script systems, there are two currently supported values for target format, with the following assigned constants: <A NAME=MARKER-2-770></A>   <B>
<TABLE BORDER="0" CELLPADDING=3><TH ALIGN=LEFT>Target format constant<TH>Hex. value<TH>Explanation<TR>
<TD><A NAME=MARKER-2-303></A>smTransAscii<TD>$00<TD>Convert to Roman<TR>
<TD><A NAME=MARKER-2-304></A>smTransNative<TD>$01<TD>Convert to a subscript native to current script<TR>
<TD><A NAME=MARKER-2-305></A>smTransCase<TD>$FE<TD>Convert case for all text (obsolete)<TR>
<TD><A NAME=MARKER-2-306></A>smTransSystem<TD>$FF<TD>Convert to system script (obsolete)</TABLE>
   </B><P>
 <A NAME=MARKER-9-771></A>The 2-byte script systems recognize the following additional values for target format:<B>
<TABLE BORDER="0" CELLPADDING=3><TH ALIGN=LEFT>Target format constant<TH>Value<TH>Explanation<TR>
<TD>All 2-byte scripts:<TD>&nbsp;<TD>&nbsp;<TR>
<TD><A NAME=MARKER-2-307></A>smTransASCII1<TD>2<TD>Convert to 1-byte Roman text<TR>
<TD><A NAME=MARKER-2-308></A>smTransASCII2<TD>3<TD>Convert to 2-byte Roman text<TR>
<TD>Japanese:<TD>&nbsp;<TD>&nbsp;<TR>
<TD><A NAME=MARKER-2-309></A>smTransKana1<TD>4<TD>Convert to 1-byte Katakana text<TR>
<TD><A NAME=MARKER-2-310></A>smTransKana2<TD>5<TD>Convert to 2-byte Katakana text<TR>
<TD><A NAME=MARKER-2-311></A>smTransGana2<TD>7<TD>Convert to 2-byte Hiragana text<TR>
<TD>Korean:<TD>&nbsp;<TD>&nbsp;<TR>
<TD><A NAME=MARKER-2-312></A>smTransHangul2<TD>8<TD>Convert to 2-byte Hangul text<TR>
<TD><A NAME=MARKER-2-313></A>smTransJamo2<TD>9<TD>Convert to 2-byte Jamo text<TR>
<TD>Chinese:<TD>&nbsp;<TD>&nbsp;<TR>
<TD><A NAME=MARKER-2-314></A>smTransBopomofo2<TD>10<TD>Convert to 2-byte Zhuyinfuhao text<A NAME=MARKER-2-315></A></TABLE>
</B><P>
 <A NAME=MARKER-9-772></A>The high-order byte of the <CODE>target</CODE> parameter is the target modifier; it provides additional formatting instructions. All script systems recognize these values for target modifier, with the following assigned constants:<A NAME=MARKER-2-773></A>   
<TABLE BORDER="0" CELLPADDING=3><TH ALIGN=LEFT>Target modifier constant<TH>Hex. value<TH>Explanation<TR>
<TD><A NAME=MARKER-2-301></A>smTransLower<TD>$4000<TD>Target becomes lowercase<TR>
<TD><A NAME=MARKER-2-302></A>smTransUpper<TD>$8000<TD>Target becomes uppercase</TABLE>
<P>
 For example, for <CODE>TransliterateText</CODE> to convert all the characters in a block of text to 1-byte Roman uppercase, the value of <CODE>srcMask</CODE> is <CODE>smMaskAll</CODE> and the target value is <CODE>smTransAscii1</CODE>+<CODE>smTransUpper</CODE>. To convert only those characters that are already (1-byte or 2-byte) Roman, the value of <CODE>srcMask</CODE> is <CODE>smMaskAscii1+smMaskAscii2</CODE>.<P>
 The <CODE>TransliterateText</CODE> function is described further on <A HREF=Text-402.html#MARKER-9-998>page 6-98</A>.<P>
<DL>
<DT><B>Note</B>
<DD><A NAME=MARKER-2-774></A>For uppercasing or lowercasing Roman text in general, use <CODE>UppercaseText</CODE> or <CODE>LowercaseText</CODE>. Because the performance of <CODE>TransliterateText</CODE> is slower, you may rarely want to use its case-changing capabilities in Roman text.<B><EM></EM></B><A NAME=MARKER-2-775></A><B></B>  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
</BLOCKQUOTE>
<HR>
<center>
<A HREF="Text-362.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="Text-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="Text-594.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="Text-364.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="Text-3.html">&copy; Apple Computer, Inc.</A><br>6 JUL 1996</center></font><P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML>  
