<!-- Generated by Harlequin WebMaker 2.2.3 (23-Apr-1996)
LispWorks 3.2.2 -->
<HTML> <HEAD>
<TITLE>Using Color QuickDraw (IM: Im)</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING199></A>



<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!--end of header -->

<center>
<A HREF="QuickDraw-198.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="QuickDraw-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="QuickDraw-476.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="QuickDraw-200.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="QuickDraw-2.html"><B>Imaging With QuickDraw</B></A> / <BR><DD><A HREF="QuickDraw-197.html"><B>Chapter 4 - Color QuickDraw</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING199-0></A>
<H1>Using Color QuickDraw</H1>
 To use Color QuickDraw, you generally<P>
<UL>
<LI>initialize QuickDraw
<LI>create a color window into which your application can draw
<LI>create <CODE>RGBColor</CODE> records to define your own foreground and background colors 
<LI>create pixel pattern (<CODE>'ppat'</CODE>) resources to define your own colored patterns 
<LI>use these colors and pixel patterns for drawing with the graphics pen, for filling as the background pattern, and for filling into shapes
<LI>use the basic QuickDraw routines previously described in this book to perform all other onscreen graphics port manipulations and calculations<P>
</UL>
 This section gives an overview of routines that your application typically calls while using Color QuickDraw. Before calling these routines, however, your application should test for the existence of Color QuickDraw by using the <CODE>Gestalt</CODE> function with the <CODE>gestaltQuickDrawVersion</CODE> selector. The <CODE>Gestalt</CODE> function returns a 4-byte value in its <CODE>response</CODE> parameter; the low-order word contains QuickDraw version data. In that low-order word, the high-order byte gives the major revision number and the low-order byte gives the minor revision number. If the value returned in the <CODE>response</CODE> parameter is equal to the value of the constant <CODE>gestalt32BitQD13</CODE>, then the system supports the System 7 version of Color QuickDraw. Listed here are the various constants, and the values they represent, that indicate earlier versions of Color QuickDraw. <A NAME=MARKER-2-84></A><P>
<PRE>
CONST
   gestalt8BitQD     = $100;  {8-bit Color QD}
   gestalt32BitQD    = $200;  {32-bit Color QD}
   gestalt32BitQD11  = $210;  {32-bit Color QDv1.1}
   gestalt32BitQD12  = $220;  {32-bit Color QDv1.2}
   gestalt32BitQD13  = $230;  {System 7: 32-bit Color QDv1.3}
</PRE>
 Your application can also use the <CODE>Gestalt</CODE> function with the selector <CODE>gestaltQuickDrawFeatures</CODE> to determine whether the user's system supports various Color QuickDraw features. If the bits indicated by the following constants are set in the <CODE>response</CODE> parameter, then the features are available:<A NAME=MARKER-2-85></A><P>
<PRE>
CONST
   gestaltHasColor         = 0;  {Color QuickDraw is present}
   gestaltHasDeepGWorlds   = 1;  {GWorlds deeper than 1 bit}
   gestaltHasDirectPixMaps = 2;  {PixMaps can be direct--16 or }
                                 { 32 bit}
   gestaltHasGrayishTextOr = 3;  {supports text mode }
                                 { grayishTextOr}
</PRE>
 When testing for the existence of Color QuickDraw, your application should test the response to the <CODE>gestaltQuickDrawVersion</CODE> selector (rather than test for the result <CODE>gestaltHasColor</CODE>, which is unreliable, from the <CODE>gestaltQuickDrawFeatures</CODE> selector). The support for offscreen graphics worlds indicated by the <CODE>gestaltHasDeepGWorlds</CODE> response to the <CODE>gestaltQuickDrawVersion</CODE> selector is described in the chapter "Offscreen Graphics Worlds." The support for the text mode indicated by the <CODE>gestaltHasGrayishTextOr</CODE> response is described in the chapter "QuickDraw Text" in <I><A HREF="../Text/Text-2.html">Inside Macintosh: Text</A></I>. For more information about the <CODE>Gestalt</CODE> function, see the chapter "Gestalt Manager" in <I><A HREF="../OSUtilities/OSUtilities-2.html">Inside Macintosh: Operating System Utilities</A></I>.<P>
<A NAME=HEADING199-13></A>
<H2>Initializing Color QuickDraw</H2>
 <A NAME=MARKER-2-86></A>To initialize Color QuickDraw, use the <CODE>InitGraf</CODE> procedure, described in the chapter "Basic QuickDraw." Besides initializing basic QuickDraw, this procedure initializes Color QuickDraw on computers that support it.<P>
 In addition to <CODE>InitGraf</CODE>, all other basic QuickDraw routines work with Color QuickDraw. For example, you can use the <CODE>GetPort</CODE> procedure to save the current color graphics port, and you can use the <CODE>CopyBits</CODE> procedure to copy an image between two different color graphics ports. See the chapters "Basic QuickDraw" and "QuickDraw Drawing" for descriptions of additional routines that you can use with Color QuickDraw.<A NAME=MARKER-2-279></A><P>
<A NAME=HEADING199-16></A>
<H2>Creating Color Graphics Ports</H2>
 <A NAME=MARKER-2-88></A><A NAME=MARKER-2-89></A>All graphics operations are performed in graphics ports. Before a color graphics port can be used, it must be allocated with the <CODE>OpenCPort</CODE> procedure and initialized with the <CODE>InitCPort</CODE> procedure. Normally, your application does not call these procedures directly. Instead, your application creates a color graphics port by using the <CODE>GetNewCWindow</CODE> or <CODE>NewCWindow</CODE> function (described in the chapter "Window Manager" in <I><A HREF="../Toolbox/Toolbox-2.html">Inside Macintosh: Macintosh Toolbox Essentials</A></I>) or the <CODE>NewGWorld</CODE> function (described in the chapter "Offscreen Graphics Worlds" in this book). These functions automatically call <CODE>OpenCPort</CODE>, which in turn calls <CODE>InitCPort</CODE>.<P>
 <A HREF=#MARKER-9-90>Listing 4-1</A> shows a simplified application-defined procedure called <CODE>DoNew</CODE> that uses the Window Manager function <CODE>GetNewCWindow</CODE> to create a color graphics port. <P>
<B>Listing 4-1  <A NAME=MARKER-9-90></A>Using the Window Manager to create a color graphics port</B><P>
<PRE>
PROCEDURE DoNew (VAR window: WindowPtr);
VAR
   windStorage:   Ptr;  {memory for window record}
BEGIN
   window := NIL;
   {allocate memory for window record from previously allocated block}
   windStorage := MyPtrAllocationProc;
   IF windStorage &lt;&gt; NIL THEN {memory allocation succeeded}
   BEGIN
      IF gColorQDAvailable THEN {use Gestalt to determine color availability}
         window := GetNewCWindow(rDocWindow, windStorage, WindowPtr(-1))
      ELSE        {create a basic graphics port for a black-and-white screen}
         window := GetNewWindow(rDocWindow, windStorage, WindowPtr(-1));
   END;
   IF (window &lt;&gt; NIL) THEN
       SetPort(window);
END;
</PRE>
 You can use <CODE>GetNewCWindow</CODE> to create color graphics ports whether or not a color monitor is currently installed. So that most of your window-handling code can handle color windows and black-and-white windows identically, <CODE>GetNewCWindow</CODE> returns a pointer of type <CODE>WindowPtr</CODE> (not of type <CODE>CWindowPtr</CODE>). <P>
 A window pointer points to a window record (<CODE>WindowRecord</CODE>), which contains a <CODE>GrafPort</CODE> record. If you need to check the fields of the color graphics port associated with a window, you can coerce the pointer to the <CODE>GrafPort</CODE> record into a pointer to a <CODE>CGrafPort</CODE> record.<P>
 You can allow <CODE>GetNewCWindow</CODE> to allocate the memory for your window record and its associated basic graphics port. You can maintain more control over memory use, however, by allocating the memory yourself from a block allocated for such purposes during your own initialization routine, and then passing the pointer to <CODE>GetNewWindow</CODE>, as shown in <A HREF=#MARKER-9-90>Listing 4-1</A>.<P>
 To dispose of a color graphics port when you are finished using a color window, you normally use the <CODE>DisposeWindow</CODE> procedure (if you let the Window Manager allocate memory for the window) or the <CODE>CloseWindow</CODE> procedure (if you allocated memory for the window). If you use the <CODE>CloseWindow</CODE> procedure, you also dispose of the window record containing the graphics port by calling the Memory Manager procedure <CODE>DisposePtr</CODE>. You use the <CODE>DisposeGWorld</CODE> procedure when you are finished with a color graphics port for an offscreen graphics world.<A NAME=MARKER-2-280></A><A NAME=MARKER-2-411></A><P>
<A NAME=HEADING199-25></A>
<H2>Drawing With Different Foreground Colors</H2>
 <A NAME=MARKER-2-93></A><A NAME=MARKER-2-459></A><A NAME=MARKER-2-95></A>You can set the foreground and background colors using either Color QuickDraw or Palette Manager routines. If your application uses the Palette Manager, it should set the foreground and background colors with the <CODE>PmForeColor</CODE> and <CODE>PmBackColor</CODE> routines, as described in the chapter "Palette Manager" in <I>Inside Macintosh: Advanced Color Imaging.</I> Otherwise, your application can use the <CODE>RGBForeColor</CODE> procedure to set the foreground color, and it can use the <CODE>RGBBackColor</CODE> procedure to set the background color. Both of these Color QuickDraw procedures also operate for basic graphics ports created in System 7. (To set the foreground and background colors for basic graphics ports on older versions of system software, use the <CODE>ForeColor</CODE> and <CODE>BackColor</CODE> procedures described in the chapter "QuickDraw Drawing.")<P>
 The <CODE>RGBForeColor</CODE> procedure lets you set the foreground color to the best color available on the current graphics device. This changes the color of the "ink" used for drawing. All of the line-drawing, framing, and painting routines described in the chapter "QuickDraw Drawing" (such as <CODE>LineTo</CODE>, <CODE>FrameRect</CODE>, and <CODE>PaintPoly</CODE>) draw with the foreground color that you specify with <CODE>RGBForeColor</CODE>.<P>
<DL>
<DT><B>Note</B>
<DD>Because a pixel pattern already contains color, Color QuickDraw ignores the foreground and background colors when your application draws with a pixel pattern. As described in <A HREF=#MARKER-9-99>"Drawing With Pixel Patterns" beginning on page 4-19</A>, you can draw with a pixel pattern by using the <CODE>PenPixPat</CODE> procedure to assign a pixel pattern to the graphics pen, by using the <CODE>BackPixPat</CODE> procedure to assign a pixel pattern as the background pattern for the current color graphics port, and by using the <CODE>FillCRect</CODE>, <CODE>FillCOval</CODE>, <CODE>FillCRoundRect</CODE>, <CODE>FillCArc</CODE>, <CODE>FillCRgn</CODE>, and <CODE>FillCPoly</CODE> procedures to fill shapes with a pixel pattern.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
 To specify a foreground color, create an <CODE>RGBColor</CODE> record. <A HREF=#MARKER-9-96>Listing 4-2</A> defines two <CODE>RGBColor</CODE> records. The first is declared as <CODE>myDarkBlue</CODE>, and it's defined with a medium-intensive blue component and with zero-intensity red and green components. The second is declared as <CODE>myMediumGreen</CODE>, and it's defined with an intensive green component, a mildly intensive red component, and a very slight blue component.<P>
<B>Listing 4-2  <A NAME=MARKER-9-96></A>Changing the foreground color</B><P>
<PRE>
PROCEDURE MyPaintAndFillColorRects;
VAR
   firstRect, secondRect:  Rect;
   myDarkBlue:             RGBColor;
   myMediumGreen:          RGBColor;
BEGIN
      {create dark blue color}
   myDarkBlue.red := $0000;
   myDarkBlue.green := $0000;
   myDarkBlue.blue := $9999;
      {create medium green color}
   myMediumGreen.red := $3206;
   myMediumGreen.green := $9038;
   myMediumGreen.blue := $013D;
   RGBForeColor(myDarkBlue);  {draw with dark blue pen}
   PenMode(patCopy);
   SetRect(firstRect, 20, 20, 70, 70);
   PaintRect(firstRect);         {paint a dark blue rectangle}
   RGBForeColor(myMediumGreen);  {draw with a medium green pen}
   SetRect(secondRect, 90, 20, 140, 70);
   FillRect(secondRect, ltGray); {paint a medium green rectangle}
END;
</PRE>
 In <A HREF=#MARKER-9-96>Listing 4-2</A>, the <CODE>RGBColor</CODE> record <CODE>myDarkBlue</CODE> is supplied to the <CODE>RGBForeColor</CODE> procedure. The <CODE>RGBForeColor</CODE> procedure supplies the <CODE>rgbFgColor</CODE> field of the <CODE>CGrafPort</CODE> record with this <CODE>RGBColor</CODE> record, and it places the closest-matching available color in the <CODE>fgColor</CODE> field; the color in the <CODE>fgColor</CODE> field is the color actually used as the foreground color.<P>
 After using <CODE>SetRect</CODE> to create a rectangle, <A HREF=#MARKER-9-96>Listing 4-2</A> calls <CODE>PaintRect</CODE> to paint the rectangle. By default, the foreground color is black; by changing the foreground color to dark blue, every pixel that would normally be painted in black is instead painted in dark blue.<P>
 <A HREF=#MARKER-9-96>Listing 4-2</A> then changes the foreground color again to the medium green specified in the <CODE>RGBColor</CODE> record <CODE>myMediumGreen</CODE>. After creating another rectangle, this listing calls <CODE>FillRect</CODE> to fill the rectangle with the bit pattern specified by the global variable <CODE>ltGray</CODE>. As explained in the chapter "QuickDraw Drawing," this bit pattern consists of widely spaced black pixels that create the effect of gray on black-and-white screens. However, by changing the foreground color, every pixel in the pattern that would normally be painted black is instead drawn in medium green.<P>
 The effects of <A HREF=#MARKER-9-96>Listing 4-2</A> are illustrated in the grayscale screen capture shown in <BR><A HREF=#MARKER-9-97>Figure 4-9</A>.<P>
<B>Figure 4-9  <A NAME=MARKER-9-97></A>Drawing with two different foreground colors (on a grayscale screen)</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/CQD-S-01.jpg"><BR>
 If you wish to draw with a color other than the foreground color, you can use the <CODE>PenPixPat</CODE> procedure to give the graphics pen a colored pixel pattern that you define, and you can use the <CODE>FillCRect</CODE>, <CODE>FillCRoundRect</CODE>, <CODE>FillCOval</CODE>, <CODE>FillCArc</CODE>, <CODE>FillCPoly</CODE>, and <CODE>FillCRgn</CODE> procedures to fill shapes with colored patterns. The use of these procedures is illustrated in the next section.<A NAME=MARKER-2-290></A><P>
<A NAME=HEADING199-39></A>
<H2><A NAME=MARKER-9-99></A>Drawing With Pixel Patterns</H2>
 <A NAME=MARKER-2-294></A>Using pixel pattern resources, you can create multicolored patterns for the pen pattern, for the background pattern, and for fill patterns.<P>
 To set the pixel pattern to be used by the graphics pen in the current color graphics port, you use the <CODE>PenPixPat</CODE> procedure. To assign a pixel pattern as the background pattern, you use the <CODE>BackPixPat</CODE> procedure; this causes the <CODE>ScrollRect</CODE> procedure and the shape-erasing procedures (for example, <CODE>EraseRect</CODE>) to fill the background with your pixel pattern. To fill shapes with a pixel pattern, you use the <CODE>FillCRect</CODE>, <CODE>FillCRoundRect</CODE>, <CODE>FillCOval</CODE>, <CODE>FillCArc</CODE>, <CODE>FillCPoly</CODE>, and <CODE>FillCRgn</CODE> procedures.<P>
<DL>
<DT><B>Note</B>
<DD>Because a pixel pattern already contains color, Color QuickDraw ignores the foreground and background colors when your application uses these routines to draw with a pixel pattern. Color QuickDraw also ignores the pen mode by drawing the pixel pattern directly onto the pixel image.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
 When you use the <CODE>PenPat</CODE> or <CODE>BackPat</CODE> procedure in a color graphics port, Color QuickDraw constructs a pixel pattern equivalent to the bit pattern you specify to <CODE>PenPat</CODE> or <CODE>BackPat</CODE>. The pen pattern or background pattern you thereby specify always uses the graphics port's current foreground and background colors. The <CODE>PenPat</CODE> and <CODE>BackPat</CODE> procedures are described in the chapter "QuickDraw Drawing."<A NAME=MARKER-2-529></A><P>
 <A NAME=MARKER-2-184></A><A NAME=MARKER-2-103></A><A NAME=MARKER-2-78></A>A pixel pattern resource is a resource of type <CODE>'ppat'</CODE>. You typically use a high-level tool such as the ResEdit application, available through APDA, to create <CODE>'ppat'</CODE> resources. <A HREF=#MARKER-9-105>Figure 4-10</A> illustrates a ResEdit window displaying an application's <CODE>'ppat'</CODE> resource with resource ID 128.<P>
<B>Figure 4-10  <A NAME=MARKER-9-105></A>Using ResEdit to create a pixel pattern resource</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/CQD-S-02.jpg"><BR>
 As shown in this figure, you should also define an analogous, black-and-white bit pattern (described in the chapter "QuickDraw Drawing") to be used when this pattern is drawn into a basic graphics port. This bit pattern is stored within the pixel pattern resource.<A NAME=MARKER-2-297></A><P>
 After using ResEdit to define a pixel pattern, you can then use the DeRez decompiler to convert your <CODE>'ppat'</CODE> resources into Rez input when necessary. (The DeRez resource decompiler and the Rez resource compiler are part of Macintosh Programmer's Workshop [MPW], which is available through APDA.) <A HREF=#MARKER-9-107>Listing 4-3</A> shows the Rez input created from the <CODE>'ppat'</CODE> resource created in <A HREF=#MARKER-9-105>Figure 4-10</A>.<P>
<B>Listing 4-3  <A NAME=MARKER-9-107></A>Rez input for a pixel pattern resource</B><P>
<PRE>
resource 'ppat' (128) {
   $&quot;0001 0000 001C 0000 004E 0000 0000 FFFF&quot;
   $&quot;0000 0000 8292 1082 9210 8292 0000 0000&quot;
   $&quot;8002 0000 0000 0008 0008 0000 0000 0000&quot;
   $&quot;0000 0048 0000 0048 0000 0000 0002 0001&quot;
   $&quot;0002 0000 0000 0000 005E 0000 0000 1212&quot;
   $&quot;4848 1212 4848 1212 4848 1212 4848 0000&quot;
   $&quot;0000 0000 0002 0000 AAAA AAAA AAAA 0001&quot;
   $&quot;2222 2222 2222 0002 7777 7777 7777&quot;
};
</PRE>
 To retrieve the pixel pattern stored in a <CODE>'ppat'</CODE> resource, you can use the <CODE>GetPixPat</CODE> function. <A HREF=#MARKER-9-111>Listing 4-4</A> uses <CODE>GetPixPat</CODE> to retrieve the <CODE>'ppat'</CODE> resource created in <BR><A HREF=#MARKER-9-107>Listing 4-3</A>. To assign this pixel pattern to the graphics pen, <A HREF=#MARKER-9-111>Listing 4-4</A> uses the <CODE>PenPixPat</CODE> procedure.<A NAME=MARKER-2-108></A> <A NAME=MARKER-2-482></A><A NAME=MARKER-2-605></A><P>
<B>Listing 4-4  <A NAME=MARKER-9-111></A>Using pixel patterns to paint and fill</B><P>
<PRE>
PROCEDURE MyPaintPixelPatternRects;
VAR
   firstRect, secondRect:        Rect;
   myPenPattern, myFillPattern:  PixPatHandle;
BEGIN
   myPenPattern := GetPixPat(128);  {get a pixel pattern}
   PenPixPat(myPenPattern);      {assign the pattern to the pen}
   SetRect(firstRect, 20, 20, 70, 70);
   PaintRect(firstRect);      {paint with the pen's pixel pattern}
   DisposePixPat(myPenPattern);  {dispose of the pixel pattern}
   myFillPattern := GetPixPat(129);    {get another pixel pattern}
   SetRect(secondRect, 90, 20, 140, 70);
   FillCRect(secondRect, myFillPattern);  {fill with this pattern}
   DisposePixPat(myFillPattern); {dispose of the pixel pattern}
END;
</PRE>
 <A HREF=#MARKER-9-111>Listing 4-4</A> uses the <CODE>PaintRect</CODE> procedure to draw a rectangle. The rectangle on the left side of <A HREF=#MARKER-9-112>Figure 4-11</A> illustrates the effect of painting a rectangle with the previously defined pen pattern.<P>
<B>Figure 4-11  <A NAME=MARKER-9-112></A>Painting and filling rectangles with pixel patterns</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/CQD-S-03.jpg"><BR>
 The rectangle on the right side of <A HREF=#MARKER-9-112>Figure 4-11</A> illustrates the effect of using the <CODE>FillCRect</CODE> procedure to fill a rectangle with another previously defined pen pattern. The <CODE>GetPixPat</CODE> function is used to retrieve the pixel pattern defined in the <CODE>'ppat'</CODE> resource with resource ID 129. This pixel pattern is then specified to the <CODE>FillCRect</CODE> procedure.<A NAME=MARKER-2-447></A><A NAME=MARKER-2-114></A><P>
<A NAME=HEADING199-58></A>
<H2><A NAME=MARKER-9-115></A>Copying Pixels Between Color Graphics Ports</H2>
 <A NAME=MARKER-2-116></A>As explained in the chapter "QuickDraw Drawing," QuickDraw has three primary image-processing routines.<P>
<UL>
<LI>The <CODE>CopyBits</CODE> procedure copies a pixel map or bitmap image to another graphics port, with facilities for resizing the image, modifying the image with transfer modes, and clipping the image to a region.
<LI>The <CODE>CopyMask</CODE> procedure copies a pixel map or bitmap image to another graphics port, with facilities for resizing the image and for altering the image by passing it through a mask--which for Color QuickDraw may be another pixel map whose pixels indicate proportionate weights of the colors for the source and destination pixels.
<LI>The <CODE>CopyDeepMask</CODE> procedure combines the effects of <CODE>CopyBits</CODE> and <CODE>CopyMask</CODE>: you can resize an image, clip it to a region, specify a transfer mode, and use another pixel map as a mask when transferring it to another graphics port.<P>
</UL>
 In basic QuickDraw, <CODE>CopyBits</CODE>, <CODE>CopyMask</CODE>, and <CODE>CopyDeepMask</CODE> copy bit images between two basic graphics ports. In Color QuickDraw, you can also use these procedures to copy pixel images between two color graphics ports. Detailed routine descriptions for these procedures appear in the chapter "QuickDraw Drawing." This section provides an overview of how to use the extra capabilities that Color QuickDraw provides for these procedures.<P>
 When using <CODE>CopyBits</CODE>, <CODE>CopyMask</CODE>, and <CODE>CopyDeepMask</CODE> to copy images between color graphics ports, you must coerce each port's <CODE>CGrafPtr</CODE> data type to a <CODE>GrafPtr</CODE> data type, dereference the <CODE>portBits</CODE> fields of each, and then pass these "bitmaps" in the <CODE>srcBits</CODE> and <CODE>dstBits</CODE> parameters. If your application copies a pixel image from a color graphics port called <CODE>MyColorPort</CODE>, in the <CODE>srcBits</CODE> parameter you could specify <CODE>GrafPtr(MyColorPort)^.portBits</CODE>. In a <CODE>CGrafPort</CODE> record, the high 2 bits of the <CODE>portVersion</CODE> field are set. This field, which shares the same position in a <CODE>CGrafPort</CODE> record as the <CODE>portBits.rowBytes</CODE> field in a <CODE>GrafPort</CODE> record, indicates to these routines that you have passed it a handle to a pixel map rather than a bitmap.<P>
 <A NAME=MARKER-2-117></A>Color QuickDraw's processing sequence of the <CODE>CopyBits</CODE> procedure is illustrated in <A HREF=#MARKER-9-118>Figure 4-12</A>. <A HREF=QuickDraw-304.html#MARKER-9-27>Listing 6-1</A> in the chapter "Offscreen Graphics Worlds" illustrates how to use <CODE>CopyBits</CODE> to transfer an image prepared in an offscreen graphics world to an onscreen color graphics port.<P>
<B>Figure 4-12  <A NAME=MARKER-9-118></A><A NAME=MARKER-21-119></A>Copying pixel images with the <CODE>CopyBits</CODE> procedure</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/CQD-L-13.jpg"><BR>
 <A NAME=MARKER-2-320></A>With the <CODE>CopyMask</CODE> procedure, you can supply a pixel map to act as a copying mask. The values of pixels in the mask act as weights that proportionally select between source and destination pixel values. The process is shown in <A HREF=#MARKER-9-121>Figure 4-13</A>, and an example of the effect can be seen in  <A HREF="ColorPlate3.html">Plate 3</A> <A HREF="ColorPlate3.html">Plate 3</A> at the front of this book. <A HREF=QuickDraw-304.html#MARKER-9-59>Listing 6-2</A> in the chapter "Offscreen Graphics Worlds" illustrates how to use <CODE>CopyMask</CODE> to mask and copy an image prepared in an offscreen graphics world to an onscreen color graphics port.<P>
<B>Figure 4-13  <A NAME=MARKER-9-121></A><A NAME=MARKER-21-122></A>Copying pixel images with the <CODE>CopyMask</CODE> procedure</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/CQD-L-14.jpg"><BR>
 <A NAME=MARKER-2-123></A>The <CODE>CopyDeepMask</CODE> procedure combines the capabilities of the <CODE>CopyBits</CODE> and <CODE>CopyMask</CODE> procedures. With <CODE>CopyDeepMask</CODE> you can specify a pixel map mask, a transfer mode, and a mask region, as shown in <A HREF=#MARKER-9-124>Figure 4-14</A>.<P>
<B>Figure 4-14  <A NAME=MARKER-9-124></A><A NAME=MARKER-21-125></A>Copying pixel images with the <CODE>CopyDeepMask</CODE> procedure</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/CQD-L-15.jpg"><BR>
 <A NAME=MARKER-2-331></A>On indexed devices, pixel images are always copied using the color table of the source <CODE>PixMap</CODE> record for source color information, and using the color table of the <I>current <CODE>GDevice record</CODE></I> for destination color information. The color table attached to the destination <CODE>PixMap</CODE> record is ignored. As explained in the chapter "Offscreen Graphics Worlds," if you need to copy to an offscreen <CODE>PixMap</CODE> record with characteristics differing from those of the current graphics device, you should create an appropriate offscreen <CODE>GDevice</CODE> record and set it as the current graphics device before the copy operation.<P>
 When the <CODE>PixMap</CODE> record for the mask is 1 bit deep, it has the same effect as a bitmap mask: a black bit in the mask means that the destination pixel is to take the color of the source pixel; a white bit in the mask means that the destination pixel is to retain its current color. When masks have <CODE>PixMap</CODE> records with greater pixel depths than 1, Color QuickDraw takes a weighted average between the colors of the source and destination <CODE>PixMap</CODE> records. Within each pixel, the calculation is done in RGB color, on a color component basis. A gray <CODE>PixMap</CODE> record mask, for example, works like blend mode in a <CODE>CopyBits</CODE> procedure. A red mask (that is, one with high values for the red components of all pixels) filters out red values coming from the source pixel image. <A NAME=MARKER-2-319></A><P>
<A NAME=HEADING199-76></A>
<H3><A NAME=MARKER-9-128></A>Boolean Transfer Modes With Color Pixels</H3>
 <A NAME=MARKER-2-129></A>As described in the chapter "QuickDraw Drawing," QuickDraw offers two types of Boolean transfer modes: pattern modes for drawing lines and shapes, and source modes for copying images or drawing text. In basic graphics ports and in color graphics ports with 1-bit pixel maps, these modes describe the interaction between the bits your application draws and the bits that are already in the destination bitmap or 1-bit pixel map. These interactions involve turning the bits on or off--that is, making the pixels black or white. <P>
 The Boolean operations on bitmaps and 1-bit pixel maps are described in the chapter "QuickDraw Drawing." When you draw or copy images to and from bitmaps or 1-bit pixel maps, Color QuickDraw behaves in the manner described in that chapter.<P>
 <A NAME=MARKER-2-130></A>When you use pattern modes in pixel maps with depths greater than 1 bit, Color QuickDraw uses the foreground color and background color when transferring bit patterns; for example, the <CODE>patCopy</CODE> mode applies the foreground color to every destination pixel that corresponds to a black pixel in a bit pattern, and it applies the background color to every destination pixel that corresponds to a white pixel in a bit pattern. See the description of the <CODE>PenMode</CODE> procedure in the chapter "QuickDraw Drawing" for a list that summarizes how the foreground and background colors are applied with pattern modes.<P>
 When you use the <CODE>CopyBits</CODE>, <CODE>CopyMask</CODE>, and <CODE>CopyDeepMask</CODE> procedures to transfer images between pixel maps with depths greater than 1 bit, Color QuickDraw performs the Boolean transfer operations in the manner summarized in <A HREF=#MARKER-9-7>Table 4-1</A>. In general, with pixel images you will probably want to use the <CODE>srcCopy</CODE> mode or one of the arithmetic transfer modes described in <A HREF=#MARKER-9-141>"Arithmetic Transfer Modes" beginning on page 4-29</A>.
<TABLE BORDER="0" CELLPADDING=3>
<CAPTION><A NAME=MARKER-9-7></A><B>Table 4-1 Boolean source modes with colored pixels</B> (Continued)</CAPTION>
<TH>Source mode<TH colspan=3>Action on destination pixel<TR>
<TD>&nbsp;<TD>If source pixel is black<TD>If source pixel is white<TD>If source pixel is any other color<TR>
<TD>srcCopy<TD>Apply foreground color<TD>Apply background color<A NAME=MARKER-2-5></A><TD>Apply weighted portions of foreground and background colors<TR>
<TD>notSrcCopy<TD>Apply background color<TD>Apply foreground color<TD>Apply weighted portions of background and foreground colors<TR>
<TD>srcOr<TD>Apply foreground color<TD>Leave alone<A NAME=MARKER-2-10></A><TD>Apply weighted portions of foreground color<TR>
<TD>notSrcOr<TD>Leave alone<TD>Apply foreground color<A NAME=MARKER-9-31></A><TD>Apply weighted portions of foreground color<TR>
<TD>srcXor<TD>Invert (undefined for colored destination pixel)<TD>Leave alone<A NAME=MARKER-2-32></A><TD>Leave alone<TR>
<TD>notSrcXor<TD>Leave alone<TD>Invert (undefined for colored destination pixel)<A NAME=MARKER-2-124></A><TD>Leave alone<TR>
<TD>srcBic<TD>Apply background color<TD>Leave alone<A NAME=MARKER-9-103></A><TD>Apply weighted portions of background color<TR>
<TD>notSrcBic<TD>Leave alone<TD>Apply background color<TD>Apply weighted portions of background color</TABLE>
<P>
<DL>
<DT><B>Note</B>
<DD>When your application draws with a pixel pattern, Color QuickDraw ignores the pattern mode and simply transfers the pattern directly to the pixel map without regard to the foreground and background colors.<EM></EM><A NAME=MARKER-2-131></A>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
 When you use the <CODE>srcCopy</CODE> mode to transfer a pixel into a pixel map, Color QuickDraw determines how close the color of that pixel is to black, and then assigns this relative amount of foreground color to the destination pixel. Color QuickDraw also determines how close the color of that pixel is to white, and assigns this relative amount of background color to the destination pixel.<P>
 To accomplish this, Color QuickDraw first multiplies the relative intensity of each red, green, and blue component of the source pixel by the corresponding value of the red, green, or blue component of the foreground color. It then multiplies the relative intensity of each red, green, and blue component of the source pixel by the corresponding value of the red, green, or blue component of the background color. For each component, Color QuickDraw adds the results and then assigns the new result as the value for the destination pixel's corresponding component. <P>
 For example, the pixel in an image might be all red: that is, its red component has a pixel value of $FFFF, and its green and blue components each have pixel values of $0000. The current foreground color might be black (that is, with pixel values of $0000, $0000, $0000 for its components) and its background color might be all white (that is, with pixel values of $FFFF, $FFFF, $FFFF). When that image is copied using the <CODE>CopyBits</CODE> procedure and the <CODE>srcCopy</CODE> source mode, <CODE>CopyBits</CODE> determines that the red component of the source pixel has 100 percent intensity; multiplying this by the intensity of the red component ($0000) of the foreground color produces a value of $0000, and multiplying this by the intensity of the red component ($FFFF) of the background color produces a value of $FFFF. Adding the results of these two operations produces a pixel value of $FFFF for the red component of the destination pixel. Performing similar operations on the green and blue components of the source pixel produces green and blue pixel values of $0000 for the destination pixel. In this way, <CODE>CopyBits</CODE> renders the source's all-red pixel as an all-red pixel in the destination pixel map. A source pixel with only 50 percent intensity for its red component and no intensity for its blue and green components would similarly be drawn as a medium red pixel in the destination pixel map.<P>
 Color QuickDraw produces similarly weighted destination colors when you use the other Boolean source modes. When you use the <CODE>srcBic</CODE> mode to transfer a colored source pixel into a pixel map, for example, <CODE>CopyBits</CODE> determines how close the color of that pixel is to black, and then assigns a relative amount of background color to the destination pixel. For this mode, <CODE>CopyBits</CODE> does not determine how close the color of the source pixel is to white.<P>
 Because Color QuickDraw uses the foreground and background colors instead of black and white when performing its Boolean source operations, the following effects are produced:<P>
<UL>
<LI>The <CODE>notSrcCopy</CODE> mode reverses the foreground and background colors. <A NAME=MARKER-2-148></A>
<LI>Drawing into a white background with a black foreground always reproduces the source image, regardless of the pixel depth.<A NAME=MARKER-2-118></A>
<LI>Drawing is faster if the foreground color is black when you use the <CODE>srcOr</CODE> and <CODE>notSrcOr</CODE> modes. <A NAME=MARKER-2-149></A>
<LI>If the background color is white when you use the <CODE>srcBic</CODE> mode, the black portions of the source are erased, resulting in white in the destination pixel map.<A NAME=MARKER-2-221></A><P>
</UL>
 As you can see, applying a foreground color other than black or a background color other than white to the pixel can produce an unexpected result. For consistent results, set the foreground color to black and the background color to white before using <CODE>CopyBits</CODE>, <CODE>CopyMask</CODE>, or <CODE>CopyDeepMask</CODE>.<P>
 However, by using the <CODE>RGBForeColor</CODE> and <CODE>RGBBackColor</CODE> procedures to set the foreground and background colors to something other than black and white before using <CODE>CopyBits</CODE>, <CODE>CopyMask</CODE>, or <CODE>CopyDeepMask</CODE>, you can achieve some interesting coloration effects.  <A HREF="ColorPlate2.html">Plate 2</A> at the front of this book shows how setting the foreground color to red and the background color to blue and then using the <CODE>CopyBits</CODE> procedure turns a grayscale image into shades of red and blue. <A HREF=#MARKER-9-136>Listing 4-5</A> shows the code that produced these two pixel maps.<P>
<A NAME=MARKER-9-136></A><B>Listing 4-5  Using <CODE>CopyBits</CODE> to produce coloration effects</B><P>
<PRE>
PROCEDURE MyColorRamp;
VAR
   origPort:            CGrafPtr;
   origDevice:          GDHandle;
   myErr:               QDErr;
   myOffScreenWorld:    GWorldPtr;
   TheColor:            RGBColor;
   i:                   Integer;
   offPixMapHandle:     PixMapHandle;
   good:                Boolean;
   myRect:              Rect;
BEGIN
   GetGWorld(origPort, origDevice);    {save onscreen graphics port}
                                 {create offscreen graphics world}
   myErr := NewGWorld(myOffScreenWorld, 
                      0, origPort^.portRect, NIL, NIL, []);
   IF (myOffScreenWorld = NIL) OR (myErr &lt;&gt; noErr) THEN
      ; {handle errors here}
   SetGWorld(myOffScreenWorld, NIL); {set current graphics port to offscreen}
   offPixMapHandle := GetGWorldPixMap(myOffScreenWorld);
   good := LockPixels(offPixMapHandle);   {lock offscreen pixel map}
   IF NOT good THEN
      ; {handle errors here}
   EraseRect(myOffScreenWorld^.portRect); {initialize offscreen pixel map}
   FOR i := 0 TO 9 DO
   BEGIN                                  {create gray ramp}
      theColor.red := i * 7168;
      theColor.green := i * 7168;
      theColor.blue := i * 7168;
      RGBForeColor(theColor);
      SetRect(myRect, myOffScreenWorld^.portRect.left, i * 10,
              myOffScreenWorld^.portRect.right, i * 10 + 10);
      PaintRect(myRect);      {fill offscreen pixel map with gray ramp}
   END;
   SetGWorld(origPort, origDevice);    {restore onscreen graphics port}
   theColor.red := $0000;
   theColor.green := $0000;
   theColor.blue := $FFFF;
   RGBForeColor(theColor);    {make foreground color all blue}
   theColor.red := $FFFF;
   theColor.green := $0000;
   theColor.blue := $0000;
   RGBBackColor(theColor);    {make background color all red}
      {using blue foreground and red background colors, transfer &quot;gray&quot; }
      { ramp to onscreen graphics port}
   CopyBits(GrafPtr(myOffScreenWorld)^.portBits,   {gray ramp is source}
            GrafPtr(origPort)^.portBits,           {window is destination}
            myOffScreenWorld^.portRect, origPort^.portRect, srcCopy, NIL);
   UnlockPixels(offPixMapHandle);
   DisposeGWorld(myOffScreenWorld);
END;
</PRE>
 <A HREF=#MARKER-9-136>Listing 4-5</A> uses the <CODE>NewGWorld</CODE> function, described in the chapter "Offscreen Graphics Worlds," to create an offscreen pixel map. The sample code draws a gray ramp into the offscreen pixel map, which is illustrated on the left side of  <A HREF="ColorPlate2.html">Plate 2</A> at the front of this book. Then <A HREF=#MARKER-9-136>Listing 4-5</A> creates an all-blue foreground color and an all-red background color. This sample code then uses the <CODE>CopyBits</CODE> procedure to transfer the pixels in the offscreen pixel map to the onscreen window, which is shown on the right side of  <A HREF="ColorPlate2.html">Plate 2</A>.<P>
 Here are some hints for using foreground and background colors and the <CODE>srcCopy</CODE> source mode to color a pixel image:<P>
<UL>
<LI>You can copy a particular color component of a source pixel without change by setting the foreground color to have a value of $0000 for that component and the background color to have a value of $FFFF for that component. For example, if you want all the pixels in a source image to retain their red values in the destination image, set the red component of the foreground color to $0000, and set the red component of the background color to $FFFF.
<LI>You can invert a particular color component of a source pixel by setting the foreground color to have a value of $FFFF for that component and the background color to have a value of $0000 for that component.
<LI>You can remove a particular color component from all the pixels in the source image by setting the foreground color to have a value of $0000 for that component and the background color to have a value of $0000 for that component.
<LI>You can force a particular color component in all the pixels in the source to be transferred with full intensity by setting the foreground color to have a value of $FFFF for that component and the background color to have a value of $FFFF for that component.<P>
</UL>
 To help make color work well on different screen depths, Color QuickDraw does some validity checking of the foreground and background colors. If your application is drawing to a color graphics port with a pixel depth equal to 1 or 2, and if the foreground and background colors aren't the same but both of them map to the same pixel value, then the foreground color is inverted. This ensures that, for instance, a red image drawn on a green background doesn't map to black on black.<P>
 On indexed devices, these source modes produce unexpected colors, because Color QuickDraw performs Boolean operations on the indexes rather than on actual color values, and the resulting index may point to an entirely unrelated color. On direct devices these transfer modes generally do not exhibit rigorous Boolean behavior except when white is set as the background color.<A NAME=MARKER-2-137></A> <P>
<A NAME=HEADING199-103></A>
<H3>Dithering</H3>
 <A NAME=MARKER-2-138></A>With the <CODE>CopyBits</CODE> and <CODE>CopyDeepMask</CODE> procedures you can use <B>dithering,</B> a technique used by these procedures for mixing existing colors together to create the illusion of a third color that may be unavailable on an indexed device. For example, if you specify dithering when copying a purple image from a 32-bit direct device to an 8-bit indexed device that does not have purple available, these procedures mix blue and red pixels to give the illusion of purple on the 8-bit device.<P>
 Dithering is also useful for improving images that you shrink when copying them from a direct device to an indexed device.<P>
 On computers running System 7, you can add dithering to any source mode by adding the following constant or the value it represents to the source mode:<P>
<PRE>
CONST ditherCopy = 64;  {add to source mode for dithering}
</PRE>
 For example, specifying <CODE>srcCopy</CODE> <CODE>+</CODE> <CODE>ditherCopy</CODE> in the <CODE>mode</CODE> parameter to <CODE>CopyBits</CODE> causes <CODE>CopyBits</CODE> to dither the image when it copies the image into the destination pixel map.<P>
 Dithering has drawbacks. First, dithering slows the drawing operation. Second, a clipped dithering operation does not provide pixel-for-pixel equivalence to the same unclipped dithering operation. When you don't specify a clipping region, for example, <CODE>CopyDeepMask</CODE> begins copying the upper-left pixel in your source image and, if necessary, begins calculating how to dither the upper-left pixel and its adjoining pixels in your destination in order to approximate the color of the source pixel. As <CODE>CopyDeepMask</CODE> continues copying pixels in this manner, there is a cumulative dithering effect based on the preceding pixels in the source image. If you specify a clipping region to <CODE>CopyDeepMask</CODE>, dithering begins with the upper-left pixel in the clipped region; this ignores the cumulative dithering effect that would otherwise occur by starting at the upper-left corner of the source image. In particular, if you clip and dither a region using the <CODE>srcXor</CODE> mode, you can't use <CODE>CopyDeepMask</CODE> a second time to copy that region back into the destination pixel map in order to erase that region.<P>
 If you replace the Color Manager's color search function with your own search function (as described in the chapter "Color Manager" in <I><A HREF="../ACI/ACI-2.html">Advanced Color Imaging on the Mac OS</A></I>), <CODE>CopyBits</CODE> and <CODE>CopyDeepMask</CODE> cannot perform dithering. Without dithering, your application does color mapping on a pixel-by-pixel basis. If your source pixel map is composed of indexed pixels, and if you have installed a custom color search function, Color QuickDraw calls your function once for each color in the color table for the source <CODE>PixMap</CODE> record. If your source pixel map is composed of direct pixels, Color QuickDraw calls your custom search function for each color in the pixel image for the source <CODE>PixMap</CODE> record; with an image of many colors, this can take a long time.<P>
 If you specify a destination rectangle that is smaller than the source rectangle when using <CODE>CopyBits</CODE>, <CODE>CopyMask</CODE>, or <CODE>CopyDeepMask</CODE> on a direct device, Color QuickDraw automatically uses an averaging technique to produce the destination pixels, maintaining high-quality images when shrinking them. On indexed devices, Color QuickDraw averages these pixels only if you specify dithering. Using dithering even when shrinking 1-bit images can produce much better representations of the original images. (The chapter "QuickDraw Drawing" includes a code sample called <CODE>MyShrinkImages</CODE>, shown in <A HREF=QuickDraw-60.html#MARKER-9-135>Listing 3-11 on page 3-29</A>, that illustrates how to use <CODE>CopyBits</CODE> to scale a bit image when copying it from one window into another.)<A NAME=MARKER-2-332></A> <A NAME=MARKER-2-140></A><P>
<A NAME=HEADING199-112></A>
<H3><A NAME=MARKER-9-141></A>Arithmetic Transfer Modes</H3>
 <A NAME=MARKER-2-164></A>In addition to the Boolean source modes described previously, Color QuickDraw offers a set of transfer modes that perform arithmetic operations on the values of the red, green, and blue components of the source and destination pixels. Although rarely used by applications, these <B>arithmetic transfer modes</B> produce predictable results on indexed devices because they work with RGB colors rather than with color table indexes. These arithmetic transfer modes are represented by the following constants:<P>
<PRE>
CONST
   blend       = 32; {replace destination pixel with a blend }
                     { of the source and destination pixel }
                     { colors; if the destination is a bitmap or }
                     { 1-bit pixel map, revert to srcCopy mode}
   addPin      = 33; {replace destination pixel with the sum of }
                     { the source and destination pixel colors-- }
                     { up to a maximum allowable value; if }
                     { the destination is a bitmap or }
                     { 1-bit pixel map, revert to srcBic mode}
   addOver     = 34; {replace destination pixel with the sum of }
                     { the source and destination pixel colors-- }
                     { but if the value of the red, green, or }
                     { blue component exceeds 65,536, then } 
                     { subtract 65,536 from that value; if the }
                     { destination is a bitmap or 1-bit }
                     { pixel map, revert to srcXor mode}
   subPin      = 35; {replace destination pixel with the }
                     { difference of the source and destination }
                     { pixel colors--but not less than a minimum }
                     { allowable value; if the destination }
                     { is a bitmap or 1-bit pixel map, revert to }
                     { srcOr mode}
   transparent = 36; {replace the destination pixel with the }
                     { source pixel if the source pixel isn't }
                     { equal to the background color}
   addMax      = 37; {compare the source and destination pixels, }
                     { and replace the destination pixel with }
                     { the color containing the greater }
                     { saturation of each of the RGB components; }
                     { if the destination is a bitmap or }
                     { 1-bit pixel map, revert to srcBic mode}
   subOver     = 38; {replace destination pixel with the }
                     { difference of the source and destination }
                     { pixel colors--but if the value of a red, }
                     { green, or blue component is }
                     { less than 0, add the negative result to }
                     { 65,536; if the destination is a bitmap or }
                     { 1-bit pixel map, revert to srcXor mode}
   adMin       = 39; {compare the source and destination pixels, }
                     { and replace the destination pixel with }
                     { the color containing the lesser }
                     { saturation of each of the RGB components; }
                     { if the destination is a bitmap or }
                     { 1-bit pixel map, revert to srcOr mode}
</PRE>
<DL>
<DT><B>Note</B>
<DD>You can use the arithmetic modes for all drawing operations; that is, your application can pass them in parameters to the <CODE>PenMode</CODE>, <CODE>CopyBits</CODE>, <CODE>CopyDeepMask</CODE>, and <CODE>TextMode</CODE> routines. (The <CODE>TextMode</CODE> procedure is described in <I><A HREF="../Text/Text-2.html">Inside Macintosh: Text</A></I>.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
 When you use the arithmetic transfer modes, each drawing routine converts indexed source and destination pixels to their RGB components; performs the arithmetic operation on each pair of red, green, and blue components to provide a new RGB color for the destination pixel; and then assigns the destination a pixel value close to the calculated RGB color. <P>
 For indexed pixels, the arithmetic transfer modes obtain the full 48-bit RGB color from the CLUT. For direct pixels, the arithmetic transfer modes use the 15 or 24 bits of the truncated RGB color. Note, however, that because the colors for indexed pixels depend on the set of colors currently loaded into a graphics device's CLUT, arithmetic transfer modes may produce effects that differ between indexed and direct devices.<P>
<DL>
<DT><B>Note</B>
<DD>The arithmetic transfer modes have no coloration effects.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
 When you use the <CODE>addPin</CODE> mode in a basic graphics port, the maximum allowable value for the destination pixel is always white. In a color graphics port, you can assign the maximum allowable value with the <CODE>OpColor</CODE> procedure, described on <A HREF=QuickDraw-230.html#MARKER-9-437>page 4-69</A>. Note that the <CODE>addOver</CODE> mode is slightly faster than the <CODE>addPin</CODE> mode.<A NAME=MARKER-2-350></A><P>
 When you use the <CODE>subPin</CODE> mode in a basic graphics port, the minimum allowable value for the destination pixel is always black. In a color graphics port, you can assign the minimum allowable value with the <CODE>OpColor</CODE> procedure. Note that the <CODE>subOver</CODE> mode <BR>is slightly faster than the <CODE>subPin</CODE> mode.<A NAME=MARKER-2-144></A><P>
 When you use the <CODE>addMax</CODE> and <CODE>adMin</CODE> modes, Color QuickDraw compares each RGB component of the source and destination pixels independently, so the resulting color isn't necessarily either the source or the destination color.<A NAME=MARKER-2-145></A><P>
 <A NAME=MARKER-2-352></A>When you use the <CODE>blend</CODE> mode, Color QuickDraw uses this formula to calculate the weighted average of the source and destination pixels, which Color QuickDraw assigns to the destination pixel:<P>
 dest = source  weight/65,535 + destination  (1 - weight/65,535)<P>
 In this formula, <I>weight</I> is an unsigned value between 0 and 65,535, inclusive. In a basic graphics port, the weight is set to 50 percent gray, so that equal weights of the source and destination RGB components are combined to produce the destination color. In a color graphics port, the weight is an <CODE>RGBColor</CODE> record that individually specifies the weights of the red, green, and blue components. You can assign the weight value with the <CODE>OpColor</CODE> procedure. <A NAME=MARKER-2-147></A><P>
 <A NAME=MARKER-2-353></A>The <CODE>transparent</CODE> mode is most useful on indexed devices, which have 8-bit and 4-bit pixel depths, and on black-and-white devices. You can specify the <CODE>transparent</CODE> mode in the <CODE>mode</CODE> parameter to the <CODE>TextMode</CODE>, <CODE>PenMode</CODE>, and <CODE>CopyBits</CODE> routines. To specify a transparent pattern, add the <CODE>transparent</CODE> constant to the <CODE>patCopy</CODE> constant:<P>
<PRE>
transparent + patCopy 
</PRE>
 The <CODE>transparent</CODE> mode is optimized to handle source bitmaps with large transparent holes, as an alternative to specifying an unusual clipping region or mask to the <CODE>CopyMask</CODE> procedure. Patterns aren't optimized, and may not draw as quickly.<A NAME=MARKER-2-149></A> <P>
 The arithmetic transfer modes are most useful in direct and 8-bit indexed pixels, but work on 4-bit and 2-bit pixels as well. If the destination pixel map is 1 bit deep, the arithmetic transfer mode reverts to a comparable Boolean transfer mode, as shown in <A HREF=#MARKER-9-15>Table 4-2</A>. (The <CODE>hilite</CODE> mode is explained in the next section.)<P>
<TABLE BORDER="0" CELLPADDING=3>
<CAPTION><A NAME=MARKER-9-15></A><B>Table 4-2 Arithmetic modes in a 1-bit environment</B></CAPTION>
<TH>Initial arithmetic mode<TH>Resulting source mode<TR>
<TD><CODE>blend</CODE><TD>srcCopy<A NAME=MARKER-2-327></A><TR>
<TD><CODE>addOver</CODE>, <CODE>subOver</CODE>, <CODE>hilite</CODE><TD>srcXor<A NAME=MARKER-2-333></A><TR>
<TD><CODE>addPin</CODE>, <CODE>addMax</CODE><TD>srcBic<A NAME=MARKER-2-339></A><TR>
<TD><CODE>subPin</CODE>, <CODE>adMin</CODE>, <CODE>transparent</CODE><TD>srcOr<A NAME=MARKER-2-19></A></TABLE>
<P>
 Because drawing with the arithmetic modes uses the closest matching colors, and not necessarily exact matches, these modes might not produce the results you expect. For instance, suppose your application uses the <CODE>srcCopy</CODE> mode to paint a green pixel on a screen with 4-bit pixel values. Of the 16 colors available, the closest green may contain a small amount of red, as in RGB components of 300 red, 65,535 green, and 0 blue. Then, your application uses <CODE>addOver</CODE> mode to paint a red pixel on top of the green pixel, ideally resulting in a yellow pixel. But the red pixel's RGB components are 65,535 red, 0 green, and 0 blue. Adding the red components of the red and green pixels wraps to 300, since the largest representable value is 65,535. In this case, <CODE>addOver</CODE> causes no visible change at all. You can prevent the maximum value from wrapping around by using the <CODE>OpColor</CODE> procedure to set the maximum allowable color to white, in which the maximum red value is 65,535. Then you can use the <CODE>addPin</CODE> mode to produce the desired yellow result.<P>
 Note that the arithmetic transfer modes don't call the Color Manager when mapping a requested RGB color to an indexed pixel value. If your application replaces the Color Manager's color-matching routines (which are described in the chapter "Color Manager" in <I><A HREF="../ACI/ACI-2.html">Advanced Color Imaging on the Mac OS</A></I>), <I></I>you must not use these modes, or you must maintain the inverse table yourself.<A NAME=MARKER-2-151></A><P>
<A NAME=HEADING199-131></A>
<H2><A NAME=MARKER-9-151></A>Highlighting</H2>
 <A NAME=MARKER-2-154></A>When <B>highlighting,</B> Color QuickDraw replaces the background color with the highlight color when your application draws or copies images between graphics ports. This has the visual effect of using a highlighting pen to select the object. For instance, TextEdit (described in <I><A HREF="../Text/Text-2.html">Inside Macintosh: Text</A></I>) uses highlighting to indicated selected text; if the highlight color is yellow, TextEdit draws the selected text, then uses <CODE>InvertRgn</CODE> to produce a yellow background for the text. <P>
 With basic QuickDraw, you can use <CODE>InvertRect</CODE>, <CODE>InvertRgn</CODE>, <CODE>InvertArc</CODE>, <CODE>InvertRoundRect</CODE>, or <CODE>InvertPoly</CODE> and any image-copying routine that uses the <CODE>srcXor</CODE> source mode to invert objects on the screen. <P>
 In general, however, you should use highlighting with Color QuickDraw when selecting and deselecting objects such as text or graphics. (Highlighting has no effect in basic QuickDraw.) The line reading "hilited" in <A HREF=#MARKER-9-153>Figure 4-15</A> uses highlighting; the user selected red as the highlight color, which the application uses as the background for the text. (This figure shows the effect in grayscale.) The application simply inverts the background for the line reading "inverted." Inversion reverses the colors of all pixels within the rectangle's boundary. On a black-and-white monitor, this changes all black pixels in the shape to white, and changes all white pixels to black. Although this procedure operates on color pixels in color graphics ports, the results are predictable only with direct pixels or 1-bit pixel maps.<P>
<B>Figure 4-15  <A NAME=MARKER-9-153></A>Difference between highlighting and inverting</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/CQD-S-04.jpg"><BR>
 The global variable <CODE>HiliteRGB</CODE> is read from parameter RAM when the machine starts. Basic graphics ports use the color stored in the <CODE>HiliteRGB</CODE> global variable as the highlight color. Color graphics ports default to the <CODE>HiliteRGB</CODE> global variable, but you can override this by using the <CODE>HiliteColor</CODE> procedure, described on <A HREF=QuickDraw-231.html#MARKER-9-446>page 4-69</A>. <A NAME=MARKER-2-154></A><P>
 To turn highlighting on when using Color QuickDraw, you can clear the highlight bit just before calling <CODE>InvertRect</CODE>, <CODE>InvertRgn</CODE>, <CODE>InvertArc</CODE>, <CODE>InvertRoundRect</CODE>, <CODE>InvertPoly</CODE>, or any drawing or image-copying routine that uses the <CODE>patXor</CODE> or <CODE>srcXor</CODE> transfer mode. On a bitmap or a 1-bit pixel map, this works exactly like inversion and is compatible with all versions of QuickDraw. <P>
 The following constant represents the highlight bit:<P>
<PRE>
CONST pHiliteBit = 0; {flag bit in HiliteMode used with BitClr}
</PRE>
 You can use the <CODE>BitClr</CODE> procedure as shown in <I></I><A HREF=#MARKER-9-156>Listing 4-6</A> to clear system software's highlight bit (<CODE>BitClr</CODE> is described in <I><A HREF="../OSUtilities/OSUtilities-2.html">Inside Macintosh: Operating System Utilities</A></I>).<A NAME=MARKER-2-362></A><P>
<B>Listing 4-6  <A NAME=MARKER-9-156></A>Setting the highlight bit</B><P>
<PRE>
PROCEDURE MySetHiliteMode;
BEGIN
   BitClr(Ptr(HiliteMode), pHiliteBit);
END;
</PRE>
 <A HREF=#MARKER-9-157>Listing 4-7</A> shows the code that produced the effects in <A HREF=#MARKER-9-153>Figure 4-15</A>.<P>
<B>Listing 4-7  <A NAME=MARKER-9-157></A>Using highlighting for text</B><P>
<PRE>
PROCEDURE HiliteDemonstration (window: WindowPtr);
CONST
   s1 = ' hilited ';
   s2 = ' inverted ';
VAR
   familyID:   Integer;
   r1, r2:     Rect;
   info:       FontInfo;
   bg:         RGBColor;
BEGIN
   TextSize(48);
   GetFontInfo(info);
   SetRect(r1, 0, 0, StringWidth(s1), info.ascent + info.descent);
   SetRect(r2, 0, 0, StringWidth(s2), info.ascent + info.descent);
   OffsetRect(r1, 30, 20);
   OffsetRect(r2, 30, 100);
{fill the background with a light-blue color}
   bg.red := $A000;
   bg.green := $FFFF;
   bg.blue := $E000;
   RGBBackColor(bg);
   EraseRect(window^.portRect);
{draw the string to highlight}
   MoveTo(r1.left + 2, r1.bottom - info.descent);
   DrawString(s1);
   MySetHiliteMode;  {clear the highlight bit}
{InvertRect replaces pixels in background color with the }
{ user-specified highlight color}
   InvertRect(r1);
{the highlight bit is reset automatically}
{show inverted text, for comparison}
   MoveTo(r2.left + 2, r2.bottom - info.descent);
   DrawString(s2);
   InvertRect(r2);
END;
</PRE>
 Color QuickDraw resets the highlight bit after performing each drawing operation, so your application should always clear the highlight bit immediately before calling a routine with which you want to use highlighting.<P>
 Another way to use highlighting is to add this constant or its value to the mode you specify to the <CODE>PenMode</CODE>, <CODE>CopyBits</CODE>, <CODE>CopyDeepMask</CODE>, and <CODE>TextMode</CODE> routines:<P>
<PRE>
CONST hilite = 50;{add to source or pattern mode for highlighting}
</PRE>
 Highlighting uses the pattern or source image to decide which bits to exchange; only bits that are on in the pattern or source image can be highlighted in the destination. <P>
 <A NAME=MARKER-2-568></A>A very small selection should probably not use highlighting, because it might be too hard to see the selection in the highlight color. TextEdit, for instance, uses highlighting to select and deselect text, but not to highlight the insertion point.<P>
 Highlighting is optimized to look for consecutive pixels in either the highlight or background colors. For example, if the source is an all-black pattern, the highlighting is especially fast, operating internally on one long word at a time instead of one pixel at a time. Highlighting a large area without such consecutive pixels (a gray pattern, for instance) can be slow.<A NAME=MARKER-2-570></A><A NAME=MARKER-2-315></A><A NAME=MARKER-2-292></A><A NAME=MARKER-2-152></A><P>

</BLOCKQUOTE>
<HR>
<center>
<A HREF="QuickDraw-198.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="QuickDraw-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="QuickDraw-476.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="QuickDraw-200.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="QuickDraw-3.html">&copy; Apple Computer, Inc.</A><br>7 JUL 1996</center></font><P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML>  
