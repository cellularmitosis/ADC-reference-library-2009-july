<!-- Generated by Harlequin WebMaker 2.2.3 (30-Apr-1996)
Macintosh Common Lisp Version 3.0kp2p2 [AppGen 3.0b1kp2p2] -->
<HTML> <HEAD>
<TITLE>Converting Between Binary and Decimal Numbers(IM:PN)</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING35></A>


<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->


<!-- Main Body -->

<CENTER>
<P>
<A HREF="PPCNumerics-34.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="PPCNumerics-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="PPCNumerics-192.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="PPCNumerics-36.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="PPCNumerics-2.html"><B>PowerPC Numerics </B></A> / <A HREF="PPCNumerics-9.html"><B>Part 1 - The PowerPC Numerics Environment</B></A><BR><DD><A HREF="PPCNumerics-29.html"><B>Chapter 5 - Conversions</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING35-0></A>
<H1>Converting Between Binary and Decimal Numbers</H1>
 <A NAME=MARKER-2-28></A>PowerPC Numerics automatically converts between binary and decimal numbers, and some implementations allow you to perform such conversions manually. This section describes when conversions between binary and decimal numbers are performed and how they are performed. <P>
<A NAME=HEADING35-2></A>
<H2>Accuracy of Decimal-to-Binary Conversions</H2>
 <A NAME=MARKER-2-11></A>As explained in <A HREF=PPCNumerics-10.html#MARKER-9-3>Chapter 1, "IEEE Standard Arithmetic,"</A> some real numbers that can be represented exactly in decimal cannot be represented exactly as binary floating-point numbers. As a result, it is important that conversions between the two types of numbers be as accurate as possible. Given a rounding direction, for every decimal value there is a best--that is, correctly rounded--binary value for each binary format. Conversely, for any rounding direction, each binary value has a corresponding best decimal representation for a given decimal format. Ideally, binary-to-decimal conversions should obtain this best value to reduce accumulated errors.<P>
 Conversion functions in PowerPC Numerics meet or exceed the stringent error bounds specified by the IEEE standard. This means that even though in extreme cases the conversions do not deliver the correctly rounded results, the results they do deliver are very nearly as good as the correctly rounded results. (The IEEE standard does not specify error bounds for conversions involving values beyond the double format. See IEEE Standard 754 for a more detailed description of error bounds.)<A NAME=MARKER-2-15></A><P>
<A NAME=HEADING35-5></A>
<H2>Automatic Conversions</H2>
 <A NAME=MARKER-2-43></A>Whenever a computer reads a decimal number into a binary format, it automatically converts the number to binary. Similarly, whenever a computer writes a binary number and a decimal format is specified for the output, it automatically converts the number from binary to decimal. <P>
 Suppose an application repeatedly reads and writes decimal data, meaning that it repeatedly converts values from decimal to binary and back. Such conversion cycles would occur, for example, in repeated execution of an application that updates a decimal file on a binary computer. Each time the application runs, it deliberately changes only a handful of values, but all the values get converted from decimal to binary and back again. Some computers use a conversion strategy that just drops extra digits; that is, it truncates the value. If the application were run on such a computer, the computer's rounding by truncation could cause severe downward drift. Using IEEE arithmetic with rounding to nearest, the values do not drift when you run the application repeatedly. That is, even though the conversions might change a few values the first time you run the program, there will be no further changes on subsequent conversions.<P>
 <A HREF=#MARKER-9-38>Figure 5-3</A> is a graphical model of such a conversion cycle with rounding to nearest, where the vertical marks represent decimal and binary computer numbers on the number line. The one-way arrow shows a decimal-to-binary conversion that does not get converted back to the original decimal value; the two-way arrow shows subsequent conversions returning the same value. In all cases, repeated conversions after the first give the same binary value; the error does not keep increasing.<P>
<B>Figure 5-3  <A NAME=MARKER-9-38></A>Conversion cycle with first-time error</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/PPCN-L-13.jpg"><P>
 What's more, if the binary format has enough extra precision beyond that of the decimal format, to-nearest rounding returns the original value the first time. The two-way arrow in <A HREF=#MARKER-9-39>Figure 5-4</A> shows a conversion cycle with different degrees of precision; here, the nearest decimal value to the binary result is always the original decimal value.<P>
<B>Figure 5-4  <A NAME=MARKER-9-39></A>Conversion cycle with correct result</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/PPCN-L-14.jpg"><P>
 For the round-trip conversion from decimal to binary and back to decimal, the size of the decimal number you can start with and be sure that the round-trip produces the original value exactly depends on the binary data format. For single format, at most 6 decimal digits can be converted and return you the exact original value; for double format, 15 decimal digits, and for double-double format, 31 decimal digits.<P>
 You might also want to be sure conversions from binary numbers to decimal and back return the original value. For example, suppose your program writes out some stored values, and the output from this program is used as input to another program. You want to know how many decimal digits to print out to ensure that the conversion back to binary results in the original value. Again, the binary data format determines how many decimal digits are required for the conversion to return the original value. For single format, printing out 9 decimal digits insures an exact round trip; for double format, 17 decimal digits.<P>
<DL>
<DT><B>Note</B>
<DD>These values bracket the ones given in <A HREF=PPCNumerics-19.html#MARKER-9-11>Table 2-7 on page 2-15</A>.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
 <A NAME=MARKER-2-20></A><A NAME=MARKER-2-12></A>Note that for the double-double format, because of its indefinite precision, there is no reasonable number of decimal digits you can print out to guarantee the conversion returns the original value. The number of decimal digits required varies with the difference between the head's exponent and the tail's exponent. In the best case, the head's exponent is exactly 54 greater than the tail's exponent so that there is no gap between the head and the tail. In this case, 34 decimal digits are required to reproduce the original double-double value exactly. The worst case is when the tail is 0. No number of decimal digits is sufficient to provide an exact round trip when the tail is 0 (assuming an infinite exponent range).<P>
 Consider the case where a double-format number is converted to double-double format. For example, if you take 1.2 represented in double format and convert it to double-double format, the result (in hexadecimal) is<P>
<PRE>
0x3FF33333 0x33333333 0x00000000 0x00000000
</PRE>
 The first two hexadecimal numbers are stored in the head, and the last two are stored in the tail. Suppose you want to convert this double-double number to decimal. If you choose 34 decimal digits, the result is<P>
<PRE>
1.199999999999999955591079014993738
</PRE>
 This result is the closest 34-decimal digit approximation of the above double-double number. It is also the closest 34-decimal digit approximation of an infinitely precise binary value whose exponent is 0 and whose fractional part is represented by 13 sequences of "0011" followed by 52 binary zeros followed by some nonzero bits. When you convert this decimal value back to double-double format, PowerPC Numerics returns the closest double-double approximation of the infinitely precise value using all of the bits of precision available to it. That is, it will use all 53 bits in the head and 53 bits in the tail to store nonzero values and adjust the exponent of the tail accordingly. The result is<P>
<PRE>
0x3FF33333 0x33333333 0xXXXYZZZZ 0xZZZZZZZZ
</PRE>
 where <CODE>XXX</CODE> represents the sign and exponent of the tail, and <CODE>YZZZ</CODE> . . . represents the start of a nonzero value. Because the tail is always nonzero, this value is guaranteed to be not equal to the original double-double value.<A NAME=MARKER-2-2></A><A NAME=MARKER-2-86></A><A NAME=MARKER-2-41></A><P>
<A NAME=HEADING35-25></A>
<H2>Manual Conversions</H2>
 A numeric implementation may provide functions that convert binary floating-point numbers to decimal and that convert decimal numbers to binary floating-point numbers. The decimal number can be input in one of two formats: as part of a decimal structure (described next) or as a character string. A numeric implementation also may provide a scanner for converting from decimal strings to decimal structures and a formatter for converting from decimal structures to decimal strings.<A NAME=MARKER-10-46></A><P>
<A NAME=HEADING35-27></A>
<H3>Converting Between Floating-Point and Decimal Structures</H3>
 <A NAME=MARKER-2-44></A><A NAME=MARKER-2-25></A>If the decimal number is part of a <B>decimal structure,</B> the structure contains<P>
<UL>
<LI>a sign field
<LI>an exponent field
<LI>a significand field<P>
</UL>
 For example, the file <CODE>fp.h</CODE> defines the following decimal structure for C:<P>
<PRE>
typedef struct decimal 
{
   char sgn;
   char unused;
   short exp;
   struct 
   {
      unsigned char length;
      unsigned char text[SIGDIGLEN];
      unsigned chard unused;
   } sig;
} decimal;
</PRE>
 The field <CODE>sgn</CODE> represents the sign, <CODE>exp</CODE> represents the exponent, and the structure <CODE>sig</CODE> represents the significand. The <CODE>length</CODE> field of the <CODE>sig</CODE> structure gives the length of the significand, and the character array <CODE>text</CODE> contains the significand. The <CODE>decimal</CODE> structure may either be input for a function that converts it to a binary floating-point number or output for a function that converts a binary floating-point number to this format.<A NAME=MARKER-2-27></A><P>
<DL>
<DT><B>IMPORTANT</B>
<DD>When you create a <CODE>decimal</CODE> structure, you must set <CODE>sig.length</CODE> to the size of the string you place in <CODE>sig.text</CODE>. You cannot leave the <CODE>length</CODE> field undefined.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
 <A NAME=MARKER-2-24></A>Conversions from floating-point types to decimal structures also require a <B>decimal format structure</B> to specify how the decimal number should look. The decimal format structure contains the following information:<P>
<UL>
<LI>whether the number should be in fixed or floating style
<LI>if fixed style, the number of digits that should be to the right of the decimal point
<LI>if floating style, the number of significant digits<P>
</UL>
 For example, the file <CODE>fp.h</CODE> defines the <CODE>decform</CODE> structure for this purpose for the C programming language:<P>
<PRE>
typedef struct decform 
{
   char style;    /* FLOATDECIMAL or FIXEDDECIMAL */
   char unused;
   short digits;
} decform;
</PRE>
<A NAME=HEADING35-42></A>
<H3>Converting Between Floating-Point and Decimal Strings</H3>
 <A NAME=MARKER-2-23></A>Languages may provide routines to convert between numeric decimal strings and the numeric data formats. Note that conversions take place in the following cases:<P>
<UL>
<LI>use of decimal constants in source code
<LI>input of decimal strings (by procedures such as <CODE>read</CODE> in Pascal)
<LI>calls to explicit routines<P>
</UL>
 All conversions to decimal strings are controlled by a decimal formatting structure as described in the previous section.<A NAME=MARKER-2-31></A><A NAME=MARKER-2-20></A><P>
 <A NAME=MARKER-2-55></A><A NAME=MARKER-2-36></A><P>

</BLOCKQUOTE>
<HR>
<center>
<A HREF="PPCNumerics-34.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="PPCNumerics-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="PPCNumerics-192.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="PPCNumerics-36.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="PPCNumerics-3.html">&copy; Apple Computer, Inc.</A><br>13 JUL 1996</center></font><P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML>  
