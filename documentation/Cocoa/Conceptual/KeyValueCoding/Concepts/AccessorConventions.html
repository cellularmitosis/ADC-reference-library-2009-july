<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>Key-Value Coding Programming Guide: Key-Value Coding Accessor Methods</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Key-Value Coding Accessor Methods"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/20002174" title="Key-Value Coding Accessor Methods"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../index.html#//apple_ref/doc/uid/TP30000440-TP30000416" target="_top">Cocoa</a> &gt; <a href="../../../DataManagement-date.html#//apple_ref/doc/uid/TP30000440-TP30000416-TP30000445" target="_top">Data Management</a> &gt; <a href="../index.html" target="_top">Key-Value Coding Programming Guide</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="BasicPrinciples.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="Validation.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>
        
        
        <a name="//apple_ref/doc/uid/20002174-BAJEAIEE" title="Key-Value Coding Accessor Methods"></a><hr /><H1>Key-Value Coding Accessor Methods</H1>

<p>In order for key-value coding to locate the accessor methods to use for invocations of <code>valueForKey:</code>,  <code>setValue:forKey:</code>, <code>mutableArrayValueForKey:</code> and <code>mutableSetValueForKey:</code> you need to implement the key-value coding accessor methods.</p><div class="notebox"><a name="//apple_ref/doc/uid/20002174-SW9" title="Note"></a><p><strong>Note:</strong>&nbsp;The accessor patterns in this section are written in the form <code>-set&lt;Key>:</code> or <code>-&lt;key></code>. The <code>&lt;key></code> text is a placeholder for the name of your property. Your implementation of the corresponding method should substitute the  property name for <code>&lt;Key></code> or <code>&lt;key></code> respecting the case specified by key. For example, for the property <code>name</code>, <code>-set&lt;Key>:</code> would expand to <code>-setName:</code>, <code>-&lt;key></code> would simply be <code>-name</code>. </p></div>

<!-- This template is being used for both PDF and HTML. -->

    
    <!-- TopicBook.pm uses this template for its miniTOCs, but needs a different title. -->
    <h4>Contents:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="AccessorConventions.html#//apple_ref/doc/uid/20002174-178660">Commonly Used Accessor Patterns</a>
				
			<br/>
			
        
			
			
				<a href="AccessorConventions.html#//apple_ref/doc/uid/20002174-178830-BAJEDEFB">Collection Accessor Patterns for To-Many Properties</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/20002174-178660" title="Commonly Used Accessor Patterns"></a><h2>Commonly Used Accessor Patterns</h2>
<p>The format for an accessor method that returns a property is <code>-&lt;key></code>. The <code>-&lt;key></code> method returns an object, scalar or a data structure. The alternate naming form <code>-is&lt;Key></code> is supported for Boolean properties. </p>
<p>The example in <span class="content_text">Listing 1</span> shows the method declaration for the <code>hidden</code> property using the typical convention, and <span class="content_text">Listing 2</span> shows the alternate format.</p>
<a name="//apple_ref/doc/uid/20002174-178719-BAJCJBGH" title="Listing 1Accessor naming variations for a hidden property key"></a><p class="codesample"><a name="//apple_ref/doc/uid/20002174-178719" title="Listing 1Accessor naming variations for a hidden property key"></a><strong>Listing 1&nbsp;&nbsp;</strong>Accessor naming variations for a hidden property key</p><div class="codesample"><table><tr><td scope="row"><pre>- (BOOL)hidden<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>   // implementation specific code<span></span></pre></td></tr><tr><td scope="row"><pre>   return ...;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div>
<a name="//apple_ref/doc/uid/20002174-178749-BAJHJDII" title="Listing 2Alternate form accessor for a hidden property key"></a><p class="codesample"><a name="//apple_ref/doc/uid/20002174-178749" title="Listing 2Alternate form accessor for a hidden property key"></a><strong>Listing 2&nbsp;&nbsp;</strong>Alternate form accessor for a hidden property key</p><div class="codesample"><table><tr><td scope="row"><pre>- (BOOL)isHidden<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>   // implementation specific code<span></span></pre></td></tr><tr><td scope="row"><pre>   return ...;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div>
<p>In order for an attribute or to-one relationship property to support <code>setValue:forKey:</code> an accessor in the form <code>-set&lt;Key>:</code> must be implemented. <span class="content_text">Listing 3</span> shows an example accessor method for the <code>hidden</code> property key.</p>
<a name="//apple_ref/doc/uid/20002174-178809-BAJEGEBG" title="Listing 3Accessor naming convention to support a hidden property key"></a><p class="codesample"><a name="//apple_ref/doc/uid/20002174-178809" title="Listing 3Accessor naming convention to support a hidden property key"></a><strong>Listing 3&nbsp;&nbsp;</strong>Accessor naming convention to support a hidden property key</p><div class="codesample"><table><tr><td scope="row"><pre>- (void)setHidden:(BOOL)flag<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>   // implementation specific code<span></span></pre></td></tr><tr><td scope="row"><pre>   return;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>You must also implement a suitable means of representing a <code>nil</code> value for an attribute. The key-value coding method <code>setNilValueForKey:</code> method is called when you attempt to set an attribute to <code>nil</code>. This provides the opportunity to provide appropriate default values for your application, or handle keys that donâ€™t have corresponding accessors in the class. </p><p>The following example sets the <code>hidden</code> attribute to <code>NO</code> when an attempt is made to it to <code>nil</code>. It creates an <code>NSNumber</code> instance containing the boolean value and then uses <code>setValue:forKey:</code> to set the new value. This maintains encapsulation of the model and ensures that any additional actions that should occur as a result of setting the value will actually occur. This is considered better practice than calling an accessor method or setting an instance variable directly.</p><div class="codesample"><table><tr><td scope="row"><pre>- (void)setNilValueForKey:(NSString *)theKey<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    if ([theKey isEqualToString:@"hidden"]) {<span></span></pre></td></tr><tr><td scope="row"><pre>        [self setValue:[NSNumber numberWithBool:YES] forKey:@"hidden"];<span></span></pre></td></tr><tr><td scope="row"><pre>    } else<span></span></pre></td></tr><tr><td scope="row"><pre>        [super setNilValueForKey:theKey];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div>
<a name="//apple_ref/doc/uid/20002174-178830" title="Collection Accessor Patterns for To-Many Properties"></a><a name="//apple_ref/doc/uid/20002174-178830-BAJEDEFB" title="Collection Accessor Patterns for To-Many Properties"></a><h2>Collection Accessor Patterns for To-Many Properties</h2><p>Although your application can implement accessor methods for to-many relationship properties using the <code>-&lt;key></code> and <code>-set&lt;Key>:</code> accessor forms, you should typically only use those to create the collection object. For manipulating the contents of the collection it is best practice to implement the additional accessor methods referred to as the collection accessor methods. You then use the collection accessor methods, or a mutable collection proxy returned by <code>mutableArrayValueForKey:</code> or <code>mutableSetValueForKey:</code>.</p><p>Implementing the collection accessor methods, instead of, or in addition too, the basic getter for the relationship, can have many advantages:</p><ul class="ul"><li class="li"><p>Performance can be increased in the case of mutable to-many relationships, often significantly.</p></li><li class="li"><p>To-many relationships can be modeled with classes other than <code>NSArray</code> or <code>NSSet</code> by implementing the appropriate collection accessors. Implementing collection accessor methods for a property makes that property indistinguishable from an array or set when using key-value coding methods.</p></li><li class="li"><p>You can use the collection accessor methods directly to make modifications to the collection in a key-value observing compliant way. See <em><a href="../../KeyValueObserving/index.html#//apple_ref/doc/uid/10000177i" target="_top">Key-Value Observing Programming Guide</a></em> for more information on key-value observing. </p></li></ul><p>There are two variations of collection accessors: indexed accessors for ordered to-many relationships (typically represented by <code>NSArray</code>) and unordered accessors for relationships that donâ€™t require an order to the members (represented by <code>NSSet</code>).</p><a name="//apple_ref/doc/uid/20002174-SW4" title="Indexed Accessor Pattern"></a><h3>Indexed Accessor Pattern</h3>
<p>The indexed accessor methods define a mechanism for counting, retrieving, adding, and replacing objects in an ordered relationship. Typically this relationship is an instance of <code>NSArray</code> or <code>NSMutableArray</code>, however any object can implement these methods and be manipulated just as if it was an array. You are not restricted to simply implementing these methods, you can also invoke them as well to interact directly with objects in the relationship.</p><p>There are indexed accessors which return data from the collection (the getter variation) and mutable accessors that provide an interface for <code>mutableArrayValueForKey:</code> to modify the collection.</p><a name="//apple_ref/doc/uid/20002174-SW10" title="Getter Indexed Accessors"></a><h4>Getter Indexed Accessors</h4><p>In order to support read-only access to an ordered to-many relationship implement the following methods:</p><ul class="spaceabove"><li class="li"><p><code>-countOf&lt;Key></code>. Required This is the analogous to the <code>NSArray</code> primitive method <code><a href="../../../Reference/Foundation/Classes/NSArray_Class/Reference/Reference.html#//apple_ref/occ/instm/NSArray/count" target="_top">count</a></code>.</p></li><li class="li"><p><code>-objectIn&lt;Key>AtIndex:</code> or <code>-&lt;key>AtIndexes:</code>. One of these methods must be implemented. They correspond to the <code>NSArray</code> methods <code><a href="../../../Reference/Foundation/Classes/NSArray_Class/Reference/Reference.html#//apple_ref/occ/instm/NSArray/objectAtIndex:" target="_top">objectAtIndex:</a></code> and <code><a href="../../../Reference/Foundation/Classes/NSArray_Class/Reference/Reference.html#//apple_ref/occ/instm/NSArray/objectsAtIndexes:" target="_top">objectsAtIndexes:</a></code>.</p></li><li class="li"><p><code>-get&lt;Key>:range:</code>. Implementing this method is optional, but offers additional performance gains. This method corresponds to the <code>NSArray</code> method <code><a href="../../../Reference/Foundation/Classes/NSArray_Class/Reference/Reference.html#//apple_ref/occ/instm/NSArray/getObjects:range:" target="_top">getObjects:range:</a></code>.</p></li></ul>
<p>An implementation of the <code>-countOf&lt;Key></code> method simply returns the number of objects in the to-many relationship as an <code>NSUInteger</code>. The code fragment in <span class="content_text"><a href="AccessorConventions.html#//apple_ref/doc/uid/20002174-SW2">Listing 4</a></span> illustrates the <code>-countOf&lt;Key></code> implementation for the to-many relationship property <code>employees</code>.</p><a name="//apple_ref/doc/uid/20002174-SW2" title="Listing 4Example -count&amp;lt;Key&gt; implementation"></a><p class="codesample"><strong>Listing 4&nbsp;&nbsp;</strong>Example <code>-count&lt;Key></code> implementation</p><div class="codesample"><table><tr><td scope="row"><pre>- (NSUInteger)countOfEmployees<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    return [employees count];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>The <code>-objectIn&lt;Key>AtIndex:</code> method returns the object at the specified index in the to-many relationship. The <code>-&lt;key>AtIndexes:</code> accessor form returns an array of objects at the indexes specified by the <code>NSIndexSet</code> parameter. Only one of these two methods must be implemented.</p>
<p>The code fragment in <span class="content_text">Listing 5</span> shows <code>-objectIn&lt;Key>AtIndex:</code> and <code>-&lt;key>AtIndexes:</code> implementations for a to-many relationship property <code>employees</code>.</p>
<p></p>
<a name="//apple_ref/doc/uid/20002174-180363-BAJDHFHH" title="Listing 5Example -objectIn&amp;lt;Key&gt;AtIndex: and -&amp;lt;key&gt;AtIndexes: implementations"></a><p class="codesample"><a name="//apple_ref/doc/uid/20002174-180363" title="Listing 5Example -objectIn&amp;lt;Key&gt;AtIndex: and -&amp;lt;key&gt;AtIndexes: implementations"></a><strong>Listing 5&nbsp;&nbsp;</strong>Example <code>-objectIn&lt;Key>AtIndex:</code> and <code>-&lt;key>AtIndexes:</code> implementations</p><div class="codesample"><table><tr><td scope="row"><pre>- (id)objectInEmployeesAtIndex:(NSUInteger)index<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    return [employees objectAtIndex:index];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>- (NSArray *)employeesAtIndexes:(NSIndexSet *)indexes<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    return [employees objectsAtIndexes:indexes];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div>
<p>If benchmarking indicates that performance improvements are required, you can also implement <code>-get&lt;Key>:range:</code>. Your implementation of this accessor should return in the buffer given as the first parameter the objects that fall within the range specified by the second parameter. </p><p><span class="content_text">Listing 6</span> shows an example implementation of the <code>-get&lt;Key>:range:</code> accessor pattern for the to-many <code>employee</code> property.</p><a name="//apple_ref/doc/uid/20002174-SW1" title="Listing 6Example -get&amp;lt;Key&gt;:range: implementation"></a><p class="codesample"><strong>Listing 6&nbsp;&nbsp;</strong>Example <code>-get&lt;Key>:range:</code> implementation</p><div class="codesample"><table><tr><td scope="row"><pre>- (void)getEmployees:(Employee **)buffer range:(NSRange)inRange<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    // Return the objects in the specified range in the provided<span></span></pre></td></tr><tr><td scope="row"><pre>    // buffer. For example, if the employees were stored in an<span></span></pre></td></tr><tr><td scope="row"><pre>    // underlying NSArray<span></span></pre></td></tr><tr><td scope="row"><pre>    [employees getObjects:buffer range:inRange];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/20002174-SW11" title="Mutable Indexed Accessors"></a><h4>Mutable Indexed Accessors</h4><p>Supporting a mutable to-many relationship with indexed accessors requires implementing additional methods. Implementing the mutable indexed accessors allow your application to interact with the indexed collection in an easy and efficient manner by using of the array proxy returned by <code>mutableArrayValueForKey:</code>. In addition, by implementing these methods for a to-many relationship your class will be key-value observing compliant for that property (see <em><a href="../../KeyValueObserving/index.html#//apple_ref/doc/uid/10000177i" target="_top">Key-Value Observing Programming Guide</a></em>).</p><div class="notebox"><a name="//apple_ref/doc/uid/20002174-SW12" title="Note"></a><p><strong>Note:</strong>&nbsp;You are strongly advised to implement these mutable accessors rather than relying on a accessor that returns a mutable array directly. The mutable accessors are much more efficient when making changes to the data in the relationship. </p></div><p>In order to be key-value coding compliant for a mutable ordered to-many relationship you must implement the following methods:</p><ul class="spaceabove"><li class="li"><p><code>-insertObject:in&lt;Key>AtIndex:</code> or <code>-insert&lt;Key>:atIndexes:</code>. At least one of these methods must be implemented. These are analogous to the <code>NSMutableArray</code> methods <code><a href="../../../Reference/Foundation/Classes/NSMutableArray_Class/Reference/Reference.html#//apple_ref/occ/instm/NSMutableArray/insertObject:atIndex:" target="_top">insertObject:atIndex:</a></code> and <code><a href="../../../Reference/Foundation/Classes/NSMutableArray_Class/Reference/Reference.html#//apple_ref/occ/instm/NSMutableArray/insertObjects:atIndexes:" target="_top">insertObjects:atIndexes:</a></code>.</p></li><li class="li"><p><code>-removeObjectFrom&lt;Key>AtIndex:</code> or <code>-remove&lt;Key>AtIndexes:</code>. At least one of these methods must be implemented. These methods correspond to the <code>NSMutableArray</code> methods <code><a href="../../../Reference/Foundation/Classes/NSMutableArray_Class/Reference/Reference.html#//apple_ref/occ/instm/NSMutableArray/removeObjectAtIndex:" target="_top">removeObjectAtIndex:</a></code> and <code><a href="../../../Reference/Foundation/Classes/NSMutableArray_Class/Reference/Reference.html#//apple_ref/occ/instm/NSMutableArray/removeObjectsAtIndexes:" target="_top">removeObjectsAtIndexes:</a></code> respectively.</p></li><li class="li"><p><code>-replaceObjectIn&lt;Key>AtIndex:withObject:</code> or <code>-replace&lt;Key>AtIndexes:with&lt;Key>:</code>. Optional. Implement if benchmarking indicates that performance is an issue.</p></li></ul><p>The <code>-insertObject:in&lt;Key>AtIndex:</code> method is passed the object to insert, and an <code>NSUInteger</code> that specifies the index where it should be inserted. The <code>-insert&lt;Key>:atIndexes:</code> method inserts an array of objects into the collection at the indices specified by the passed <code>NSIndexSet</code>. You are only required to implement one of these two methods. </p><p><span class="content_text"><a href="AccessorConventions.html#//apple_ref/doc/uid/20002174-SW6">Listing 7</a></span> shows sample implementations of both insert accessors for the to-many <code>employee</code> property.</p><a name="//apple_ref/doc/uid/20002174-SW6" title="Listing 7Example -insertObject:in&amp;lt;Key&gt;AtIndex: and -removeObjectFrom&amp;lt;Key&gt;AtIndex: accessors"></a><p class="codesample"><a name="//apple_ref/doc/uid/20002174-178955" title="Listing 7Example -insertObject:in&amp;lt;Key&gt;AtIndex: and -removeObjectFrom&amp;lt;Key&gt;AtIndex: accessors"></a><strong>Listing 7&nbsp;&nbsp;</strong>Example <code>-insertObject:in&lt;Key>AtIndex:</code> and <code>-removeObjectFrom&lt;Key>AtIndex:</code> accessors</p><div class="codesample"><table><tr><td scope="row"><pre>- (void)insertObject:(Employee *)employee<span></span></pre></td></tr><tr><td scope="row"><pre>   inEmployeesAtIndex:(NSUInteger)index<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    [employees insertObject:anObject atIndex:index];<span></span></pre></td></tr><tr><td scope="row"><pre>    return;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>- (void)insertEmployees:(NSArray *)employeeArray<span></span></pre></td></tr><tr><td scope="row"><pre>              atIndexes:(NSIndexSet *)indexes<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    [employees insertObjects:employeeArray atIndexes:indexes];<span></span></pre></td></tr><tr><td scope="row"><pre>    return;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>The <code>-removeObjectFrom&lt;Key>AtIndex:</code> method is passed an <code>NSUInteger</code> value specifying the index of the object to be removed from the relationship. The <code>-remove&lt;Key>AtIndexes:</code> is passed an <code>NSIndexSet</code> specifying the indexes of the objects to be removed from the relationship. Again, you are only required to implement one of these methods.</p><p><span class="content_text">Listing 8</span> shows sample implementations of <code>-removeObjectFrom&lt;Key>AtIndex:</code> and <code>-remove&lt;Key>AtIndexes:</code> implementations for the to-many <code>employee</code> property.</p>
<a name="//apple_ref/doc/uid/20002174-178955-BAJJCDIB" title="Listing 8Example -removeObjectFrom&amp;lt;Key&gt;AtIndex: and -remove&amp;lt;Key&gt;AtIndexes: accessors"></a><p class="codesample"><strong>Listing 8&nbsp;&nbsp;</strong>Example <code>-removeObjectFrom&lt;Key>AtIndex:</code> and <code>-remove&lt;Key>AtIndexes:</code> accessors</p><div class="codesample"><table><tr><td scope="row"><pre>- (void)removeObjectFromEmployeesAtIndex:(NSUInteger)idx<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    [employees removeObjectAtIndex:index];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>- (void)removeEmployeesAtIndexes:(NSIndexSet *)indexes<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    [employees removeObjectsAtIndexes:indexes];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div>
<p>If benchmarking indicates that performance improvements are required, you can also implement one or both of the optional replace accessors. Your implementation of either <code>-replaceObjectIn&lt;Key>AtIndex:withObject:</code> or <code>-replace&lt;Key>AtIndexes:with&lt;Key>:</code> are called when an object is replaced in a collection, rather than doing a remove and then insert.</p><p><span class="content_text">Listing 8</span> shows sample implementations of <code>-replaceObjectIn&lt;Key>AtIndex:withObject:</code> and <code>-replace&lt;Key>AtIndexes:with&lt;Key>:</code> implementations for the to-many <code>employee</code> property.</p><a name="//apple_ref/doc/uid/20002174-SW13" title="Listing 9Example -replaceObjectIn&amp;lt;Key&gt;AtIndex:withObject: and -replace&amp;lt;Key&gt;AtIndexes:with&amp;lt;Key&gt;: accessors"></a><p class="codesample"><strong>Listing 9&nbsp;&nbsp;</strong>Example <code>-replaceObjectIn&lt;Key>AtIndex:withObject:</code> and <code>-replace&lt;Key>AtIndexes:with&lt;Key>:</code> accessors</p><div class="codesample"><table><tr><td scope="row"><pre>- (void)replaceObjectInEmployeesAtIndex:(NSUInteger)idx<span></span></pre></td></tr><tr><td scope="row"><pre>                             withObject:(id)anObject<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    [employees replaceObjectAtIndex:index withObject:anObject];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>- (void)replaceEmployeesAtIndexes:(NSIndexSet *)indexes<span></span></pre></td></tr><tr><td scope="row"><pre>                    withEmployees:(NSArray *)employeeArray<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    [employees replaceObjectsAtIndexes:indexes<span></span></pre></td></tr><tr><td scope="row"><pre>                           withObjects:employeeArray];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/20002174-SW5" title="Unordered Accessor Pattern"></a><h3>Unordered Accessor Pattern</h3><p>The unordered accessor methods provide a mechanism for accessing and mutating objects in an unordered relationship. Typically this relationship is an instance of <code>NSSet</code> or <code>NSMutableSet</code>. However, by implementing these accessors, any class can by used to model the relationship and be manipulated using key-value coding just as if it was an instance of <code>NSSet</code>.</p><a name="//apple_ref/doc/uid/20002174-SW14" title="Getter Unordered Accessors"></a><h4>Getter Unordered Accessors</h4><p>The getter variations of the unordered accessor methods provide simple access to the relationship data. The methods return the number of objects in the collection, an enumerator to iterate over the collection objects, and a method to compare an object with the contents of the collection to see if it is already present.</p><div class="notebox"><a name="//apple_ref/doc/uid/20002174-SW15" title="Note"></a><p><strong>Note:</strong>&nbsp;Itâ€™s rare to have to implement the getter variations of the unordered accessors. To-many unordered relationships are most often modeled using instance of NSSet or a subclass. In that case the key-value coding will, if it doesnâ€™t find these accessor patterns for the property, directly access the set. Typically, you only implement these methods if you are using a custom collection class that needs to be accessed as if it was a set.  </p></div><p>In order to support read-only access to an unordered to-many relationship you would implement the following methods:</p><ul class="spaceabove"><li class="li"><p><code>-countOf&lt;Key></code>. Required. This method corresponds to the <code>NSSet</code> method <code><a href="../../../Reference/Foundation/Classes/NSSet_Class/Reference/Reference.html#//apple_ref/occ/instm/NSSet/count" target="_top">count</a></code>.</p></li><li class="li"><p><code>-enumeratorOf&lt;Key></code>. Required. Corresponds to the <code>NSSet</code> method <code><a href="../../../Reference/Foundation/Classes/NSSet_Class/Reference/Reference.html#//apple_ref/occ/instm/NSSet/objectEnumerator" target="_top">objectEnumerator</a></code>.</p></li><li class="li"><p><code>-memberOf&lt;Key>:</code>. Required. This method is the equivalent of the <code>NSet</code> method <code><a href="../../../Reference/Foundation/Classes/NSSet_Class/Reference/Reference.html#//apple_ref/occ/instm/NSSet/member:" target="_top">member:</a></code></p></li></ul><p><span class="content_text"><a href="AccessorConventions.html#//apple_ref/doc/uid/20002174-SW3">Listing 10</a></span> shows simple implementations of the necessary getter accessors that simply pass the responsibilities to the <code>transactions</code> property.</p><a name="//apple_ref/doc/uid/20002174-SW3" title="Listing 10Example -countOf&amp;lt;Key&gt;, -enumeratorOf&amp;lt;Key&gt;, and -memberOf&amp;lt;Key&gt;: accessors"></a><p class="codesample"><strong>Listing 10&nbsp;&nbsp;</strong>Example <code>-countOf&lt;Key></code>, <code>-enumeratorOf&lt;Key></code>, and <code>-memberOf&lt;Key>:</code> accessors</p><div class="codesample"><table><tr><td scope="row"><pre>- (NSUInteger)countOfTransactions<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    return [transactions count];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>- (NSEnumerator *)enumeratorOfTransactions<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    return [transactions objectEnumerator];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>- (Transaction *)memberOfTransactions:(Transaction *)anObject<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    return [transactions member:anObject];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>The <code>-countOf&lt;Key></code> accessor implementation should simply return the number of items in the relationship. The <code>-enumeratorOf&lt;Key></code> method implementation must return an <code>NSEnumerator</code> instance that is used to iterate over the items in the relationship. See <span class="content_text"><a href="../../Collections/Articles/Enumerators.html#//apple_ref/doc/uid/20000135" target="_top">Enumerators: Traversing a CollectionÃ¢Â€Â™s Elements</a></span> in <em><a href="../../Collections/index.html#//apple_ref/doc/uid/10000034i" target="_top">Collections Programming Topics for Cocoa</a></em> for more information about enumerators. </p><p>The <code>-memberOf&lt;Key>:</code> accessor must compare the object passed as a parameter with the contents of the collection and returns the matching object as a result, or <code>nil</code> if no matching object is found. Your implementation of this method may use <code>isEqual:</code> to compare the objects, or may compare objects in another manner. The object returned may be a different object than that tested for membership, but it should be the equivalent as far as content is concerned. </p><a name="//apple_ref/doc/uid/20002174-SW16" title="Mutable Unordered Accessors"></a><h4>Mutable Unordered Accessors</h4><p>Supporting a mutable to-many relationship with indexed accessors requires implementing additional methods. Implementing the mutable indexed accessors for your application to interact with the indexed collection in an easy and efficient manner through the use of the array proxy returned by <code>mutableArrayValueForKey:</code>. In addition, by implementing these methods for a to-many relationship your class will be key-value observing compliant for that property (see <em><a href="../../KeyValueObserving/index.html#//apple_ref/doc/uid/10000177i" target="_top">Key-Value Observing Programming Guide</a></em>).</p><div class="notebox"><a name="//apple_ref/doc/uid/20002174-SW17" title="Note"></a><p><strong>Note:</strong>&nbsp;You are strongly advised to implement these mutable accessors rather than relying on a accessor that returns a mutable array directly. The mutable accessors are much more efficient when making changes to the data in the relationship. </p></div><p>In order to be key-value coding complaint for a mutable unordered to-many relationship you must implement the following methods:</p><ul class="spaceabove"><li class="li"><p><code>-add&lt;Key>Object:</code> or <code>-add&lt;Key>:</code>. At least one of these methods must be implemented. These are analogous to the <code>NSMutableSet</code> method <code><a href="../../../Reference/Foundation/Classes/NSMutableSet_Class/Reference/NSMutableSet.html#//apple_ref/occ/instm/NSMutableSet/addObject:" target="_top">addObject:</a></code>.</p></li><li class="li"><p><code>-remove&lt;Key>Object:</code> or <code>-remove&lt;Key>:</code>. At least one of these methods must be implemented. These are analogous to the <code>NSMutableSet</code> method <code><a href="../../../Reference/Foundation/Classes/NSMutableSet_Class/Reference/NSMutableSet.html#//apple_ref/occ/instm/NSMutableSet/removeObject:" target="_top">removeObject:</a></code>.</p></li><li class="li"><p><code>-intersect&lt;Key>:</code>. Optional. Implement if benchmarking indicates that performance is an issue. It performs the equivalent action of the NSSet method <code><a href="../../../Reference/Foundation/Classes/NSMutableSet_Class/Reference/NSMutableSet.html#//apple_ref/occ/instm/NSMutableSet/intersectSet:" target="_top">intersectSet:</a></code>.</p></li></ul><p>The <code>-add&lt;Key>Object:</code> and <code>-add&lt;Key>:</code> implementations add a single item or a set of items to the relationship. You only required to implement one of the methods. When adding a set of items to the relationship you should ensure that an object that an equivalent object is not already present in the relationship. <span class="content_text"><a href="AccessorConventions.html#//apple_ref/doc/uid/20002174-SW7">Listing 11</a></span> shows an example pass-through implementation for the <code>transactions</code> property.</p><a name="//apple_ref/doc/uid/20002174-SW7" title="Listing 11Example -add&amp;lt;Key&gt;Object: and -add&amp;lt;Key&gt;: accessors"></a><p class="codesample"><strong>Listing 11&nbsp;&nbsp;</strong>Example <code>-add&lt;Key>Object:</code> and <code>-add&lt;Key>:</code> accessors</p><div class="codesample"><table><tr><td scope="row"><pre>- (void)addTransactionsObject:(Transaction *)anObject<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    [transactions addObject:anObject];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>- (void)addTransactions:(NSSet *)manyObjects<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    [transactions unionSet:manyObjects];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>Similarly, the <code>-remove&lt;Key>Object:</code> and <code>-remove&lt;Key>:</code> implementations remove a single item or a set of items from the relationship. Again, implementation of only one of the methods is required. <span class="content_text"><a href="AccessorConventions.html#//apple_ref/doc/uid/20002174-SW8">Listing 12</a></span> shows an example pass-through implementation for the <code>transactions</code> property.</p><a name="//apple_ref/doc/uid/20002174-SW8" title="Listing 12Example -remove&amp;lt;Key&gt;Object: and -remove&amp;lt;Key&gt;: accessors"></a><p class="codesample"><strong>Listing 12&nbsp;&nbsp;</strong>Example <code>-remove&lt;Key>Object:</code> and <code>-remove&lt;Key>:</code> accessors</p><div class="codesample"><table><tr><td scope="row"><pre>- (void)removeTransactionsObject:(Transaction *)anObject<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    [transactions removeObject:anObject];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>- (void)removeTransactions:(NSSet *)manyObjects<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    [transactions minusSet:manyObjects];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>If benchmarking indicates that performance improvements are required, you can also implement the <code>-intersect&lt;Key>:</code> or <code>-set&lt;Key>:</code> methods. </p><p>The implementation of <code>-intersect&lt;Key>:</code> should remove from the relationship all the objects that arenâ€™t common to both sets. This is the equivalent of the <code>NSMutableSet</code> method <code><a href="../../../Reference/Foundation/Classes/NSMutableSet_Class/Reference/NSMutableSet.html#//apple_ref/occ/instm/NSMutableSet/intersectSet:" target="_top">intersectSet:</a></code>.</p><a name="//apple_ref/doc/uid/20002174-SW18" title="Listing 13Example -intersect&amp;lt;Key&gt;: and -set&amp;lt;Key&gt;: implementations"></a><p class="codesample"><strong>Listing 13&nbsp;&nbsp;</strong>Example <code>-intersect&lt;Key>:</code> and <code>-set&lt;Key>:</code> implementations</p><div class="codesample"><table><tr><td scope="row"><pre>- (void)intersectTransactions:(NSSet *)otherObjects<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    return [transactions intersectSet:otherObjects];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div>

        <br/><br/> 

        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="BasicPrinciples.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="Validation.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2003, 2009 Apple Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2009-02-04<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Cocoa/Conceptual/KeyValueCoding/Concepts/AccessorConventions.html%3Fid%3D10000107i-6.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Cocoa/Conceptual/KeyValueCoding/Concepts/AccessorConventions.html%3Fid%3D10000107i-6.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Cocoa/Conceptual/KeyValueCoding/Concepts/AccessorConventions.html%3Fid%3D10000107i-6.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>
