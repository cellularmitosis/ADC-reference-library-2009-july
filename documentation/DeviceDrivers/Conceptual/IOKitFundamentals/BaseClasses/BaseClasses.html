<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>I/O Kit Fundamentals: The Base Classes</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="The Base Classes"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP0000016" title="The Base Classes"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../../HardwareDrivers/index.html#//apple_ref/doc/uid/TP30000440-TP40003576" target="_top">Hardware &amp; Drivers</a> &gt; <a href="../Introduction/Introduction.html#//apple_ref/doc/uid/TP0000011-CH204-TPXREF101">I/O Kit Fundamentals</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../Matching/Matching.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../Families/Families.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        
        <a name="//apple_ref/doc/uid/TP0000016-BAJJFCHJ" title="The Base Classes"></a><h1>The Base Classes</h1><p>The I/O Kit is an object-oriented framework consisting primarily of dozens, if not hundreds, of C++ classes. These classes can be organized by virtue of their inheritance relationships in a class hierarchy. As with all class hierarchies, the I/O Kit’s can be depicted as an inverted tree, with childless nodes—classes without any subclasses—as the leaves of the tree. Carrying the analogy further, the classes at the trunk and, especially, the root of the tree are those that most classes of the hierarchy inherit from. These are the base classes. </p><p><span class="content_text"><a href="BaseClasses.html#//apple_ref/doc/uid/TP0000016-BAJCJBCF">Figure 5-1</a></span> shows the general outline of the I/O Kit’s class hierarchy and the positions of the base classes within this <a name="//apple_ref/doc/uid/TP0000016-DontLinkElementID_187"></a>hierarchy.</p><br/><div><a name="//apple_ref/doc/uid/TP0000016-BAJCJBCF" title="Figure 5-1The base classes of the I/O Kit class hierarchy"></a><p><strong>Figure 5-1&nbsp;&nbsp;</strong>The base classes of the I/O Kit class hierarchy</p><img src = "../art/class_diagram.gif" alt = "The base classes of the I/O Kit class hierarchy" width="428" height="394"></div><br/><p>As the diagram illustrates, the base classes specific to the I/O Kit are <a name="//apple_ref/doc/uid/TP0000016-DontLinkElementID_188"></a>IOService and <a name="//apple_ref/doc/uid/TP0000016-DontLinkElementID_189"></a>IORegistryEntry; also included as base classes—through inheritance—are the <a name="//apple_ref/doc/uid/TP0000016-DontLinkElementID_190"></a>libkern library’s <a name="//apple_ref/doc/uid/TP0000016-DontLinkElementID_191"></a>OSObject and (in a special sense) <a name="//apple_ref/doc/uid/TP0000016-DontLinkElementID_192"></a>OSMetaClass. </p><p>Given the centrality of these classes, it is apparent how important it is to understand them. They provide not just the behavior and data structures that all other classes of the I/O Kit inherit. They define the <em>structure</em> of behavior for kernel and driver objects: how objects are created and disposed of, how metaclass information is captured and revealed, how driver objects should behave within a dynamic runtime environment, and how the client/provider relationships among driver objects are dynamically established. If you’re writing device drivers using the I/O Kit, you’re going to have to deal with the base classes in your code early on and frequently thereafter, so it’s a good idea to become familiar with them.</p><p>This chapter also gives an overview of some generally useful functions and data types. Even though these functions and types do not properly belong in a discussion of base classes (since they are not affiliated with any class), their utility in a variety of circumstances makes them almost as central as any of the base classes.<a name="//apple_ref/doc/uid/TP0000016-DontLinkElementID_193"></a></p>
<!-- This template is being used for both PDF and HTML. -->

    
    <h4>In this section:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="BaseClasses.html#//apple_ref/doc/uid/TP0000016-BAJEGGFI">The libkern Base Classes</a>
				
			<br/>
			
        
			
			
				<a href="BaseClasses.html#//apple_ref/doc/uid/TP0000016-BAJEEGAF">The I/O Kit Base Classes</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/TP0000016-BAJEGGFI" title="The libkern Base Classes"></a><h2>The libkern Base Classes</h2><a name="//apple_ref/doc/uid/TP0000016-DontLinkElementID_194"></a><p>The I/O Kit is built on top of the <a name="//apple_ref/doc/uid/TP0000016-DontLinkElementID_195"></a>libkern C++ library, which is written in a subset of <a name="//apple_ref/doc/uid/TP0000016-DontLinkElementID_196"></a>C++ suitable for use in loadable <a name="//apple_ref/doc/uid/TP0000016-DontLinkElementID_197"></a>kernel modules. Specifically, the libkern C++ environment does not support <a name="//apple_ref/doc/uid/TP0000016-DontLinkElementID_198"></a>multiple inheritance, <a name="//apple_ref/doc/uid/TP0000016-DontLinkElementID_199"></a>templates, the C++ <a name="//apple_ref/doc/uid/TP0000016-DontLinkElementID_200"></a>exception-handling facility, and runtime type information (RTTI)<a name="//apple_ref/doc/uid/TP0000016-DontLinkElementID_201"></a><a name="//apple_ref/doc/uid/TP0000016-DontLinkElementID_202"></a>. The C++ RTTI facility is omitted because it doesn’t support dynamic allocation of classes by name, a feature required for loading kernel extensions. RTTI also makes considerable use of exceptions. However, the libkern C++ environment defines its own runtime typing system, which does support dynamic loading.</p><p>Exceptions are forbidden in the kernel for reasons of both cost and stability. They increase the size of the code, thereby consuming precious kernel memory, and introduce unpredictable latencies. Further, because I/O Kit code may be invoked by many client threads, there’s no way to guarantee that an exception will be caught. Using <code>try</code>, <code>throw</code>, or <code>catch</code> in any kernel extension is not supported and will result in a compilation error. Although you can’t use exceptions in an I/O Kit driver, your driver should always check return codes where appropriate.</p><p>Apple highly recommends that you base all kernel C++ code, including that for device drivers, on the libkern base classes, OSObject and OSMetaClass, and observe the conventions prescribed by those classes (see <span class="content_text"><a href="BaseClasses.html#//apple_ref/doc/uid/TP0000016-TPXREF104">“Type Casting, Object Introspection, and Class Information”</a></span>). Classes that are completely private to your driver need not be based on OSObject and need not follow these conventions. Such classes, however, will be limited in their interaction with libkern classes. For example, all libkern collection classes store objects that inherit from OSObject. Custom classes that don’t inherit from OSObject can’t be stored in libkern collections such as OSDictionary or OSArray objects.</p><div class="importantbox"><a name="//apple_ref/doc/uid/TP0000016-DontLinkElementID_11" title="Important:"></a><p><strong>Important:</strong>&nbsp;At present, the loader does not allow the use of any OSObject subclass that requires qualification, such as a <a name="//apple_ref/doc/uid/TP0000016-DontLinkElementID_203"></a>nested class or a class declared within a namespace (for an example of a namespace declaration, see <span class="content_text"><a href="../Features/Features.html#//apple_ref/doc/uid/TP0000012-TPXREF105">“Language Choice”</a></span>). For example, the following nested class declaration in an I/O Kit driver would prevent the driver from loading:</p><p><div class="codesample"><table><tr><td scope="row"><pre>class com.mycompany.driver.myClass {<span></span></pre></td></tr><tr><td scope="row"><pre>    class myNestedClass : public IOService {}; // This is not allowed.<span></span></pre></td></tr><tr><td scope="row"><pre>};<span></span></pre></td></tr></table></div></p></div><a name="//apple_ref/doc/uid/TP0000016-BAJJBDHB" title="Object Creation and Disposal (OSObject)"></a><h3>Object Creation and Disposal (OSObject)</h3><p>OSObject is at the root of the extended I/O Kit hierarchy. It inherits from no (public) superclass, and all other libkern and I/O Kit classes (except for OSMetaClass) inherit from it. <a name="//apple_ref/doc/uid/TP0000016-DontLinkElementID_204"></a>OSObject implements the dynamic typing and allocation features needed to support loadable kernel modules. Its virtual functions and overridden operators define how objects are created, retained, and disposed of in the kernel. OSObject is an abstract base class, and therefore cannot itself be instantiated or copied.</p><a name="//apple_ref/doc/uid/TP0000016-TPXREF101" title="Object Construction"></a><h4>Object Construction</h4><p>The standard C++ constructors cannot be used in libkern because these <a name="//apple_ref/doc/uid/TP0000016-DontLinkElementID_205"></a><a name="//apple_ref/doc/uid/TP0000016-DontLinkElementID_206"></a>constructors use exceptions to report failures; as you may recall, the restricted form of C++ chosen for libkern excludes exceptions. So the main purpose of the OSObject class (and also of the OSMetaClass class) is to reimplement object construction.</p><p>For constructing objects, OSObject defines the <code><!--a-->init<!--/a--></code><a name="//apple_ref/doc/uid/TP0000016-DontLinkElementID_207"></a><a name="//apple_ref/doc/uid/TP0000016-DontLinkElementID_208"></a>function and overrides the <code>new</code> operator. The <code>new</code> operator allocates memory for an object and sets the object’s reference count to one. After it uses the <code>new</code> operator, the client must call the <code>init</code> function on the new object to perform all initializations required to make it a usable object. If the <code><!--a-->init<!--/a--></code> call fails, then the client must immediately release the object. </p><p>In support of OSObject’s <code><!--a-->init<!--/a--></code> and <code>new</code>, the <a name="//apple_ref/doc/uid/TP0000016-DontLinkElementID_209"></a>OSMetaClass class implements macros related to object construction. These macros bind a class into the kernel’s runtime typing facility and automatically define functions that act as the constructor and destructor for the class. See <span class="content_text"><a href="BaseClasses.html#//apple_ref/doc/uid/TP0000016-CJBFJECG">“Runtime Type Information (OSMetaClass)”</a></span> for more information on these macros and OSMetaClass’s implementation of RTTI.</p><p>Subclasses of OSObject do not explicitly implement their constructors and <a name="//apple_ref/doc/uid/TP0000016-DontLinkElementID_210"></a>destructors since these are essentially created through the OSMetaClass macros. Moreover, you typically invoke neither constructor and destructor functions, nor the C++ <code>new</code> and <code><!--a-->delete<!--/a--></code><a name="//apple_ref/doc/uid/TP0000016-DontLinkElementID_211"></a><a name="//apple_ref/doc/uid/TP0000016-DontLinkElementID_212"></a>operators. These functions and operators are reserved for use by the dynamic typing and allocation facilities, which implicitly define them for a class. In their place, OSObject defines a convention for creating and initializing objects. Subclasses do, however, typically override the <code><!--a-->init<!--/a--></code> function to perform initializations specific to the class.</p><p>Most libkern and I/O Kit classes define one or more static functions for creating instances. The naming convention varies from class to class, but the name is usually either the base name of the class itself (with a lowercase first letter), or some form of <code><!--a-->with...<!--/a--></code> where the name describes the initialization arguments. For example, OSArray defines the static creation functions <code><!--a-->withCapacity<!--/a--></code>, <code><!--a-->withObjects<!--/a--></code>, and <code><!--a-->withArray<!--/a--></code>; IOTimerEventSource defines <code><!--a-->timerEventSource<!--/a--></code>; and IOMemoryCursor defines <code><!--a-->withSpecification<!--/a--></code>. If a class doesn’t have static creation functions, you must use <code><!--a-->new<!--/a--></code> and then invoke the initialization method that takes the place of the C++ constructor, as shown in <span class="content_text"><a href="BaseClasses.html#//apple_ref/doc/uid/TP0000016-CCDHACJB">Listing 5-2</a></span></p><p>For an overview of the boilerplate code you need to specify your class’s constructor and destructor functions, see <span class="content_text"><a href="BaseClasses.html#//apple_ref/doc/uid/TP0000016-TPXREF104">“Type Casting, Object Introspection, and Class Information”</a></span> </p><a name="//apple_ref/doc/uid/TP0000016-TPXREF102" title="Object Retention and Disposal "></a><h4>Object Retention and Disposal </h4><a name="//apple_ref/doc/uid/TP0000016-DontLinkElementID_213"></a><a name="//apple_ref/doc/uid/TP0000016-DontLinkElementID_214"></a><p>OSObject defines a <a name="//apple_ref/doc/uid/TP0000016-DontLinkElementID_215"></a>reference-counting and automatic-deallocation mechanism to support the safe unloading of kernel extensions. For this mechanism it uses three virtual member <a name="//apple_ref/doc/uid/TP0000016-DontLinkElementID_216"></a><a name="//apple_ref/doc/uid/TP0000016-DontLinkElementID_217"></a><a name="//apple_ref/doc/uid/TP0000016-DontLinkElementID_218"></a>functions—<code><!--a-->retain<!--/a--></code>, <code><!--a-->release<!--/a--></code>, and <code><!--a-->free<!--/a--></code>—and overrides the <code>delete</code><a name="//apple_ref/doc/uid/TP0000016-DontLinkElementID_219"></a>operator. Of these, the only functions you should call in your code are <code><!--a-->retain<!--/a--></code> and <code><!--a-->release<!--/a--></code>, and you should follow certain conventions that dictate when to call them.</p><p>Newly created objects and copied objects have a reference count of one. If you have created or copied a libkern object and have no need to keep it beyond the current context, you should call <code><!--a-->release<!--/a--></code> on it. This decrements the object’s reference count. If that count is zero, the object is deallocated; specifically, the <code>release</code> method invokes the alternative destructor, named <code><!--a-->free<!--/a--></code>, and finally invokes the <code>delete</code> operator. If you don’t own an object—that is, you did not create or copy it—and you want to keep it past the current context, call <code><!--a-->retain<!--/a--></code> on it to increment its reference count. If you did not create, copy, or call <code><!--a-->retain<!--/a--></code> on an object, you should never call <code><!--a-->release<!--/a--></code> on it.</p><p>In addition, some functions that return objects pass ownership to the caller, meaning the caller must release the object when it is finished with it, while others don’t. See the reference documentation for a given function to find out if your code needs to retain or release an object it receives.</p><p>Never invoke the <code>delete</code> operator explicitly to free an object. Also, never call <code><!--a-->free<!--/a--></code> directly to free an object; however, you may (and should, in most circumstances) override the <code><!--a-->free<!--/a--></code> function to deallocate memory allocated in your <code><!--a-->init<!--/a--></code> function.<a name="//apple_ref/doc/uid/TP0000016-DontLinkElementID_220"></a></p><a name="//apple_ref/doc/uid/TP0000016-CJBFJECG" title="Runtime Type Information (OSMetaClass)"></a><h3>Runtime Type Information (OSMetaClass)</h3><p>Although libkern’s restricted form of C++ excludes the native runtime type information <a name="//apple_ref/doc/uid/TP0000016-DontLinkElementID_221"></a>(RTTI) facility, <a name="//apple_ref/doc/uid/TP0000016-DontLinkElementID_222"></a>OSMetaClass implements an alternative <a name="//apple_ref/doc/uid/TP0000016-DontLinkElementID_223"></a>runtime typing facility that does support dynamic allocation of classes by name. OSMetaClass is not a base class in the true sense; no public libkern or I/O Kit class inherits from it. However, OSMetaClass provides APIs and functionality that are essential for object construction and destruction. OSMetaClass itself is an abstract class and cannot be directly constructed.</p><p>The functionality that OSMetaClass offers all libkern-based code includes the following:</p><ul class="spaceabove"><li class="li"><p>A mechanism for tracking the class hierarchy dynamically</p></li><li class="li"><p>Safe loading and unloading of <a name="//apple_ref/doc/uid/TP0000016-DontLinkElementID_224"></a>kernel modules</p><p>The runtime typing facility enables the system to track how many instances of each libkern (and I/O Kit) class are currently extant and to assign each of these instances to a kernel module (KMOD). </p></li><li class="li"><p>Automatic construction and deconstruction of class instances</p></li><li class="li"><p>Macros and functions for dynamic type casting, type discovery, membership evaluation, and similar introspective behavior</p></li><li class="li"><p>Dynamic allocation of libkern class instances based on some indication of their class type, including C-string names</p></li></ul><p>In libkern’s runtime typing facility, one static metaclass instance (derivative of OSMetaClass) is created for every class in a kernel module (KMOD) loaded into the kernel. The instance encapsulates information on the class’s name, size, superclass, kernel module, and the current count of instances of that class. The process of loading a kernel module takes place in two phases, the first initiated by the <code><!--a-->preModLoad<!--/a--></code> member function and the second by the <code><!--a-->postModLoad<!--/a--></code> function. During the <code><!--a-->preModLoad<!--/a--></code> phase, OSMetaClass statically constructs, within the context of a single, lock-protected thread, a metaclass instance for each class in the module. In the <code><!--a-->postModLoad<!--/a--></code> phase, OSMetaClass links together the inheritance hierarchy of constructed metaclass objects, inserts the metaclass instances into the global register of classes, and records for each instance the kernel module it derived from. See the OSMetaClass reference documentation for more on <code><!--a-->preModLoad<!--/a--></code>, <code><!--a-->postModLoad<!--/a--></code>, and related functions.</p><p>The created store of metaclass information forms the basis for the capabilities of OSMetaClass listed above. The following sections explore the more important of these capabilities in some detail.</p><a name="//apple_ref/doc/uid/TP0000016-TPXREF103" title="Object Construction and Dynamic Allocation"></a><h4>Object Construction and Dynamic Allocation</h4><a name="//apple_ref/doc/uid/TP0000016-DontLinkElementID_225"></a><a name="//apple_ref/doc/uid/TP0000016-DontLinkElementID_226"></a><a name="//apple_ref/doc/uid/TP0000016-DontLinkElementID_227"></a><p>One of the features of OSMetaClass is its ability to allocate libkern objects based upon some indication of class type. Subclasses of OSMetaClass can do this dynamically by implementing the <code><!--a-->alloc<!--/a--></code><a name="//apple_ref/doc/uid/TP0000016-DontLinkElementID_228"></a>function; the class type is supplied by the OSMetaClass subclass itself. You can also allocate an instance of any libkern class by calling one of the <code><!--a-->allocClassWithName<!--/a--></code><a name="//apple_ref/doc/uid/TP0000016-DontLinkElementID_229"></a>functions, supplying an appropriate identification of class type (OSSymbol, OSString, or C string). </p><p>Freshly allocated objects have a retain count of 1 as their sole instance variable and are otherwise uninitialized. After allocation, the client should immediately invoke the object’s initialization function (which is <code><!--a-->init<!--/a--></code> or some variant of <code><!--a-->init<!--/a--></code>). </p><p>OSMetaClass defines a number of runtime type-declaration <a name="//apple_ref/doc/uid/TP0000016-DontLinkElementID_230"></a><a name="//apple_ref/doc/uid/TP0000016-DontLinkElementID_231"></a>macros and object-construction macros based on the <code><!--a-->alloc<!--/a--></code> function. Based on the type of class (virtual or otherwise), you must insert one of these macros as the first statement in class declarations and implementations:</p><dl class="termdef">	<dt><code><!--a-->OSDeclareDefaultStructors<!--/a--></code><a name="//apple_ref/doc/uid/TP0000016-DontLinkElementID_232"></a></dt><dd><p>Declares the data and interfaces of a class, which are needed as <a name="//apple_ref/doc/uid/TP0000016-DontLinkElementID_233"></a>runtime type information. By convention this macro should immediately follow the opening brace in a class declaration.</p></dd><dt><code><!--a-->OSDeclareAbstractStructors<!--/a--></code><a name="//apple_ref/doc/uid/TP0000016-DontLinkElementID_234"></a></dt><dd><p>Declares the data and interfaces of a virtual class, which are needed as runtime type information. By convention this macro should immediately follow the opening brace in a class declaration. Use this macro when the class has one or more pure virtual methods.</p></dd><dt><code><!--a-->OSDefineMetaClassAndStructors<!--/a--></code><a name="//apple_ref/doc/uid/TP0000016-DontLinkElementID_235"></a></dt><dd><p>Defines an OSMetaClass subclass and the primary constructors and destructors for a non-abstract subclass of OSObject. This macro should appear at the top of the implementation file just before the first function is implemented for a particular class. </p></dd><dt><code><!--a-->OSDefineMetaClassAndAbstractStructors<!--/a--></code><a name="//apple_ref/doc/uid/TP0000016-DontLinkElementID_236"></a></dt><dd><p>Defines an OSMetaClass subclass and the primary constructors and destructors for a subclass of OSObject that is an abstract class. This macro should appear at the top of the implementation file just before the first function is implemented for a particular class.</p></dd><dt><code><!--a-->OSDefineMetaClassAndStructorsWithInit<!--/a--></code><a name="//apple_ref/doc/uid/TP0000016-DontLinkElementID_237"></a></dt><dd><p>Defines an OSMetaClass subclass and the primary constructors and destructors for a non-abstract subclass of OSObject. This macro should appear at the top of the implementation file just before the first function is implemented for a particular class. The specified initialization routine is called once the OSMetaClass instance has been constructed at load time.</p></dd><dt><code><!--a-->OSDefineMetaClassAndAbstractStructorsWithInit<!--/a--></code><a name="//apple_ref/doc/uid/TP0000016-DontLinkElementID_238"></a></dt><dd><p>Defines an OSMetaClass subclass and the primary constructors and destructors for a subclass of OSObject that is an abstract class. This macro should appear at the top of the implementation file just before the first function is implemented for a particular class. The specified initialization routine is called once the OSMetaClass instance has been constructed at load time<a name="//apple_ref/doc/uid/TP0000016-DontLinkElementID_239"></a>.</p></dd></dl><p>See <span class="content_text"><a href="BaseClasses.html#//apple_ref/doc/uid/TP0000016-TPXREF104">“Type Casting, Object Introspection, and Class Information”</a></span> for more information on using these macros, including examples of usage.</p><a name="//apple_ref/doc/uid/TP0000016-TPXREF104" title="Type Casting, Object Introspection, and Class Information"></a><h4>Type Casting, Object Introspection, and Class Information</h4><a name="//apple_ref/doc/uid/TP0000016-DontLinkElementID_240"></a><a name="//apple_ref/doc/uid/TP0000016-DontLinkElementID_241"></a><a name="//apple_ref/doc/uid/TP0000016-DontLinkElementID_242"></a><a name="//apple_ref/doc/uid/TP0000016-DontLinkElementID_243"></a><a name="//apple_ref/doc/uid/TP0000016-DontLinkElementID_244"></a><a name="//apple_ref/doc/uid/TP0000016-DontLinkElementID_245"></a><p>OSMetaClass defines many macros and functions that you can use in almost any situation. They help you safely cast from one type to another, discover an arbitrary object’s class, determine if an object inherits from a given superclass, find out how many instances of a given class are still allocated, and yield other useful <a name="//apple_ref/doc/uid/TP0000016-DontLinkElementID_246"></a>information. <span class="content_text"><a href="BaseClasses.html#//apple_ref/doc/uid/TP0000016-CJBGACGB">Table 5-1</a></span> summarizes these macros and functions.</p><a name="//apple_ref/doc/uid/TP0000016-DontLinkElementID_247"></a><a name="//apple_ref/doc/uid/TP0000016-CJBGACGB" title="Table 5-1OSMetaClass type-casting and introspection APIs "></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table 5-1&nbsp;&nbsp;</strong>OSMetaClass type-casting and introspection APIs </caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Function or macro</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Description</p></th></tr><tr><td  scope="row"><p><code><!--a-->OSTypeID<!--/a--></code><a name="//apple_ref/doc/uid/TP0000016-DontLinkElementID_248"></a></p></td><td ><p>This macro returns the type ID of a class based on its name.</p></td></tr><tr><td  scope="row"><p><code><!--a-->OSTypeIDInst<!--/a--></code><a name="//apple_ref/doc/uid/TP0000016-DontLinkElementID_249"></a></p></td><td ><p>This macro returns the type ID of the class a given instance is constructed from.</p></td></tr><tr><td  scope="row"><p><code><!--a-->OSCheckTypeInst<!--/a--></code><a name="//apple_ref/doc/uid/TP0000016-DontLinkElementID_250"></a></p></td><td ><p>This macro checks if one instance is of the same class type as another instance.</p></td></tr><tr><td  scope="row"><p><code><!--a-->OSDynamicCast<!--/a--></code><a name="//apple_ref/doc/uid/TP0000016-DontLinkElementID_251"></a></p></td><td ><p>This macro dynamically casts the class type of an instance to a suitable class. It is basically equivalent to RTTI’s <code><!--a-->dynamic_cast<!--/a--></code>.</p></td></tr><tr><td  scope="row"><p><a name="//apple_ref/doc/uid/TP0000016-DontLinkElementID_252"></a><code><!--a-->isEqualTo<!--/a--></code></p></td><td ><p>This function verifies if the invoking OSMetaClass instance (which represents a class) is the same as another OSMetaClass instance. The default implementation performs a shallow pointer comparison.</p></td></tr><tr><td  scope="row"><p><code><!--a-->metaCast<!--/a--></code><a name="//apple_ref/doc/uid/TP0000016-DontLinkElementID_253"></a> (multiple)</p></td><td ><p>This set of functions determines if an OSMetaClass instance (which represents a class) is, or inherits from, a given class type. The type can be specified as OSMetaClass, OSSymbol, OSString, or a C string.</p></td></tr><tr><td  scope="row"><p><code><!--a-->modHasInstance<!--/a--></code><a name="//apple_ref/doc/uid/TP0000016-DontLinkElementID_254"></a></p></td><td ><p>Returns whether a kernel module has any outstanding instances. This function is usually called to determine if a module can be unloaded.</p></td></tr><tr><td  scope="row"><p><code><!--a-->getInstanceCount<!--/a--></code><a name="//apple_ref/doc/uid/TP0000016-DontLinkElementID_255"></a></p></td><td ><p>This function returns the number of instances of the class represented by the receiver.</p></td></tr><tr><td  scope="row"><p><code><!--a-->getSuperClass<!--/a--></code><a name="//apple_ref/doc/uid/TP0000016-DontLinkElementID_256"></a></p></td><td ><p>This function returns the receiver’s superclass.</p></td></tr><tr><td  scope="row"><p><code><!--a-->getClassName<!--/a--></code><a name="//apple_ref/doc/uid/TP0000016-DontLinkElementID_257"></a></p></td><td ><p>This function returns the name (as a C string) of the receiver.</p></td></tr><tr><td  scope="row"><p><code><!--a-->getClassSize<!--/a--></code><a name="//apple_ref/doc/uid/TP0000016-DontLinkElementID_258"></a></p></td><td ><p>This function returns the size (in bytes) of the class represented by the receiver.</p></td></tr></table></div><a name="//apple_ref/doc/uid/TP0000016-DontLinkElementID_1" title="Defining C++ Classes in libkern"></a><h3>Defining C++ Classes in libkern</h3><p>When implementing a C++ class based on OSObject, you invoke a pair of <a name="//apple_ref/doc/uid/TP0000016-DontLinkElementID_259"></a>macros based upon the OSMetaClass class. These macros tie your class into the libkern <a name="//apple_ref/doc/uid/TP0000016-DontLinkElementID_260"></a><a name="//apple_ref/doc/uid/TP0000016-DontLinkElementID_261"></a>runtime typing facility by defining a metaclass and by defining the <a name="//apple_ref/doc/uid/TP0000016-DontLinkElementID_262"></a>constructor and <a name="//apple_ref/doc/uid/TP0000016-DontLinkElementID_263"></a>destructor for your class that perform RTTI bookkeeping tasks through the metaclass.</p><p>The first <a name="//apple_ref/doc/uid/TP0000016-DontLinkElementID_264"></a>macro, <code><!--a-->OSDeclareDefaultStructors<!--/a--></code> declares the C++ constructors; by convention you insert this macro as the first element of the class declaration in the header file. For example:</p><div class="codesample"><table><tr><td scope="row"><pre>class MyDriver : public IOEthernetController<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    OSDeclareDefaultStructors(MyDriver);<span></span></pre></td></tr><tr><td scope="row"><pre>    /* ... */<span></span></pre></td></tr><tr><td scope="row"><pre>};<span></span></pre></td></tr></table></div><p>Your class implementation then uses the companion <a name="//apple_ref/doc/uid/TP0000016-DontLinkElementID_265"></a>macro, <code>OSDefineMetaClassAndStructors</code>, to define the constructor and <a name="//apple_ref/doc/uid/TP0000016-DontLinkElementID_266"></a>destructor, as well as the metaclass that provides the runtime typing information. <code>OSDefineMetaClassAndStructors</code> takes as arguments the name of your driver and the name of its superclass. It uses these to generate code that allows your driver class to be loaded and instantiated while the kernel is running. For example, <code>MyDriver.cpp</code> might begin like this:</p><div class="codesample"><table><tr><td scope="row"><pre>#include "MyDriver.h"<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>// This convention makes it easy to invoke superclass methods.<span></span></pre></td></tr><tr><td scope="row"><pre>#define super    IOEthernetController<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>// You cannot use the "super" macro here, however, with the<span></span></pre></td></tr><tr><td scope="row"><pre>//  OSDefineMetaClassAndStructors macro.<span></span></pre></td></tr><tr><td scope="row"><pre>OSDefineMetaClassAndStructors(MyDriver, IOEthernetController);<span></span></pre></td></tr></table></div><p>The definition of the <code>super</code><a name="//apple_ref/doc/uid/TP0000016-DontLinkElementID_267"></a>macro allows convenient access to superclass methods without having to type the whole name of the superclass every time. This is a common idiom of libkern and I/O Kit class implementations.</p><p>In place of the C++ constructor and destructor, your class implements an <a name="//apple_ref/doc/uid/TP0000016-DontLinkElementID_268"></a><a name="//apple_ref/doc/uid/TP0000016-DontLinkElementID_269"></a>initialization method and a <code><!--a-->free<!--/a--></code><a name="//apple_ref/doc/uid/TP0000016-DontLinkElementID_270"></a>method. For non–I/O Kit classes, the initialization method takes whatever arguments are needed, can have any name (although it usually begins with <code>init</code>), and returns a C++ <code>bool</code> value. The <code><!--a-->free<!--/a--></code> method always takes no arguments and returns <code>void</code>.</p><p>The initialization method for your driver class should invoke the appropriate superclass initialization method before doing anything else, as shown in <span class="content_text"><a href="BaseClasses.html#//apple_ref/doc/uid/TP0000016-CCDIFICJ">Listing 5-1</a></span> If the superclass returns <code>false</code>, your class’s initialization method should abort, release any allocated resources, and return <code>false</code>. Otherwise your class can perform its initialization and return <code>true</code>. When the libkern C++ runtime system creates an instance of a class, it zero-fills all of the member variables, so you don’t need to explicitly initialize anything to zero, false, or null values. </p><a name="//apple_ref/doc/uid/TP0000016-CCDIFICJ" title="Listing 5-1Implementing an init method"></a><p class="codesample"><strong>Listing 5-1&nbsp;&nbsp;</strong>Implementing an init method</p><div class="codesample"><table><tr><td scope="row"><pre>bool MyDriver::init(IOPhysicalAddress * paddr)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    if (!super::init()) {<span></span></pre></td></tr><tr><td scope="row"><pre>        // Perform any required clean-up, then return.<span></span></pre></td></tr><tr><td scope="row"><pre>        return false;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    physAddress = paddr;  // Set an instance variable.<span></span></pre></td></tr><tr><td scope="row"><pre>    return true;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>To create an instance using the initialization method, you write code such as this:</p><a name="//apple_ref/doc/uid/TP0000016-CCDHACJB" title="Listing 5-2Creating an instance and calling its init method"></a><p class="codesample"><strong>Listing 5-2&nbsp;&nbsp;</strong>Creating an instance and calling its init method</p><div class="codesample"><table><tr><td scope="row"><pre>MyDriver * pDrv = new MyDriver; // This invokes the predefined constructor<span></span></pre></td></tr><tr><td scope="row"><pre>                                //  of MyDriver itself<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>if (!pDrv) {<span></span></pre></td></tr><tr><td scope="row"><pre>    // Deal with error.<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>if (!pDrv->init(memAddress)) {<span></span></pre></td></tr><tr><td scope="row"><pre>    // Deal with error.<span></span></pre></td></tr><tr><td scope="row"><pre>    pDrv->release();    // Dispose of the driver object.<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>Because this makes creating instances more cumbersome, you may want to write a convenience method in the manner of many of the kernel C++ classes, as for example:</p><div class="codesample"><table><tr><td scope="row"><pre>MyDriver * MyDriver::withAddress(IOPhysicalAddress *paddr)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    MyDriver * pDrv = new MyDriver;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if (pDrv &amp;&amp; !pDrv->init(paddr)) {<span></span></pre></td></tr><tr><td scope="row"><pre>        pDrv->release();<span></span></pre></td></tr><tr><td scope="row"><pre>        return 0;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    return pDrv;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>Using this convenience method, you can create an instance of your driver with code like the following:</p><div class="codesample"><table><tr><td scope="row"><pre>MyDriver * pDrv = MyDriver::withAddress(paddr);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>if (!pDrv) {<span></span></pre></td></tr><tr><td scope="row"><pre>    // Deal with error of not being able to create driver object.<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre>else {<span></span></pre></td></tr><tr><td scope="row"><pre>    // Go on after successful creation of driver object.<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>A class’s <code><!--a-->free<!--/a--></code> method should release any resources held by the instance and then invoke the superclass’s <code><!--a-->free<!--/a--></code> method, as in <span class="content_text"><a href="BaseClasses.html#//apple_ref/doc/uid/TP0000016-CCDFBAIH">Listing 5-3</a></span>:</p><a name="//apple_ref/doc/uid/TP0000016-CCDFBAIH" title="Listing 5-3Implementing the free function"></a><p class="codesample"><strong>Listing 5-3&nbsp;&nbsp;</strong>Implementing the free function</p><div class="codesample"><table><tr><td scope="row"><pre>void MyDriver::free(void)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    deviceRegisterMap->release();<span></span></pre></td></tr><tr><td scope="row"><pre>    super::free();<span></span></pre></td></tr><tr><td scope="row"><pre>    return;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>Again, note that your code should never invoke <code><!--a-->free<!--/a--></code> or the <code>delete</code> operator directly with objects based on the OSObject class. Always call <code><!--a-->release<!--/a--></code> on such objects to dispose of them.<a name="//apple_ref/doc/uid/TP0000016-DontLinkElementID_271"></a><a name="//apple_ref/doc/uid/TP0000016-DontLinkElementID_272"></a></p><a name="//apple_ref/doc/uid/TP0000016-BAJEEGAF" title="The I/O Kit Base Classes"></a><h2>The I/O Kit Base Classes</h2><a name="//apple_ref/doc/uid/TP0000016-DontLinkElementID_273"></a><p>All driver objects based on the I/O Kit inherit from the two base classes <a name="//apple_ref/doc/uid/TP0000016-DontLinkElementID_274"></a>IORegistryEntry and <a name="//apple_ref/doc/uid/TP0000016-DontLinkElementID_275"></a>IOService. The second of these classes, IOService, directly inherits from IORegistryEntry and all driver objects ultimately inherit from IOService. The IORegistryEntry class defines a driver object as a node in the I/O Registry, and IOService defines the life cycle of a driver object as well as implementing other behavior common to drivers.</p><p>The close inheritance relationship between IORegistryEntry and IOService might invite speculation as to why these classes weren’t designed as one class. The reason is performance. Having IORegistryEntry as a superclass of IOService is an optimization because, in terms of memory footprint, the IORegistryEntry object is much more lightweight.</p><a name="//apple_ref/doc/uid/TP0000016-BAJJHBFH" title="Dynamic Driver Registration (IORegistryEntry)"></a><h3>Dynamic Driver Registration (IORegistryEntry)</h3><a name="//apple_ref/doc/uid/TP0000016-DontLinkElementID_276"></a><p>An IORegistryEntry object defines a node (or entry) in the I/O Registry. As the chapter <span class="content_text"><a href="../TheRegistry/TheRegistry.html#//apple_ref/doc/uid/TP0000014-TP9">“The I/O Registry”</a></span> explains in detail, the I/O Registry is a dynamic database that captures the current graph of “live” driver objects, tracking the client/provider relationships among these objects and recording the properties that describe their personalities. The I/O Registry plays an essential role in the dynamic features of Mac OS X; when users add or remove hardware, the system uses the Registry in the driver-matching process and immediately updates it to reflect the new configuration of devices.</p><p>Each IORegistryEntry object has two dictionaries (that is, instances of OSDictionary) associated with it. One is the property table for the object, which is typically also a driver object. This property table is the <a name="//apple_ref/doc/uid/TP0000016-DontLinkElementID_277"></a>matching dictionary that specifies one of the driver’s personalities. (See <span class="content_text"><a href="../Matching/Matching.html#//apple_ref/doc/uid/TP0000015-BAJEICBG">“Driver Personalities and Matching Languages”</a></span> for information on personalities.) The other dictionary of an IORegistryEntry object is the plane dictionary, which specifies how the object is connected to other objects in the registry.</p><p>In addition to reflecting all client/provider relationships among driver objects, the I/O Registry identifies subsets of these relationships. Both the totality of the Registry tree and the subsets of it are called <strong>planes</strong>. Each <a name="//apple_ref/doc/uid/TP0000016-DontLinkElementID_278"></a>plane expresses a different provider/client relationship between objects in the I/O Registry by showing only those connections that exist in that relationship. Often the plane relationship is one of a dependency chain. The most general plane is the Service plane which displays the total hierarchy of registry entries. Every object in the Registry is a client of the services provided by its parent, so every object’s connection to its ancestor in the Registry tree is visible on the Service plane. In addition to the Service plane, there are the Power, Audio, Device, FireWire, and USB planes. For more information on planes, see <span class="content_text"><a href="../TheRegistry/TheRegistry.html#//apple_ref/doc/uid/TP0000014-CGGFIFEC">“I/O Registry Architecture and Construction”</a></span></p><p>It is possible to have an IORegistryEntry object that is not also an IOService object. Such an object could be used purely for holding information associated with that node in the Registry. However, there is little actual need for such objects.</p><p>The <a name="//apple_ref/doc/uid/TP0000016-DontLinkElementID_279"></a>IORegistryEntry class includes many member functions that driver objects might find useful; these functions fall into several categories:</p><ul class="spaceabove"><li class="li"><p>Property-table functions allow you to set, get, and remove properties of an IORegistryEntry object’s property table as well as serializing property tables. Some <code><!--a-->getProperty<!--/a--></code><a name="//apple_ref/doc/uid/TP0000016-DontLinkElementID_280"></a>functions perform a synchronized, recursive search through the Registry for the property of a given key.</p></li><li class="li"><p><a name="//apple_ref/doc/uid/TP0000016-DontLinkElementID_281"></a>Positional functions let an IORegistryEntry object manipulate its position in the Registry tree. It can locate, identify, and attach to or detach from another IORegistryEntry object.</p></li><li class="li"><p><a name="//apple_ref/doc/uid/TP0000016-DontLinkElementID_282"></a>Iteration functions enable your code to traverse the entire Registry tree, or a portion or it, and optionally invoke an “applier” callback function on IORegistryEntry objects encountered.</p></li></ul><p>See the reference documentation for IORegistryEntry for details.<a name="//apple_ref/doc/uid/TP0000016-DontLinkElementID_283"></a></p><a name="//apple_ref/doc/uid/TP0000016-TPXREF105" title="Basic Driver Behavior (IOService)"></a><h3>Basic Driver Behavior (IOService)</h3><p>Every driver object in the I/O Kit is an instance of a class that ultimately inherits from the <a name="//apple_ref/doc/uid/TP0000016-DontLinkElementID_284"></a>IOService class. IOService most importantly defines, through complementary pairs of virtual functions, a driver’s <a name="//apple_ref/doc/uid/TP0000016-DontLinkElementID_285"></a>life cycle within a dynamic runtime environment. It manages the <a name="//apple_ref/doc/uid/TP0000016-DontLinkElementID_286"></a>matching and <a name="//apple_ref/doc/uid/TP0000016-DontLinkElementID_287"></a><a name="//apple_ref/doc/uid/TP0000016-DontLinkElementID_288"></a>probing process, implements default matching behavior, and registers drivers and other services. But the IOService class also provides a wealth of functionality for many other purposes, including:</p><ul class="spaceabove"><li class="li"><p>Accessing a driver’s provider, clients, state, and work loop</p></li><li class="li"><p>Posting <a name="//apple_ref/doc/uid/TP0000016-DontLinkElementID_289"></a>notifications and sending messages to other driver objects or services</p></li><li class="li"><p>Managing power in devices</p></li><li class="li"><p>Implementing user clients (device interfaces)</p></li><li class="li"><p>Accessing device memory</p></li><li class="li"><p>Registering and controlling interrupt handlers</p></li></ul><p>This section first describes the life cycle of a driver object and IOService’s role in that life cycle. Then it summarizes each of the other major IOService APIs.</p><a name="//apple_ref/doc/uid/TP0000016-CCDGAAJB" title="Driver Object Life Cycle"></a><h4>Driver Object Life Cycle</h4><a name="//apple_ref/doc/uid/TP0000016-DontLinkElementID_290"></a><p>An I/O Kit driver can be loaded and unloaded, or activated and deactivated, at any time. Every driver’s life cycle follows the same pattern, as laid out in a set of functions defined by the standard driver superclass, IOService. Some of these functions must be implemented by the driver; others are implemented by IOService, but can be overridden by the driver for additional flexibility.</p><br/><div><a name="//apple_ref/doc/uid/TP0000016-CGJCGGJD" title="Figure 5-2Driver object life-cycle functions"></a><p><strong>Figure 5-2&nbsp;&nbsp;</strong>Driver object life-cycle functions</p><a name="//apple_ref/doc/uid/TP0000016-DontLinkElementID_291"></a><img src = "../art/driverlifecycle.gif" alt = "Driver object life-cycle functions" width="138" height="215"></div><br/><p><span class="content_text"><a href="BaseClasses.html#//apple_ref/doc/uid/TP0000016-CGJCGGJD">Figure 5-2</a></span> shows the sequence of functions that gets invoked during the life of a driver object. The bracketing lines show how these functions are grouped into complementary pairs. A driver object class can <a name="//apple_ref/doc/uid/TP0000016-DontLinkElementID_292"></a>override any of these functions, but must be sure to invoke the superclass’s implementation of that same function at the appropriate point in its own implementation. For example, when you override the opening function of a complementary pair, such as <code><!--a-->init<!--/a--></code> or <code><!--a-->start<!--/a--></code>, your version must invoke the corresponding function of its superclass before doing its own initialization, as shown in <span class="content_text"><a href="BaseClasses.html#//apple_ref/doc/uid/TP0000016-CCDIFICJ">Listing 5-1</a></span> When you override a closing function, such as <code><!--a-->free<!--/a--></code> or <code><!--a-->stop<!--/a--></code>, you should perform your own cleanup before invoking the corresponding function in the superclass, as shown in <span class="content_text"><a href="BaseClasses.html#//apple_ref/doc/uid/TP0000016-CCDFBAIH">Listing 5-3</a></span></p><a name="//apple_ref/doc/uid/TP0000016-TPXREF111" title="Driver Matching and Loading"></a><h5>Driver Matching and Loading</h5><a name="//apple_ref/doc/uid/TP0000016-DontLinkElementID_293"></a><p>The first group of <a name="//apple_ref/doc/uid/TP0000016-DontLinkElementID_294"></a><a name="//apple_ref/doc/uid/TP0000016-DontLinkElementID_295"></a><a name="//apple_ref/doc/uid/TP0000016-DontLinkElementID_296"></a><a name="//apple_ref/doc/uid/TP0000016-DontLinkElementID_297"></a>functions—<code><!--a-->init<!--/a--></code>, <code><!--a-->attach<!--/a--></code>, <code><!--a-->probe<!--/a--></code>, and <code><!--a-->detach<!--/a--></code>—is invoked during the process of driver matching and <a name="//apple_ref/doc/uid/TP0000016-DontLinkElementID_298"></a>loading. This process occurs at boot time and at any time devices are added or removed. The following paragraphs summarize the matching process, paying special attention to the functions involved; see <span class="content_text"><a href="../Matching/Matching.html#//apple_ref/doc/uid/TP0000015-TPXREF109">“Driver Matching and Loading”</a></span> for an extended discussion of the process.</p><p>The matching process is kicked off when a service provider detects a device. Usually this provider is the controller driver for a bus (such as a PCI bus), which detects the device by scanning its bus. The provider (usually through its family) then creates and <a name="//apple_ref/doc/uid/TP0000016-DontLinkElementID_299"></a>registers any required nubs by calling the IOService <a name="//apple_ref/doc/uid/TP0000016-DontLinkElementID_300"></a>function, <code><!--a-->registerService<!--/a--></code>; this call, in turn, triggers the matching process.</p><p>As orchestrated by IOService, the I/O Kit finds and loads a driver for a nub in three distinct phases, using a subtractive process. In each phase, drivers that are <em>not</em> considered to be likely candidates for a match are subtracted from the total pool of possible candidates until a successful candidate is found. The phases are:</p><ol class="ol"><li class="li"><p><strong>Class matching</strong>—the I/O Kit eliminates any drivers of the wrong provider (nub) class.<a name="//apple_ref/doc/uid/TP0000016-DontLinkElementID_301"></a></p></li><li class="li"><p><strong>Passive matching</strong>—the I/O Kit examines the remaining drivers’ personalities for family-specific properties<a name="//apple_ref/doc/uid/TP0000016-DontLinkElementID_302"></a>. </p></li><li class="li"><p><strong>Active matching</strong>—IOService calls each of the remaining drivers’ <code><!--a-->probe<!--/a--></code> functions with reference to the object the driver is being matched against. This function allows the driver to communicate with the device and verify that it can in fact drive that device. A probe score is returned that reflects how well suited the driver is to drive the device.<a name="//apple_ref/doc/uid/TP0000016-DontLinkElementID_303"></a></p></li></ol><p>When a matching driver is found, its code is loaded and an instance of the principal class listed in the personality is created. </p><p>In the first two phases, none of the driver’s life-cycle functions is called. It is only during the third stage of active matching, when the driver is asked to <a name="//apple_ref/doc/uid/TP0000016-DontLinkElementID_304"></a><a name="//apple_ref/doc/uid/TP0000016-DontLinkElementID_305"></a>probe a device for suitability, that the first group of functions is invoked.</p><p>Whether a driver is loaded to drive a device or is merely asked to probe it, the first life-cycle function invoked is <code><!--a-->init<!--/a--></code>, which is the libkern equivalent of the constructor function for the class. For I/O Kit drivers, this function takes as its sole argument an OSDictionary containing the matching properties from the personality in the XML file. The driver can use this to determine what specific personality it’s been loaded for, determine the level of diagnostic output to produce, or otherwise establish basic operating parameters. However, I/O Kit drivers typically don’t override the <code><!--a-->init<!--/a--></code> function, performing their initialization in later stages, as described below. For more on <code><!--a-->init<!--/a--></code>, and the related <code><!--a-->free<!--/a--></code> function, see <span class="content_text"><a href="BaseClasses.html#//apple_ref/doc/uid/TP0000016-BAJJBDHB">“Object Creation and Disposal (OSObject)”</a></span></p><p>Before a driver object can either probe or start, it must be attached into the I/O Registry. To do this, the nub invokes the driver’s <code><!--a-->attach<!--/a--></code> function, which attaches the driver to the nub through the I/O Registry. The complementary function <code><!--a-->detach<!--/a--></code> removes the driver from its nub. IOService gives both of these functions default implementations. A driver can override them, but rarely needs to do so.</p><p>If active matching is occurring, the nub next invokes the driver object's probe function. The probe function returns an IOService. This is usually the driver object itself, but the driver can return an instance of a different class, such as a specialized subclass included in the driver's kernel extension bundle. IOService's default implementation of probe simply returns the this pointer without altering the probe score. Overriding probe is optional; most drivers get enough information from property matching and don't need to override it. If you do override probe, however, you must make sure that the probe is not destructive, leaving the device in the state it found it. Hardware specifications generally define how to conduct non-destructive probes.</p><p>A driver’s <code><!--a-->start<!--/a--></code><a name="//apple_ref/doc/uid/TP0000016-DontLinkElementID_306"></a>function, just as with implementations of <code><!--a-->probe<!--/a--></code>, should perform only the minimum necessary allocation of system resources to verify that it can operate the hardware. This conservative approach delays consumption of kernel resources until they’re actually needed.<a name="//apple_ref/doc/uid/TP0000016-DontLinkElementID_307"></a><a name="//apple_ref/doc/uid/TP0000016-DontLinkElementID_308"></a><a name="//apple_ref/doc/uid/TP0000016-DontLinkElementID_309"></a></p><p>Each family, such as PCI, USB, or storage, defines a pair of activation and deactivation functions to indicate that the driver should prepare to service I/O requests and that the driver’s services are no longer needed. These two <a name="//apple_ref/doc/uid/TP0000016-DontLinkElementID_310"></a><a name="//apple_ref/doc/uid/TP0000016-DontLinkElementID_311"></a>functions are typically named <code><!--a-->open<!--/a--></code> and <code><!--a-->close<!--/a--></code>. Most drivers implement these functions to allocate and deallocate all of the necessary buffers and other structures in preparation for I/O processing.</p><p>Some families define additional levels of activation and deactivation. A networking driver, for example, does very little in <code><!--a-->open<!--/a--></code> and <code><!--a-->close<!--/a--></code>, instead performing setup and teardown in the <code><!--a-->enable<!--/a--></code> and <code><!--a-->disable<!--/a--></code> functions. Whatever the specific activation and deactivation functions, they can be invoked many times during a driver’s life span; a driver should be able to function no matter how many times it gets activated or deactivated.<a name="//apple_ref/doc/uid/TP0000016-DontLinkElementID_312"></a><a name="//apple_ref/doc/uid/TP0000016-DontLinkElementID_313"></a></p><a name="//apple_ref/doc/uid/TP0000016-TPXREF112" title="Driver Status Change"></a><h5>Driver Status Change</h5><p>Another function that can be invoked many times during a driver’s life span is the <code><!--a-->message<!--/a--></code><a name="//apple_ref/doc/uid/TP0000016-DontLinkElementID_314"></a>function. This function informs the driver of important system status changes, such as when a disk is forcibly removed, when a power management change (sleep, wake-up) is occurring, or when the driver is being shut down. IOService’s implementation of this function does nothing and returns an “unsupported” result code. For more on the notification and messaging functionality provided by IOService, see <span class="content_text"><a href="BaseClasses.html#//apple_ref/doc/uid/TP0000016-BAJJGEDF">“Notification and Messaging”</a></span> </p><a name="//apple_ref/doc/uid/TP0000016-TPXREF113" title="Driver Shutdown"></a><h5>Driver Shutdown</h5><a name="//apple_ref/doc/uid/TP0000016-DontLinkElementID_315"></a><p>When a driver is going to be permanently shut down, its <code><!--a-->message<!--/a--></code> function is invoked with a terminate <a name="//apple_ref/doc/uid/TP0000016-DontLinkElementID_316"></a>message (<code>kIOMessageServiceIsTerminated</code>). If the driver accepts the termination, its <code><!--a-->stop<!--/a--></code> function is then invoked. The driver should implement its <code><!--a-->stop<!--/a--></code><a name="//apple_ref/doc/uid/TP0000016-DontLinkElementID_317"></a>function to close, release, or free any resources it opened or created in its <code><!--a-->start<!--/a--></code> function, and to leave the hardware in the state the driver originally found it. Assuming the driver implements the activation and deactivation functions, there is usually little to do in the <code><!--a-->stop<!--/a--></code> function. The final stage of driver shutdown is invocation of <code><!--a-->free<!--/a--></code>, <a name="//apple_ref/doc/uid/TP0000016-DontLinkElementID_318"></a>which occurs when the driver object’s reference count reaches zero. In this function the driver can dispose of any resources it created in its <code><!--a-->init<!--/a--></code> function.<a name="//apple_ref/doc/uid/TP0000016-DontLinkElementID_319"></a></p><a name="//apple_ref/doc/uid/TP0000016-TPXREF106" title="Provider Matching"></a><h4>Provider Matching</h4><p>If you are implementing a <a name="//apple_ref/doc/uid/TP0000016-DontLinkElementID_320"></a>provider driver object (that is, a subclass that is a member of an I/O Kit family) you may want to override IOService’s <code><!--a-->matchPropertyTable<!--/a--></code> member <a name="//apple_ref/doc/uid/TP0000016-DontLinkElementID_321"></a>function. When IOService performs matching for a driver object, it calls this method so the provider class can implement its own specific matching criteria in addition to the generic ones provided by IOService. The provider should examine the matching dictionary passed to see if it contains properties the family understands for matching and use them to match with the specific driver object if it does understand them.</p><a name="//apple_ref/doc/uid/TP0000016-BAJJGEDF" title="Notification and Messaging"></a><h4>Notification and Messaging</h4><p>IOService provides two mechanisms for driver objects to communicate with each other and with the I/O Kit: <a name="//apple_ref/doc/uid/TP0000016-DontLinkElementID_322"></a>notifications and <a name="//apple_ref/doc/uid/TP0000016-DontLinkElementID_323"></a>messaging. Notifications are delivered to interested clients when a certain event occurs with an active service or driver that has properties matching a given dictionary. Messages are more targeted and flow in one direction, from provider to client. Any provider can send a message to any of its clients to notify it of some change in the runtime environment. </p><p>As discussed earlier in <span class="content_text"><a href="BaseClasses.html#//apple_ref/doc/uid/TP0000016-CCDGAAJB">“Driver Object Life Cycle”</a></span> driver clients implement the <code><!--a-->message<!--/a--></code><a name="//apple_ref/doc/uid/TP0000016-DontLinkElementID_324"></a>function to receive and respond to messages from their providers. This function allows them to adapt to changes in the runtime environment. The messages can inform them of changes in system status, such as changes in power state, suspension of service, or impending service terminations. Providers implement the <code><!--a-->messageClient<!--/a--></code><a name="//apple_ref/doc/uid/TP0000016-DontLinkElementID_325"></a>(or <code><!--a-->messageClients<!--/a--></code>) functions to send messages by invoking their client’s <code><!--a-->message<!--/a--></code> methods. The I/O Kit defines some messages while others may be defined by families. See the header file <code>Kernel.framework/Headers/IOKit/IOMessage.h</code> for the generic messages that the <code><!--a-->messageClient<!--/a--></code> and <code><!--a-->messageClients<!--/a--></code> functions can deliver to a driver.</p><p>The broadcasting of notifications is a bit more complicated. Any driver object can install a notification handler through the <code><!--a-->addNotification<!--/a--></code> or <code><!--a-->installNotification<!--/a--></code> functions. The notification handler is set up to be invoked when a specific driver object (identified by a dictionary of matching properties) experiences a specific type of state change, such as when a driver is first published, matched at any time, or is terminated. Each notification handler is also given a priority number in case multiple notifications of the same type and for the same object are triggered at the same time.</p><p>The <a name="//apple_ref/doc/uid/TP0000016-DontLinkElementID_326"></a><a name="//apple_ref/doc/uid/TP0000016-DontLinkElementID_327"></a>notification handler (of type <code>IOServiceNotificationHandler</code>) is invoked if any driver object whose personality matches the supplied matching dictionary changes to the specified state. For example, when a service provider calls <code><!--a-->registerServices<!--/a--></code>, that not only starts the registration process but it also delivers notifications to all registered clients interested in the publication of the provider. The notification request is identified by an instance of an IONotifier object, through which the notification can be enabled, disabled, or removed.</p><a name="//apple_ref/doc/uid/TP0000016-TPXREF107" title="Driver Accessors"></a><h4>Driver Accessors</h4><p>IOService includes, as a convenience, a number of <a name="//apple_ref/doc/uid/TP0000016-DontLinkElementID_328"></a><a name="//apple_ref/doc/uid/TP0000016-DontLinkElementID_329"></a>accessor member functions giving quick access to a driver object’s state and the objects that are closely related to it. These functions return the following objects or values:</p><ul class="spaceabove"><li class="li"><p>The driver’s state (<code><!--a-->getState<!--/a--></code>), a bitfield indicating whether the driver is inactive, registered, matched, and so on</p></li><li class="li"><p>The work loop being used by the driver (<code><!--a-->getWorkLoop<!--/a--></code>) (see <span class="content_text"><a href="../HandlingEvents/HandlingEvents.html#//apple_ref/doc/uid/TP0000018-BAJFFJAD">“Handling Events”</a></span>) for further information)</p></li><li class="li"><p>The driver’s primary provider (<code><!--a-->getProvider<!--/a--></code>), as well as an <a name="//apple_ref/doc/uid/TP0000016-DontLinkElementID_330"></a>OSIterator object for iterating over the driver’s providers, if multiple (for example, a RAID device)</p></li><li class="li"><p>The driver’s primary client (<code><!--a-->getClient<!--/a--></code>), as well as an OSIterator object for iterating over the driver’s clients, if multiple</p></li></ul><a name="//apple_ref/doc/uid/TP0000016-TPXREF109" title="Other IOService Features"></a><h4>Other IOService Features</h4><p>IOService incorporates functionality (other than that summarized above) that is useful for many categories of device driver. Most notably, this functionality includes the following features:</p><ul class="spaceabove"><li class="li"><p><strong>User client</strong>. The <code><!--a-->newUserClient<!--/a--></code><a name="//apple_ref/doc/uid/TP0000016-DontLinkElementID_331"></a>function creates an IOUserClient-based connection for communication with a non-kernel client; the client invokes this function by calling the <code><!--a-->IOServiceOpen<!--/a--></code><a name="//apple_ref/doc/uid/TP0000016-DontLinkElementID_332"></a>function of the I/O Kit framework<a name="//apple_ref/doc/uid/TP0000016-DontLinkElementID_333"></a>.</p></li><li class="li"><p><strong>Device memory</strong>. Several IOService member functions get, map, and set the physical memory ranges allocated to a memory-mapped device. These functions are intended for driver objects that are clients of PCI devices<a name="//apple_ref/doc/uid/TP0000016-DontLinkElementID_334"></a>. </p></li><li class="li"><p><strong>Interrupt handling</strong>. IOService provides low-level functions for registering, unregistering, manipulating, and accessing interrupt handlers that are called at primary-interrupt time for a device’s interrupt. The functions provide a mechanism for installing interrupt handlers that is not based on a work loop<a name="//apple_ref/doc/uid/TP0000016-DontLinkElementID_335"></a>.<a name="//apple_ref/doc/uid/TP0000016-DontLinkElementID_336"></a><a name="//apple_ref/doc/uid/TP0000016-DontLinkElementID_337"></a></p></li></ul>

        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../Matching/Matching.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../Families/Families.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2001, 2007 Apple Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2007-05-17<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/DeviceDrivers/Conceptual/IOKitFundamentals/BaseClasses/BaseClasses.html%3Fid%3DTP0000011-4.8&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/DeviceDrivers/Conceptual/IOKitFundamentals/BaseClasses/BaseClasses.html%3Fid%3DTP0000011-4.8&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/DeviceDrivers/Conceptual/IOKitFundamentals/BaseClasses/BaseClasses.html%3Fid%3DTP0000011-4.8&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>