<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"			"http://www.w3.org/TR/REC-html40/loose.dtd"><HTML><!-- Template 01-05-01 --><HEAD><LINK REL="stylesheet" HREF="../../adcstyle.css" TYPE="text/css"><LINK REL="stylesheet" HREF="../../style.css" TYPE="text/css">   <title>Technical Note TN1144: Writing Custom Hoses for LaserWriter 8.6</title>       <meta name="keywords" content="Mac OS 8 LaserWriter 8.6 custom hose plug-ins writing DTP">    <meta name="Description" content="Technical Note TN1144: This Technical Note gives an overviewof the custom hose specification. Custom hoses add the abilityfor shared libraries to implement various communication methodsand for these libraries to be loaded dynamically based upona DTP's type. First by detailing how to identify a DTP'stype then by presenting the current list of DTP types, thisNote  demonstrates how hose plug-ins can be added to developerproducts."><meta name="categories" content="Printing"><meta name="week-posted" content="Jul 26, 1999 - Aug 6, 1999"><LINK REL="stylesheet" HREF="../../css/adcstyle.css" TYPE="text/css"><script language="JavaScript" type="text/javascript" src="../../js/adc.js"></script></HEAD><BODY BGCOLOR="#FFFFFF"><a name="//apple_ref/doc/uid/DTS10002983" title="Writing Custom Hoses for LaserWriter 8.6"></a><A NAME="top"></A><!-- begin_header_information --><!--#include virtual="/adcnavbar" --><p><a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../technicalnotes/index.html">Technical Notes</a> &gt; <a href="../../technicalnotes/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../technicalnotes/LegacyTechnologies/idxPrinting-date.html">Printing</a> &gt; </p><div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="../../referencelibrary/Printing/index.html" target="_blank">Reference Library > Printing</a></li>
	</ul>
</div>




</div></div></div><!-- end_header_information --><!-- bottom_of_header_marker_comment --><!-- top_of_titles_marker_comment --><CENTER><table width="600" cellpadding="0" cellspacing="0" border="0">
<tr><td align="left" scope="row">
<h1>
<div id="pagehead">Technical Note TN1144</div>
<div id="pageheadsub">Writing Custom Hoses for LaserWriter 8.6</div>
</h1>
</td></tr></table></CENTER><!-- bottom_of_titles_marker_comment --><CENTER><TABLE BORDER=0 CELLSPACING=1 WIDTH=600><TR><td align="left">         <!-- begin_header_box --><center><table width="600" cellpadding="0" cellspacing="0" border="0">     <tr><td width=300 valign="top" align=left scope="row">    <table border="0" width="300" cellpadding="0" cellspacing="0">			<tr>                        <td width=300 align=left> <img src="images/tnmenutop.gif" alt="" align="bottom" width=300 height=7></td>        </tr>        <tr bgcolor="#e6e6e6">   <td background="images/tnmenubody.gif" width=300 align=left>       <span id="menutitle">CONTENTS   <br>  <br>       </span>   </td>        </tr>        <tr bgcolor="#e6e6e6">   <td background="images/tnmenubody.gif" width=300 align=left>       <!-- begin_toc --><p id="menutext">           <A HREF = "#Identify">Identifying a DTP's Type</A><BR><BR>               <A HREF = "#Plugin">Adding Hose Plug-ins</A><BR><BR>                <A HREF = "#Registrations">Hose Type Registrations</A><BR><BR>            <A HREF = "#Summary">Summary</A><BR><BR>		<A HREF = "#References">References</A><BR><BR>        <A HREF = "#Downloads">Downloadables</A></p>        <!-- end_toc --></td>        </tr>        <tr>   <td width=300 align=left scope="row">       <img src="images/tnmenubottom.gif" alt="" width=300 height=16>   </td>        </tr>    </table></td>        <td width=300 valign="top" align=left>            <!-- begin_intro_text --><P id = "introtext">LaserWriter 8.6 supports printing to a variety of desktop printer types, including PAP, LPR, and IrDA. Each desktop printer can have its own method of communicating with its associated physical printer, RIP, or other post-printing processor. LaserWriter 8.6, through the invention of custom "hoses", adds the ability for shared libraries to implement various communication methods and for these libraries to be loaded dynamically based upon a DTP's type. This Technote gives an overview of the custom hose specification for developers.</p><!-- end_intro_text --><!-- begin_date --><h3>&nbsp;Updated: [Nov 2 1998]</h3><!-- end_date --></TD>             </TR>          </TABLE></center> <!-- end_header_box --><BR><BR><hr width=500 align=center><BR><BR><!-- begin_content --><A NAME="Identify"></A><h2>Identifying a DTP's Type</h2><P>Associated with each LaserWriter 8 desktop printer is a <CODE>'PAPA'</CODE> resource that identifies the DTP's type, as well as the printer's name and other associated communications parameters. The DTP type takes the form of a four-byte constant. All DTP types, with the exception of the <CODE>'PAP '</CODE> type, must be in the form <CODE>'=XXX'</CODE> (e.g. <CODE>'=Hld'</CODE> or  <CODE>'=Fil'</CODE>). This is due to how the old <CODE>'PAPA'</CODE> resource was expanded with the release of the LaserWriter 8.5.1 driver. The new DTP type signature replaces the zone string in the old 103-byte <CODE>'PAPA'</CODE> resource and maps to the appropriate tag <CODE>'TYPE'</CODE> in the <CODE>'PAPA'</CODE> resource. <A HREF = "tn1115.html">Technote 1115: The Extended 'PAPA' Resource</A> contains detailed information about the contents of the <CODE>'PAPA'</CODE> resource.</p> <h3>LaserWriter 8.6 DTP Types</h3><P>The <CODE>PrintingLib</CODE> that ships with LaserWriter 8.6 supports the following DTP types:</p><h4><code>'PAP '</code></h4><p>Communication with the printer is performed using AppleTalk's Printer Access Protocol (PAP). The printer's AppleTalk name, type, and zone are stored in the compatibility portion of the <code>'PAPA'</code> resource as described in <A HREF = "tn1115.html">Technote 1115: The Extended 'PAPA' Resource</A>.</p><h4><code>'=Hld'</code></h4><p>The hold desktop printer is unique in that there is no associated communications module for it. A hold desktop printer never converts the desktop spool file to PostScript, but instead simply queues the spool files. To print a spool file queued to a hold desktop printer, the user must move the spool file into the queue of another type of desktop printer.</p><h4><code>'=Fil'</code></h4><p>A translator desktop printer writes its PostScript, EPS, or PDF output to a file.</p><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>The ability to output PDF is dependent upon the user having Adobe's Acrobat Distiller installed.</P></TD></TR></TABLE></CENTER><BR><BR><h4><code>'=LPR'</code></h4><p>An LPR desktop printer uses the Unix LPD protocol to communicate over TCP/IP with a print server. For more information on this protocol, please see <I>RFC 1179 </I>at &lt;<A HREF = "http://ds.internic.net/ds/dspg1intdoc.html">http://ds.internic.net/ds/dspg1intdoc.html</A>&gt;.</p><h4><code>'=Cst'</code></h4><p>The custom application desktop printer writes its PostScript to disk and then launches an application to post-process the PostScript job. See <A HREF = "tn1113.html">Technote 1113: Customizing the Desktop Printer Utility</A> for additional information on custom DTPs.</p><h4><code>'=Ird'</code></h4><p>The PostScript job is transmitted using an infrared link to an IrDA-capable printer. LaserWriter 8 uses the IrDA specification as outlined at <A HREF = "http://www.irda.org">http://www.irda.org</A>.</p><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>Future releases of the LaserWriter 8 driver may add built-in support for USB and FireWire.</P></TD></TR></TABLE></CENTER><BR><BR><A NAME="Plugin"></A><h2>Adding Hose Plug-ins</h2><p>When printing a job to a desktop printer, LaserWriter 8.6 obtains the four-byte DTP type and then looks for a shared library containing the matching hose. LaserWriter 8.6 searches for the library in the following order:</p><ol>	<li>In the System's "Printing Plug-ins" folder (in the Extensions folder)<BR></li>	<li>In the <CODE>PrintingLib</CODE> file</li></ol><p>A desktop printer's type is obtained using the <CODE>SettingsLib</CODE> call <CODE>psGetDTPType()</CODE>, as described in <A HREF = "tn1129.html">Technote 1129: The Settings Library</A>. The Printing Plug-in Manager (as described in an upcoming Technote) is then used to find a printing plug-in of type 'hose' with a subtype matching the DTP type. </p><p>Plug-in files managed by the Printing Plug-ins Manager, such as custom hoses, are required to have a resource of type <CODE>'PLGN'</CODE> with ID -8192 that contains information about the plug-ins contained in a given file. If they do not, they cannot be used and are ignored by the LaserWriter 8.6 driver. The plug-ins are also required to have a standard <CODE>'cfrg'</CODE> resource describing the code fragments in the data fork of the file.</p><p>The <CODE>'PLGN'</CODE> resource contains information about how many shared libraries are contained in this file, and for each shared library, the type of plug-in that it is, the subtype that library handles, and the library name.</p><p>The <CODE>'PLGN'</CODE> resource is as follows:</p><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>short num;                // the number of shared libraries PluginLibInfo libInfo[num];The PluginLibInfo structure is as follows: typedef struct PluginLibInfo{  SettingsDataType type;  SettingsDataSubType subtype;  unsigned char libraryName[ ];  // pascal string                                // word aligned }PluginLibInfo;type:        the type of plug-in that is described by the PluginLibInfosubtype:     the subtype of data that can be handled by the plug-in             described by the PluginLibInfolibraryName: the library name of the code fragment in the plug-in             file described by this PluginLibInfo</pre></TD></TR></TABLE></CENTER><BR><BR><p>A ResEdit <CODE>'TMPL'</CODE> for editing the <CODE>'PLGN'</CODE> resource is provided in PrintingLib 8.6. The type field should be <CODE>'hose'</CODE> and the subtype should be <CODE>'=XXX'</CODE>, where XXX is the custom-registered type of DTP being supported. See the <A NAME="#Registrations">Hose Type Registrations</A> section for more details on registration. The <CODE>libraryName</CODE> should match the name of the code fragment in the data fork which implements the hose.</p><h3>The Hose Interface</h3><h4><code>hoseOpen</code></h4><p>Hose fragments are required to export a single entry point. This entry point, <code>hoseOpen()</code> has the following signature:</p><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>OSStatus hoseOpen(HoseInfo *hoseInfo, const BufCallbacks *callbacks, Collectionhints, Handle papaH);</pre></TD></TR></TABLE></CENTER><BR><BR><p>The hoseOpen routine's primary job is to fill out the structure pointed to by hoseInfo.</p><p>The HoseInfo structure is filled out by a <CODE>hoseOpen</CODE> procedure. The structure describes the buffer requirements of the hose as well as the function pointers for reading, writing, and closing the hose.</p> <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>typedef struct{ HoseOutProc out;        // Called to write a buffer. HoseInProc in;          // Called to read a buffer. HoseIdleProc idle;      // Called periodically. HoseCloseProc close;    // Called to shut down the connection. HoseConnProc connState; // This procedure returns the state of the                         // current connection. HoseStatusProc status;  // Return the hose's current status string. HoseDisposeProc dispose;// The hose should free up all of its memory. Size bufSize;           // The size of each allocated data buffer. long minBufs;           // The hose requires this many buffers. If                         // there isn't enough memory to allocate them,                         // the client will return memFullErr. long maxBufs;           // We'll never allocate more buffers than this. void *refcon;           // A pointer that will be passed to the hose                         // routines.}HoseInfo;</pre></TD></TR></TABLE></CENTER><BR><BR><p>First, the hose needs to fill in the <CODE>out</CODE>, <CODE>in</CODE>, <CODE>idle</CODE>, <CODE>close</CODE>, <CODE>connState</CODE>, <CODE>status</CODE>, and <CODE>dispose</CODE> fields with native function pointers to routines in the hose that implement the hose's functionality (i.e., the PPC code provides PPC function pointers while the 68KCFM code provides 68KCFM function pointers. No classic 68K function pointers are supported). In addition to filling in the hose's function pointers, the hose must fill in the <CODE>bufSize</CODE>, <CODE>minBufs</CODE>, and <CODE>maxBufs</CODE> fields to describe the hose's buffer requirements. Lastly, the hose needs to fill in the <CODE>refcon</CODE> field with a pointer to its own storage.</p><p>Before calling the hose to transmit data, the hose client provides buffering to improve performance. Because of this buffering, the hose must deal with only one transmit buffer and one receive buffer at a time. The hose client is responsible for allocating the buffers that it uses for providing the buffering. The hose indicates the size of the buffers its client should allocate by filling in the <CODE>bufSize</CODE> field during <CODE>hoseOpen</CODE>. Some typical buffer sizes include 4096 bytes for the <CODE>'PAP '</CODE> hose and 16384 bytes for the <CODE>'=Fil'</CODE> hose. The hose specifies the minimum number of buffers it needs in <CODE>minBufs</CODE>. It is recommended that the <CODE>minBufs</CODE> field be set to at least four for bidirectional hoses and to at least two for unidirectional hoses. The maximum number of buffers to be allocated is set by the hose in the <CODE>maxBufs</CODE> field. The current rule of thumb for this field is that it should not specify more than 256K worth of memory. In other words, it should be (262144 / <CODE>bufSize</CODE>). This is just a general rule of thumb; some hoses may require a larger <CODE>maxBufs</CODE> setting, while others will use a smaller number.</p><p>The callbacks parameter to <code>hoseOpen</code> is a pointer to a <CODE>BufCallbacks</CODE> structure filled in by the hose client.</p><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>typedef void (*FinishedWriteProc)(MemQElemPtr memElem, OSStatus err);typedef void (*FinishedReadProc)(MemQElemPtr memElem, OSStatus err);typedef struct{ FinishedWriteProc finishedWrite; FinishedReadProc finishedRead;}BufCallbacks;</pre></TD></TR></TABLE></CENTER><BR><BR><BR><p>The hose's client places two pointers to native functions in this structure.  These functions are to be called by the hose when a read or write is completed. For more information on these function pointers, see the detailed description of <CODE>HoseOutProc</CODE> and <CODE>HoseInProc</CODE> below. The hose should store a copy of this structure in its private data.</p><p>As part of the <code>hoseOpen</code> call, the hose is handed a Collection Manager collection containing hints for configuring the job that will be transmitted through the hose. The hints in this collection are used by the QuickDraw to PostScript converter hose client to configure the byte codes that are available for its generation of PostScript language output. In particular, the <CODE>kHintEighthBitTag</CODE> and <CODE>kHintTransparentChannelTag</CODE> hints, as defined by LaserWriter 8.6, configure the hose client as to whether it can generate its data using byte values outside the standard PostScript language printable ASCII character set. These hints are defined as follows:</p><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>/* When generating PostScript for the output stream, the PostScript converter will by default use, if needed, characters in the range 0x80-0xFF inclusive. Use the 'kHintEighthBitTag' with a value of 'false' to prevent the converter from emitting bytes with the high bit set.*/#define kHintEighthBitTag   'bit8'#define kHintEighthBitId   1#define kHintEighthBitVariableType  Boolean#define kHintEighthBitDefault  true/* When generating PostScript for the output stream, the PostScript converter will by default use, if needed, characters in the range 0x00-0x1F inclusive. Use the 'kHintTransparentChannelTag' with a value of 'false' to prevent the converter from emitting bytes less than 0x20.*/#define kHintTransparentChannelTag  'trns'#define kHintTransparentChannelId   1#define kHintTransparentChannelVariableType Boolean#define kHintTransparentChannelDefault  true</pre></TD></TR></TABLE></CENTER><BR><BR><p>Typically, the hints collection passed to <code>hoseOpen</code> does not contain the collection items corresponding to these tag/id pairs. This is equivalent to the <CODE>kHintEighthBitTag</CODE> and <CODE>kHintTransparentChannelTag</CODE> hints both set to true, i.e. bytes <CODE>0x00-0xFF</CODE> are all available. </p><p>For hoses which communicate through a channel that has attributes more restrictive than these defaults, the hose must add the appropriate collection item(s) to the hints collection to ensure that the hose client only writes bytes in the supported range. Note that only hints which are <I>more</I> restrictive than the defaults need to be added. If a hose supports full 8-bit communications, it need not add these hints to the hints collection passed in.</p><p>In some cases, the hints collection passed to <code>hoseOpen</code> already contains either or both of the <CODE>kHintEighthBitTag</CODE> and <CODE>kHintTransparentChannelTag</CODE> collection items and the collection item may be locked. If the hose client requires a more restrictive setting than that present, it <I>must</I> add the hint to the collection, regardless of whether the hint is already locked.</p><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>OSErr err; // e.g. this hose cannot transmit the high 8 bit kHintEighthBitVariableType eightBit = false; // unlock the hint if it is already there // this is OK if the hint is already unlocked err = SetCollectionItemInfo(hints, kHintEighthBitTag,    kHintEighthBitId, collectionLockMask,    0); // if the hint isn't already there that's fine if(err == collectionItemNotFoundErr)   err = noErr; if(!err){  err = AddCollectionItem(hints, kHintEighthBitTag,     kHintEighthBitId, sizeof(eightBit),    &amp;eightBit);  if(!err)   err = SetCollectionItemInfo(hints,     kHintEighthBitTag, kHintEighthBitId,    collectionLockMask, collectionLockMask); }</pre></TD></TR></TABLE></CENTER><BR><BR><BR><P>See <a href="../../documentation/macos8/Legacy/QuickDrawGX/quickdrawgx.html"><I>Inside Macintosh</I>: QuickDraw GX Environment and Utilities</a> for more information on the Collection Manager.</p><P>The last parameter to <code>hoseOpen</code>, <CODE>papa</CODE>, is the handle to an extended <code>'PAPA'</code> structure. Please see <A HREF = "tn1115.html">Technote 1115: The Extended 'PAPA' Resource</A> for a full description of this structure and <A HREF = "tn1129.html">Technote 1129: The Settings Library</a> for the <code>'PAPA'</code> accessor routines, <CODE>psPapaToCollection</CODE> and <CODE>psCollectionToPapa</CODE>. Each type of hose has different communications parameters that specify the target output device and how the communications channel is to be configured. The <code>'PAPA'</code> handle provides those communications settings for the hose and are set by the creator of the desktop printer.</p><P>In its <code>hoseOpen</code> routine, the hose should allocate any needed memory and begin opening the connection with the printer. The hose need not -- and for most connection types should not -- complete the connection in the <code>hoseOpen</code> call. Because of the lengthy connect times of most communications techniques, the opening of the printer connection should take place asynchronously. The hose starts the connection process and then returns <CODE>noErr</CODE> from <code>hoseOpen</code>. The client will periodically call the <CODE>hoseConnProc</CODE> requesting the current state of the connection. The <CODE>hoseConnProc</CODE> looks like this:</p><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>typedef enum{ kConnClosed = 0,  // Start in this state. kConnOpening,     // This is the state while we wait for the                   // printer to accept the connection. kConnOpen,        // This is the state while we do reads and                   // writes to the printer. kConnClosing      // This is the state while we wait for the                   // connection to close.}ConnState;typedef ConnState (*HoseConnProc)(void *refcon);</pre></TD></TR></TABLE></CENTER><BR><BR><P>The hose's connection procedure should return the constant <CODE>kConnOpening</CODE> while the connection is being established. Once the open completes successfully, calls to the hose's connection procedure should return <CODE>kConnOpen</CODE>. If instead an error occurs while opening the hose, the hose's connection procedure should return <CODE>kConnClosed</CODE>. At that point, the hose client will call the hose's <CODE>HoseCloseProc</CODE> and <CODE>HoseCloseProc</CODE> needs to return the appropriate error code indicating why the hose couldn't be opened.</p><h4><code>HoseOutPro</code></h4><P>The primary purpose of a hose is to transmit data. This is accomplished by the hose's client through calls to <CODE>HoseOutProc</CODE>. <CODE>HoseOutProc</CODE> looks like this:</p><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>typedef OSStatus (*HoseOutProc)(void *refcon, MemQElem *memElem);</pre></TD></TR></TABLE></CENTER><BR><BR><P>and thus the hose's function is:</p><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>OSStatus hoseOut(void *refcon, MemQElem *memElem);</pre></TD></TR></TABLE></CENTER><BR><BR><P>The <CODE>refcon</CODE> parameter passed to <CODE>HoseOutProc</CODE> is taken from the refcon field of the <CODE>HoseInfo</CODE> structure filled out by the <code>hoseOpen</code> routine. This value should be a pointer or a handle to the hose's private data.</p><P>The second parameter to <CODE>HoseOutProc</CODE>, <CODE>memElem</CODE>, is a pointer to a <CODE>MemQElem</CODE> structure describing the data to be written.</p><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>typedef struct MemQElem{ QElemPtr qLink;      // Used by Enqueue and Dequeue- private. short qType;         // Our constant (kMemQueueType) to identify our                      // queues- private. struct BufIO *bufIO; // So we can recover buffer information-                      // private. Byte *buf;           // Pointer to the allocated buffer. SInt32 maxBytes;     // The size of the block pointed to by 'buf' SInt32 nBytes;       // Number of valid bytes in 'buf'. Boolean eoj;         // true if the data is followed by an end of                      // job. Boolean inQOnly;     // This buffer should be used only for the input                      // routines- private.}MemQElem, *MemQElemPtr;</pre></TD></TR></TABLE></CENTER><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>Many of the fields of the <CODE>MemQElem</CODE> structure are private and are used by the hose client. These fields are marked private and must not be used by the hose.</P></TD></TR></TABLE></CENTER><BR><BR><P>The hose client uses the <CODE>'eoj'</CODE> field of the <CODE>MemQElem</CODE> structure to signal to the hose when it needs to transmit a PostScript end of job to the printer. If the <CODE>'eoj'</CODE> field of the <CODE>MemQElem</CODE> structure is true, a PostScript end of job indication must be sent after or along with the buffer of data (if any) in this <CODE>memElem</CODE>. For some communications channels, this <CODE>'eoj'</CODE> is a data byte sent after the data, such as control-D for serial connections. For other communications channels, such as <CODE>PAP</CODE>, the end of job indicator is out of band with the data itself.</p><P>Again, it is highly recommended that hoses perform their writes and reads in an asynchronous manner. In this case, <CODE>HoseOutProc</CODE> begins to write the <CODE>nBytes</CODE> pointed to by buf and then returns to the caller. When the write completes, the hose signals the caller by calling the finishedWrite function pointer passed in the <CODE>BufCallbacks</CODE> structure to <code>hoseOpen</code>. </p><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>typedef void (*FinishedWriteProc)(MemQElem *memElem, OSStatus err);</pre></TD></TR></TABLE></CENTER><BR><BR><P>When making the <CODE>FinishedWriteProc</CODE> call, the hose passes in the <CODE>MemQElem</CODE> pointer passed to <CODE>hoseOut</CODE> along with an error code. If the write finished successfully, the error code should be <CODE>noErr</CODE>. If there was an error in the write, pass that code to <CODE>FinishedWriteProc</CODE>.</p><P>The call to <CODE>FinishedWriteProc</CODE> is an indication from the hose to the client that the hose is done with the <CODE>MemQElem</CODE> structure and is ready for another <CODE>hoseOut</CODE> call. In fact, the routine called through the <CODE>FinishedWriteProc</CODE> may immediately make another <CODE>hoseOut</CODE> call before returning to the hose. Because of this, the hose must be prepared for the <CODE>hoseOut</CODE> routine to be invoked while still in an asynchronous completion routine. Furthermore, once the <CODE>MemQElem</CODE> pointer is passed to <CODE>FinishedWriteProc</CODE>, the hose should no longer reference it. Any data that might have been copied from the structure before calling <CODE>FinishedWriteProc</CODE> is no longer valid (particularly <CODE>'buf'</CODE>). So, not only is the structure itself no longer valid, any data contained in the structure that was previously in use is also no longer valid.</p><h4><code>HoseInProc</code></h4><P>If a hose is managing a unidirectional communications channel, the hose need not have a routine for reading data. In this case, the <code>hoseOpen</code> routine should fill in the <CODE>'in'</CODE> field of the <CODE>HoseInfo</CODE> structure with <CODE>NULL</CODE> during <code>hoseOpen</code>.</p><P>If the hose can read data from the printer, it fills the in field of the <CODE>HoseInfo</CODE> structure with a pointer to its routine that reads data.</p><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>typedef OSStatus (*HoseInProc)(void *refcon, MemQElem memElem);</pre></TD></TR></TABLE></CENTER><BR><BR><P>As with HoseOutProc, <CODE>HoseInProc</CODE> should execute asynchronously. When invoked, <CODE>HoseInProc</CODE> should start a read. When data is available and the hose's asynchronous completion routine is invoked, the hose invokes the client's <CODE>FinishedReadProc</CODE>, passing back the <CODE>MemQElem</CODE> pointer passed to <CODE>HoseInProc</CODE> and an error code. The hose cannot read more than memElem-&gt;maxBytes bytes. In addition, the hose must fill in memElem-&gt;nBytes with the number of bytes read into memElem-&gt;buf.</p><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>typedef void (*FinishedReadProc)(MemQElem memElem, OSStatus err);</pre></TD></TR></TABLE></CENTER><BR><BR><p>As with data writes, once the <CODE>FinishedReadProc</CODE> is called, the hose must be prepared for another call to <CODE>HoseInProc</CODE> before <CODE>FinishedReadProc</CODE> returns. Similar to <CODE>FinishedWriteProc</CODE>, the data in the <CODE>MemQElem</CODE> should be considered invalid after the <CODE>FinishedReadProc</CODE> is called by the hose.</p><h4><code>HoseIdleProc</code></h4><P>Not all hoses are able to use asynchronous completion routines to note the end of a read or write. To help these hoses, a <CODE>HoseIdleProc</CODE> can be specified in the <CODE>HoseInfo</CODE> structure returned from <code>hoseOpen</code>. If the idle field of the <CODE>HoseInfo</CODE> structure is not <CODE>NULL</CODE>, the hose's client will periodically call the <CODE>HoseIdleProc</CODE>. This idle procedure can check the status of pending reads and writes and call <CODE>FinishedWriteProc</CODE> and <CODE>FinishedReadProc</CODE> as needed. Most hoses do not need a <CODE>HoseIdleProc</CODE>, but, if one is needed, it has the following signature:</p><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>typedef OSStatus (*HoseIdleProc)(void *refcon);</pre></TD></TR></TABLE></CENTER><BR><BR><h4><code>HoseStatusProc</code></h4><P>While a hose is open, the hose's client may periodically request that the hose query the printer for status. When the call is made the hose should copy a Pascal string describing the printer's last known status into the buffer pointed to by <CODE>statusStr</CODE>. The hose should also start an asyncronous status request to the printer. When the asyncronous status request returns the hose must hold that status until the next call to its status procedure.</p><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>typedef OSStatus (*HoseStatusProc)(void *refcon, StringPtr statusStr);</pre></TD></TR></TABLE></CENTER><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>Make sure that the <CODE>StringPtr</CODE> always points to a valid Pascal string (i.e., leave the length byte 0 until the whole string is written so that your client does not display garbage characters if the timing is wrong).</P></TD></TR></TABLE></CENTER><BR><BR><P>For some communications channels, such as serial channels, the status from a printer is returned on the back channel read by the <CODE>HoseInProc</CODE>. In such a case, the hose's client pulls the status out of the back channel and the hose does not need to do anything other than transmit a status request to the output device.</p><h4><code>HoseCloseProc</code></h4><P>When the client is done with the hose, it calls the hose's <CODE>HoseCloseProc</CODE> to shut down the connection. The hose should terminate any pending reads and writes and begin to shut down the connection. If this shut down procedure is immediate,  it can be completed before this routine returns. If the shut down procedure takes an extended amount of time, this routine can begin the process and return.</p><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>typedef OSStatus (*HoseCloseProc)(void *refcon);</pre></TD></TR></TABLE></CENTER><BR><BR><h4><code>HoseDisposeProc</code></h4><P>After <CODE>HoseCloseProc</CODE> is invoked, the <CODE>HoseConnProc</CODE> is called repeatedly until <CODE>kConnClosed</CODE> is returned. When the hose signals that the connection has been shut down, <CODE>HoseDisposeProc</CODE> is called to allow the hose to release any memory it still holds.</p><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>typedef OSStatus (*HoseDisposeProc)(void *refcon);</pre></TD></TR></TABLE></CENTER><BR><BR><P>If there was an error during an asynchronous close, the <CODE>HoseDisposeProc</CODE> should return a non-zero error value.</p><A NAME="Registrations"></A><h2>Hose Type Registrations</h2><P>In order to ensure that we do not have conflicting hose types, we ask that you register your custom hose 4-byte type by sending an email to <A HREF = "mailto:devprograms@apple.com">devprograms@apple.com</A>. Please send the following information to register your custom hose type:</p><OL TYPE="1" START="0">    <LI>Contact Name</li>    <LI>Company Name</li>    <LI>Mailing Address</li>    <LI>Phone Number</li>    <LI>Email Address</li>    <LI>Make and Model of device</li>    <LI>Description of communications method</li>    <LI>4-byte type (in the form '=XXX')</li></OL><A NAME="Summary"></A><h2>Summary</h2><p>As outlined in this document, creating a custom hose for LaserWriter 8.6 is fairly straightforward and clean. Make sure that you are familiar with the other documents mentioned in this Technote before you begin on your journey to create a custom hose!</p><a name="References"></a><h2>References</h2><P><A HREF = "tn1113.html">Technote 1113: Customizing the Desktop Printer Utility</A></p><P><A HREF = "tn1115.html">Technote 1115: The Extended 'PAPA' Resource</A> </p><P><A HREF = "tn1129.html">Technote 1129: The Settings Library</A> </p><P><A HREF = "tn1170.html">Technote 1170: Printing Plug-ins Manager</A></p><P><a href="../../documentation/macos8/Legacy/QuickDrawGX/quickdrawgx.html"><I>Inside Macintosh</I>: QuickDraw GX Environment and Utilities</a></p><BR><P><A HREF="#top">Back to top</A></P>        <A NAME="Downloads"></A>         <h2>Downloadables</h2>        <center><TABLE BORDER=0 CELLPADDING=3 WIDTH="600">         <TR>             <td width=50 align=left>               <P ALIGN=center><img src="images/acrobatsmall.gif" align=middle alt="Acrobat" width=22 height=23></P>            </TD>            <td align="left">               <p>Acrobat version of this Note (76K).</P>            </TD>            <td width=60 align=left>               <p><A HREF="pdf/tn1144.pdf">Download</A></P>            </TD>          </TR>             </table></center><BR><BR><BR><P><A HREF="#top">Back to top</A></P></TD></TR></TABLE></CENTER><!-- end_content --><!-- begin_footer_information -->	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/technotes/tn/tn1144.html%3Fid%3DDTS10002983-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/technotes/tn/tn1144.html%3Fid%3DDTS10002983-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/technotes/tn/tn1144.html%3Fid%3DDTS10002983-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>
<!--#include virtual="/includes/footer"--><!-- end_footer_information --></BODY></HTML>