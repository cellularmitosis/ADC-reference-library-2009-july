<!-- Generated by Harlequin WebMaker 2.2.3 (23-Apr-1996)
LispWorks 3.2.2 -->
<HTML> <HEAD>
<TITLE>Handling Names Table Entry Requests(IM:N)</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING65></A>


<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->


<!-- Main Body -->

<CENTER>
<P>
<A HREF="Networking-64.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="Networking-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="Networking-304.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt= "Book Index"></A> <A HREF="Networking-66.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="Networking-2.html"><B>Networking</B></A> / <BR><DD><A HREF="Networking-61.html"><B>Chapter 3 - Name-Binding Protocol (NBP)</B></A> / <A HREF="Networking-63.html"><B>Using NBP</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING65-0></A>
<H2><A NAME=MARKER-9-42></A>Handling Names Table Entry Requests</H2>
 In addition to providing services that let you register an entity name and socket address for your process, NBP lets you look up addresses of other entities based on a name, confirm that a process whose entity name and address you already have is still registered with NBP and that the address is correct, remove your process's name and address from the names table when you no longer want to make the entity available, and cancel a pending request. You use<P>
<UL>
<LI>the <CODE>NBPSetEntity</CODE> procedure to prepare an entity name in the format required by the NBP functions
<LI>the <CODE>PLookupName</CODE> function to retrieve another entity's address based on the entity's complete NBP name, or to retrieve the addresses of multiple entities that match an NBP name that includes wildcards 
<LI>the <CODE>NBPExtract</CODE> function to read a retrieved address from the return buffer
<LI>the <CODE>PConfirmName</CODE> function to verify a name and address
<LI>the <CODE>PRemoveName</CODE> function to remove your process's name and address from the <BR>NBP names directory
<LI>the <CODE>PKillNBP</CODE> function to cancel a request to register, confirm, or look up a names table entry if the function was called asynchronously and it has not already been executed<P>
</UL>
<A NAME=HEADING65-8></A>
<H3><A NAME=MARKER-9-43></A>Preparing an Entity Name</H3>
 To prepare an <A NAME=MARKER-2-83></A>entity name using <A NAME=MARKER-2-85></A><CODE>NBPSetEntity</CODE>, you allocate a buffer that is at least <BR>99 <A NAME=MARKER-2-203></A>bytes long. You can allocate a record of type <A NAME=MARKER-2-88></A><CODE>EntityName</CODE> for this buffer. You pass <CODE>NBPSetEntity</CODE> a pointer to the buffer along with the three parts of the name (object, type, and zone), and <CODE>NBPSetEntity</CODE> writes the entity name to the buffer in the <BR>format that the <CODE>PLookupName</CODE>, <CODE>PConfirmName</CODE>, and <CODE>PRemoveName</CODE> functions require. <BR><A HREF=#MARKER-9-51>Figure 3-5</A> shows the <A NAME=MARKER-2-167></A>format of the entity name recor<A NAME=MARKER-2-3></A>d. <A NAME=MARKER-9-50></A><P>
<B>Figure 3-5  <A NAME=MARKER-9-51></A>Entity name record format </B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/NBP-L-04.jpg"><P>
 For the <CODE>PConfirmName</CODE> and <CODE>PRemoveName</CODE> functions, you must specify explicit values for the <CODE>nbpObject</CODE>, <CODE>nbpType</CODE>, and <CODE>nbpZone</CODE> parameters. However, you can specify wildcards for these parameters for <CODE>PLookupName</CODE>. <A NAME=MARKER-2-52></A><P>
<A NAME=HEADING65-13></A>
<H3>Looking Up a Name</H3>
 You can use the <A NAME=MARKER-2-19></A><CODE>PLookupName</CODE> <A NAME=MARKER-2-131></A>function to look up the address of a particular entity whose NBP name you know. You can also use the <CODE>PLookupName</CODE> function to find the addresses of more than one entity whose NBP names match a partial name that includes wildcards. <P>
 If you want to retrieve the address of a particular entity, you assign to the <CODE>entityPtr</CODE> field of the parameter block a pointer to a fully qualified entity name that you provided using <CODE>NBPSetEntity</CODE>. <A NAME=MARKER-2-93></A>You create a buffer to hold the name and address that <CODE>PLookupName</CODE> returns and set the parameter block's return buffer pointer (<CODE>retBuffPtr</CODE>) field to this buffer's pointer. Because the data is packed and each tuple takes a maximum of 104 bytes, to look up a particular name you need to set the return buffer size (<CODE>retBuffSize</CODE>) field to the buffer size of 104 bytes. <A HREF=#MARKER-9-56>Figure 3-6</A> shows the format of <BR>the record for a tuple that <CODE>PLookupName</CODE> returns. <P>
<B>Figure 3-6  <A NAME=MARKER-9-56></A>Tuple returned by the <CODE>PLookupName</CODE> function </B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/NBP-L-05.jpg"><P>
 If you want only one name and address pair returned, you set the maximum number of matches (<CODE>maxToGet</CODE>) field to 1. When you call the function asynchronously, you must assign to the <CODE>ioCompletion</CODE> field a pointer to your completion routine or set this field to <CODE>NIL</CODE>. For more information about executing routines synchronously or asynchro-<BR>nously, see the chapter "Introduction to AppleTalk" in this book. <P>
 If you want to obtain the addresses of other instances of the same type of entity that are running on other nodes in the network, you can look up the addresses of these entities by specifying<A NAME=MARKER-2-28></A> wildcards. In this case, you specify a type field value and wildcards for the object and zone fields.<P>
 <A HREF=#MARKER-9-2>Table 3-1</A> shows the wildcards that you can use to control the kind of matches that you want NBP to return. 
<TABLE BORDER="0" CELLPADDING=3>
<CAPTION><A NAME=MARKER-9-2></A><B>Table 3-1 NBP wildcards</B></CAPTION>
<TH>Character<TH>Meaning<TR>
<TD>=<TD>All possible values. You can use the equal sign (=) alone instead of specifying a name in the object or type field.<TR>
<TD>[double tilde]<TD>Any or no characters in this position. You can use the double tilde ([double tilde]) to obtain matches for object or type fields. For example, <I>pa[double tilde]l</I> matches <I>pal</I>, <I>paul</I>, <I>paper ball</I>, and so forth. You can use only one double tilde in any string. Press Option-X to type the double tilde character on a Macintosh keyboard. If you use the double tilde alone, it has the same meaning as the equal sign (=). <P>Any node not running AppleTalk Phase 2 drivers will not recognize this character.<TR>
<TD>*<TD>This zone. You can use the asterisk (*) in place of the name of the zone to which this node belongs.</TABLE>
<P>
 For example, if you want to retrieve the names and addresses of all the mailboxes in the same zone as one in which your process is running, you can set the entity name object field to the equal sign (=), the type field to <CODE>Mailbox</CODE>, and the zone field to the asterisk (*). The <CODE>PLookupName</CODE> function will return the entity names and internet addresses of all mailboxes in that zone excluding your own entity's name and address. <P>
 <A NAME=MARKER-9-58></A>You can specify how thorough the lookup should be by defining the number of times that NBP should broadcast the lookup packets and the time interval between these retries. To do this, you assign values to the parameter block's <CODE>count</CODE> and <CODE>interval</CODE> fields. See the discussion on how to determine these values in the section <A HREF=Networking-64.html#MARKER-9-37>"Registering a Names Table Entry" beginning on page 3-8</A>.<P>
 You must also create a buffer large enough to hold all of the tuples for the matches that NBP returns. (See <A HREF=#MARKER-9-64>Listing 3-3 on page 3-15</A>.) You assign the buffer's pointer to the parameter block's <CODE>retBuffPtr</CODE> field and the buffer's size in bytes to the <CODE>retBuffSize</CODE> field. Allow 104 bytes for each match. You set the maximum number of matches for NBP to return as the value of the <CODE>maxToGet</CODE> field. <P>
 The <CODE>PLookupName</CODE> function keeps track of the number of matches it writes to the return buffer each time it receives a returned packet containing one or more matches, and it updates the number of matches returned (<CODE>numGotten</CODE>) field after it returns each match. Because <CODE>PLookupName</CODE> maintains <CODE>numGotten</CODE>, you can start reading the names and addresses in the buffer and storing them or displaying them for the user before the function completes execution. <P>
 A single lookup request or retry can return more than one match in a reply packet. When this happens, the <CODE>PLookupName</CODE> function will return as many of the matches that the packet contains as will fit in the buffer. In cases such as this, you will find that the number of tuples that <CODE>PLookupName</CODE> writes to the return buffer may exceed the maximum number of matches to be returned as specified by <CODE>maxToGet</CODE>. When this occurs you can assume that there may be additional matches that did not fit in the buffer or additional reply packets containing matches that <CODE>PLookupName</CODE> did not process. To receive all the matches, you should increase the size of the buffer and the <CODE>maxToGet</CODE> number, and call the <CODE>PLookupName</CODE> function again.<P>
 If the buffer is too small to accommodate all of the returned matches in a packet, <BR>the <CODE>PLookupName</CODE> function returns a function result of <CODE>nbpBuffOvr</CODE>. In any case, <BR>the <CODE>numGotten</CODE> field always indicates the actual number of tuples returned in the <BR>buffer. (See also <A HREF=Networking-78.html#MARKER-9-132>"PLookupName" beginning on page 3-28</A> for more information <BR>about this function.)<P>
 The code in <A HREF=#MARKER-9-59>Listing 3-2</A> assigns values to the fields of the parameter block to be used for the <CODE>PLookupName</CODE> function call. The value <CODE>theEntity</CODE> points to a packed entity-name record that you prepared using <CODE>NBPSetEntity</CODE>. This is the name that will be looked <BR>for. The value <CODE>returnBufferPtr</CODE> points to the buffer where <CODE>PLookupName</CODE> will return <BR>any matches that it finds. The buffer must be able to hold the number of matches specified by the input value of <CODE>entityCount</CODE>; each match is 104 bytes long. On return, <CODE>entityCount</CODE> contains the number of matches that the <CODE>PLookupName</CODE> function found and returned in the buffer pointed to by r<CODE>eturnBufferPtr</CODE>. The <CODE>PLookupName</CODE> function's glue code in the MPW interface fills in the values for the <CODE>ioRefNum</CODE> and <CODE>csCode</CODE> fields. <P>
<B>Listing 3-2  <A NAME=MARKER-9-59></A>Calling <CODE>PLookupName</CODE> to find matches for an entity name</B><P>
<PRE>
FUNCTION MyLookupName (theEntity: EntityName; VAR entityCount: Integer; 
                        returnBufferPtr: Ptr): OSErr;
CONST
   kTupleSize = 104;       {sizeof(AddrBlock) + a one-byte enumerator + }
                           { sizeof(EntityName)}
VAR
   mppPB: MPPParamBlock;
BEGIN
   WITH mppPB DO
      BEGIN
         interval := $0F;                 {reasonable values for the }
         count := $03;                    { interval and retry count}
         entityPtr := @theEntity;         {pointer to the entity name to }
                                          { look for}
         retBuffPtr := returnBufferPtr;   {pointer to the buffer for the }
                                          { tuples}
         RetBuffSize := entityCount * kTupleSize; 
                                          {return buffer size}
         maxToGet := entityCount;         {the number of entities that the }
                                          { return buffer can hold}
      END;
   MyLookupName := PLookupName(@mppPB, FALSE); 
                                 {look up the entity name}
   entityCount := mppPB.numGotten; 
                                 {return the number of matches found}
END;
</PRE>
 The tuples in the buffer are in the format used in the NBP names table, as shown in <A HREF=#MARKER-9-56>Figure 3-6 on page 3-12</A>. Because data is packed, the object, type, and zone names in this format are of arbitrary length; you cannot use Pascal to read these tuples. You can use the <CODE>NBPExtract</CODE> function to read tuples from the buffer. <A NAME=MARKER-2-76></A><P>
<A NAME=HEADING65-32></A>
<H3>Extracting a Name From a List of Returned Names</H3>
 <A NAME=MARKER-2-115></A>After NBP returns the matches to your buffer, you need to extract the match or matches that you want to use. You can use the <A NAME=MARKER-2-182></A><CODE>NBPExtract</CODE> function to read a name and address pair from the return buffer that you supplied to <CODE>PLookupName</CODE>. Before you call <CODE>NBPExtract</CODE>, you need to allocate memory for two buffers: one buffer that is at least <BR>102 bytes long to hold the name part of the tuple and another buffer that is 4 bytes long to hold the address. You pass the <CODE>NBPExtract</CODE> function pointers to these <A NAME=MARKER-2-196></A>buffers. The <CODE>NBPExtract</CODE> function unpacks the name and address data and writes it to the buffers <BR>that you supply.<P>
 You also pass <CODE>NBPExtract</CODE> a pointer to the buffer containing the returned tuples; this is the pointer that you assigned to the <CODE>PLookupName</CODE> function's <CODE>retBuffPtr</CODE> parameter block field. For the <CODE>numInBuf</CODE> parameter, you specify the number of tuples in the return buffer; this is the value that the <CODE>PLookupName</CODE> function returned in the <CODE>numGotten</CODE> parameter block field. Counting the first returned tuple as one and following in sequence to the value of <CODE>numGotten</CODE>, you identify which name and address pair you want to extract as the value of the <CODE>whichOne</CODE> parameter. You can use the <CODE>NBPExtract</CODE> function in a loop that varies the value of the <CODE>whichOne</CODE> parameter (<CODE>entityCount</CODE> in the following code example) from 1 to the total number of tuples in the list to extract all the names in the list. <P>
 <A HREF=#MARKER-9-64>Listing 3-3</A> shows an application-defined procedure, <CODE>DoMyLookupName</CODE>, that allocates a buffer to hold the matches that the <CODE>PLookupName</CODE> function returns; the <CODE>MyLookupName</CODE> function, shown in <A HREF=#MARKER-9-59>Listing 3-2 on page 3-13</A>, calls the <CODE>PLookupName</CODE> function. The <CODE>DoMyLookupName</CODE> procedure calls the <CODE>MyLookupName</CODE> function.<P>
 If the <CODE>MyLookupName</CODE> function returns a result code of <CODE>noErr</CODE>, then the code calls the <CODE>NBPExtract</CODE> function to read the matches that are in the buffer and write them to <BR>the application's buffer with an application-defined routine, <CODE>MyAddToMatchList</CODE>; the listing does not show the <CODE>MyAddToMatchList</CODE> routine. After the matches are extracted, the code disposes of the return buffer. <P>
<B>Listing 3-3  <A NAME=MARKER-9-64></A>Creating a buffer to hold name matches found, then using <CODE>NBPExtract</CODE> to read the matches</B><P>
<PRE>
PROCEDURE DoMyLookupName;
   CONST
      kTupleSize = 104;       {sizeof(AddrBlock) + a one-byte enumerator + }
                              { sizeof(EntityName)}
      kMaxMatches = 100;      {number of matches to get}
   VAR
      result:           OSErr;
      returnBufferPtr:  Ptr;
      theEntity:        EntityName;
      entityCount:      Integer;
      index:            Integer;
      entityAddress:    AddrBlock;
BEGIN
   returnBufferPtr := NewPtr(kMaxMatches * LongInt(kTupleSize));
   IF returnBufferPtr &lt;&gt; NIL THEN
      BEGIN
      {Create a packed entity name.}
         NBPSetEntity(@theEntity, '=', 'AFPServer', '*');
         entityCount := kMaxMatches;      {maximum number of matches we want}
         result := MyLookupName(theEntity, entityCount, returnBufferPtr);
         IF result = noErr THEN
         {Extract the matches and add them to the match list.}
            FOR index := 1 TO entityCount DO
               IF NBPExtract(returnBufferPtr, entityCount, index, theEntity,
                            entityAddress) = noErr THEN
                  AddToMatchList(theEntity, entityAddress)
            DiposPtr(returnBufferPtr);    {release the memory}
   END;
END;
</PRE>
<A NAME=HEADING65-39></A>
<H3>Confirming a Name</H3>
 <A NAME=MARKER-2-65></A>If you know the name and address of an entity, and you only want to confirm that the tuple is still registered with NBP and that the address hasn't been changed, you should call the <CODE>PConfirmName</CODE> function instead of calling <CODE>PLookupName</CODE>. <P>
 The <CODE>PConfirmName</CODE> function is faster than <CODE>PLookupName</CODE> because NBP can send a request packet directly to the node based on the address that you supply rather than having to broadcast lookup packets throughout the network to locate the names table entry based on the entity name alone. <P>
 The code in <A HREF=#MARKER-9-66>Listing 3-4</A> sets up the parameter block to be used for the <CODE>PConfirmName</CODE> function and calls <CODE>PConfirmName</CODE> to verify that the name and address still exist, and that the address is unchanged. If the application is using a different socket, <CODE>PConfirmName</CODE> returns a function result of <CODE>nbpConfDiff</CODE> and gives the new <BR>socket number in the parameter block's <CODE>newSocke</CODE>t field. <P>
<B>Listing 3-4  <A NAME=MARKER-9-66></A>Confirming an existing NBP name and address</B><P>
<PRE>
FUNCTION MyConfirmName (theEntity: EntityName; entityAddress: AddrBlock;
                        VAR socket: Integer): OSErr;
VAR
   mppPB: MPPParamBlock;
BEGIN
   WITH mppPB DO
      BEGIN
         interval := $0F;              {reasonable values for the interval }
         count := $03;                 { and retry count}
         entityPtr := @theEntity;      {entity name to look for}
         confirmAddr := entityAddress; {entity's network address}
      END;
   MyConfirmName := PConfirmName(@mppPB, FALSE);
   socket := mppPB.newSocket;          {return the socket number, which is }
                                       { the new socket number if }
                                       { PConfirmName's result is }
                                       { nbpConfDiff}
END;
</PRE>
<A NAME=HEADING65-45></A>
<H3>Removing an Entry From the Names Table</H3>
 After you close the socket that your process uses or when you no longer want to make the process available throughout the network, you remove the names table entry from the node on which it resides using the <A NAME=MARKER-2-3></A><CODE>PRemoveName</CODE> function. <P>
 <A NAME=MARKER-2-68></A>There are two ways to remove a names table entry:<P>
<UL>
<LI>For the first method, you use the <CODE>NBPSetEntity</CODE> procedure to put the entity name of an existing registered entity into the structure that NBP requires. Then you specify the pointer to this record as the value of the <CODE>entityPtr</CODE> field of the parameter block. 
<LI>For the second method, you provide the <CODE>PRemoveName</CODE> function with a pointer to the names table entry record that you used to register the name. <P>
</UL>
 The <CODE>PRemoveNam</CODE>e function removes the entry from the node's names table unless the name is no longer registered, in which case, <CODE>PRemoveName</CODE> returns a function result of <CODE>nbpNotFound</CODE>. An entity name may not be included in the node's names table if, for example, the request to register the name had been canceled by the <CODE>PKillNBP</CODE> function before the <CODE>PRegisterName</CODE> function used to register the name was executed. <P>
 The code in <A HREF=#MARKER-9-69>Listing 3-5</A> shows how to remove a names table entry using <CODE>PRemoveName</CODE>. The <CODE>PRemoveName</CODE> function's glue code fills in the <CODE>ioRefNum</CODE> and <CODE>csCode</CODE> values. The code in <A HREF=#MARKER-9-69>Listing 3-5</A> provides the pointer to the names table entry record that was used to register the name; it assigns this value to the <CODE>entityPtr</CODE> field of the parameter block used for the <CODE>PRemoveName</CODE> function call. (The code in <A HREF=Networking-64.html#MARKER-9-41>Listing 3-1 on page 3-10</A> created the names table entry record.) If the application-defined <CODE>MyRemoveName</CODE> function returns a function result of <CODE>noErr</CODE>, the code disposes of the memory block pointed to by <CODE>ntePtr</CODE>. <P>
<B>Listing 3-5  <A NAME=MARKER-9-69></A>Removing an NBP names table entry</B><P>
<PRE>
FUNCTION MyRemoveName (ntePtr: Ptr): OSErr;
VAR
   mppPB: MPPParamBlock;
   result: OSErr;
BEGIN
   mppPB.entityPtr := Ptr(ORD4(ntePtr) + 9);
                     {the entity name is at offset 9 in the NTE}
   result := PRemoveName(@mppPB, FALSE);{remove the name}
   IF (result = noErr) THEN
      DisposPtr(ntePtr); {release the memory}
   MyRemoveName := result;
END;
</PRE>
<A NAME=HEADING65-54></A>
<H3><A NAME=MARKER-9-70></A>Canceling a Request </H3>
 You can use the <CODE>PKillNBP</CODE> function to cancel a request to register, look up, or confirm <BR>a names table entry if the function was called asynchronously and it has not already been executed.<P>
 When you call <CODE>PRegisterName</CODE>, <CODE>PLookupName</CODE>, or <CODE>PConfirmName</CODE>, NBP calls the Device Manager, which places your request in the .MPP driver queue with other requests waiting to be executed. To queue the request, the Device Manager places <BR>a pointer to the function's parameter block in the .MPP driver queue. You assign this pointer to the <CODE>PKillNPB</CODE> parameter block's queue element (<CODE>nKillQEl</CODE>) field.<P>
 If the function request that you want to cancel is not in the queue, <CODE>PKillNBP</CODE> returns <BR>a function result of <CODE>cbNotFound</CODE>. If <CODE>PKillNBP</CODE> cancels the function, it returns a <BR>function result of <CODE>noErr</CODE>, and the function that it canceled returns a function result <BR>of <CODE>reqAborted</CODE>. <P>
 The code in <A HREF=#MARKER-9-71>Listing 3-6 on page 3-18</A> shows how to cancel a <CODE>PRegisterName</CODE>, <CODE>PLookupName</CODE>, or <CODE>PConfirmName</CODE> function call. The application-defined <CODE>MyKillNBP</CODE> function takes as an input parameter a pointer to the parameter block that was used <BR>to make the <CODE>PLookupName</CODE>, <CODE>PRegisterName</CODE>, or <CODE>PConfirmName</CODE> function call to be canceled. The code assigns this pointer to the <CODE>nKillQEl</CODE> field of the parameter block to be passed to the <CODE>PKillNBP</CODE> function. The <CODE>ioRefNum</CODE> and <CODE>csCode</CODE> field values are filled in by the <CODE>PKillNBP</CODE> function's glue code in the MPW interface. <P>
<B>Listing 3-6  <A NAME=MARKER-9-71></A>Canceling a request to look up a name</B><P>
<PRE>
FUNCTION MyKillNBP (requestPBPtr: MPPPBptr): OSErr;
   VAR
   mppPB: MPPParamBlock;
BEGIN
   mppPB.nKillQEl := Ptr(requestPBPtr);
   MyKillNBP := PKillNBP(@mppPB, FALSE);
END;
</PRE>
</BLOCKQUOTE>
<HR>
<center>
<A HREF="Networking-64.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="Networking-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="Networking-304.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt= "Book Index"></A> <A HREF="Networking-66.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="Networking-3.html">&copy; Apple Computer, Inc.</A><br>7 JUL 1996</center></font><P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML>  
