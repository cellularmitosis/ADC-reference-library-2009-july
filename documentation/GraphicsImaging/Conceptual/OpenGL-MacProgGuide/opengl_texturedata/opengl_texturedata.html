<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>OpenGL Programming Guide for Mac OS X: Techniques for Working with Texture Data</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Techniques for Working with Texture Data"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP40001987-CH407" title="Techniques for Working with Texture Data"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../index.html#//apple_ref/doc/uid/TP30000440-TP30000424" target="_top">Graphics &amp; Imaging</a> &gt; <a href="../../../OpenGL-date.html#//apple_ref/doc/uid/TP30000440-TP30000424-TP30000549" target="_top">OpenGL</a> &gt; <a href="../opengl_intro/opengl_intro.html#//apple_ref/doc/uid/TP40001987-CH207-TP9">OpenGL Programming Guide for Mac OS X</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../opengl_vertexdata/opengl_vertexdata.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../opengl_fsaa/opengl_fsaa.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        
        <a name="//apple_ref/doc/uid/TP40001987-CH407-SW1" title="Techniques for Working with Texture Data"></a><h1>Techniques for Working with Texture Data</h1><p>Textures add realism to OpenGL objects. They are what makes the objects defined by vertex data take on the material properties of real-world objects, such as wood, brick, metal, and fur. Texture data can originate from many sources, including images. As with vertex data, there are a variety of techniques you can use to minimize the number of times texture data is copied and converted as it's moved throughout the system. </p><br/><div><a name="//apple_ref/doc/uid/TP40001987-CH407-SW23" title="Figure 9-1Textures add realism to a scene"></a><p><strong>Figure 9-1&nbsp;&nbsp;</strong>Textures add realism to a scene</p><img src = "../art/textures.jpg" alt = "Textures add realism to a scene" ></div><br/><p>Textures start as pixel data that flows through an OpenGL program, as shown in <span class="content_text">Figure 9-2</span>.  As with vertex data you can supply pixel data in two ways. The first way, from pixel data to per-pixel operations, is as part of an OpenGL command sequence that is issued by the application and executed immediately (immediate mode). The second is packaged as a named display list that can be preprocessed ahead of time and used later in the program.</p><br/><div><a name="//apple_ref/doc/uid/TP40001987-CH407-SW2" title="Figure 9-2Texture data path"></a><p><strong>Figure 9-2&nbsp;&nbsp;</strong>Texture data path</p><img src = "../art/pixel_pipeline.jpg" alt = "Texture data path" ></div><br/><p>The precise route that texture data takes from your application to its final destination can impact the performance of your application. The purpose of this chapter is to provide techniques you can use to ensure optimal processing of texture data in your application. This chapter</p><ul class="ul"><li class="li"><p>shows how to use OpenGL extensions to optimize performance</p></li><li class="li"><p>lists optimal data formats and types</p></li><li class="li"><p>provides information on working with textures whose dimensions are not a power of two</p></li><li class="li"><p>describes creating textures from image data</p></li><li class="li"><p>shows how to download textures</p></li><li class="li"><p>discusses using double buffers for texture data</p></li></ul>
<!-- This template is being used for both PDF and HTML. -->

    
    <h4>In this section:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="opengl_texturedata.html#//apple_ref/doc/uid/TP40001987-CH407-SW14">Using Extensions to Optimize</a>
				
			<br/>
			
        
			
			
				<a href="opengl_texturedata.html#//apple_ref/doc/uid/TP40001987-CH407-SW22">Optimal Data Formats and Types</a>
				
			<br/>
			
        
			
			
				<a href="opengl_texturedata.html#//apple_ref/doc/uid/TP40001987-CH407-SW3">Working with Non–Power-of-Two Textures</a>
				
			<br/>
			
        
			
			
				<a href="opengl_texturedata.html#//apple_ref/doc/uid/TP40001987-CH407-SW28">Creating Textures from Image Data</a>
				
			<br/>
			
        
			
			
				<a href="opengl_texturedata.html#//apple_ref/doc/uid/TP40001987-CH407-SW13">Downloading Texture Data</a>
				
			<br/>
			
        
			
			
				<a href="opengl_texturedata.html#//apple_ref/doc/uid/TP40001987-CH407-SW16">Double Buffering Texture Data</a>
				
			<br/>
			
        
			
			
				<a href="opengl_texturedata.html#//apple_ref/doc/uid/TP40001987-CH407-SW32">See Also</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/TP40001987-CH407-SW14" title="Using Extensions to Optimize"></a><h2>Using Extensions to Optimize</h2><p>Without any optimizations, texture data flows through an OpenGL program as shown in <span class="content_text">Figure 9-3</span>. Data from your application first goes to the OpenGL framework, which may make a copy of the data before handing it to the driver. If your data is not in a native format for the hardware (see <span class="content_text"><a href="opengl_texturedata.html#//apple_ref/doc/uid/TP40001987-CH407-SW22">“Optimal Data Formats and Types”</a></span>), the driver may also make a copy of the data to convert it to a hardware-specific format for uploading to video memory. Video memory, in turn, can keep a copy of the data. Theoretically, there could be four copies of your texture data throughout the system.</p><br/><div><a name="//apple_ref/doc/uid/TP40001987-CH407-SW6" title="Figure 9-3Data copies in an OpenGL program"></a><p><strong>Figure 9-3&nbsp;&nbsp;</strong>Data copies in an OpenGL program</p><img src = "../art/texturedata_copies.jpg" alt = "Data copies in an OpenGL program" ></div><br/><p>Data flows at different rates through the system, as shown by the size of the arrows in <span class="content_text">Figure 9-3</span>. The fastest data transfer happens between VRAM and the GPU. The slowest transfer occurs between the OpenGL driver and VRAM. Data moves between the application and the OpenGL framework, and between the  framework and the driver at the same "medium" rate. Eliminating any of the data transfers, but the slowest one in particular, will improve application performance. </p><p>There are several extensions you can use to eliminate one or more data copies and control how texture data travels from your application to the GPU:</p><ul class="ul"><li class="li"><p><code>GL_APPLE_client_storage</code></p></li><li class="li"><p><code>GL_APPLE_texture_range</code> along with a storage hint, either <code>GL_STORAGE_CACHED_APPLE</code> or <code>GL_STORAGE_SHARED_APPLE</code></p></li><li class="li"><p><code>GL_ARB_texture_rectangle</code></p></li></ul><p>The sections that follow describe the extensions and show how to use them. </p><a name="//apple_ref/doc/uid/TP40001987-CH407-SW24" title="Apple Client Storage"></a><h3>Apple Client Storage</h3><p>The Apple client storage extension (<code>APPLE_client_storage</code>) lets you provide OpenGL with a pointer to memory that your application allocates and maintains. OpenGL retains a pointer to your data but does not copy the data. Because OpenGL references your data, this extension requires that you retain a copy of your texture data until it is no longer needed. By using this extension you can eliminate the OpenGL framework copy as shown in <span class="content_text">Figure 9-4</span>. Note that a texture  width must be a multiple of 32 bytes for OpenGL to bypass the copy operation from the application to the OpenGL framework.</p><br/><div><a name="//apple_ref/doc/uid/TP40001987-CH407-SW15" title="Figure 9-4The client storage extension eliminates a data copy"></a><p><strong>Figure 9-4&nbsp;&nbsp;</strong>The client storage extension eliminates a data copy</p><img src = "../art/texturedata_storage_ext.jpg" alt = "The client storage extension eliminates a data copy" ></div><br/><p>The Apple client storage extension defines a pixel storage parameter, <code>GL_UNPACK_CLIENT_STORAGE_APPLE</code>, that you pass to the OpenGL function <code>glPixelStorei</code> to specify that your application retains storage for textures. The following code sets up client storage:</p><div class="codesample"><table><tr><td scope="row"><pre>glPixelStorei(GL_UNPACK_CLIENT_STORAGE_APPLE, GL_TRUE);<span></span></pre></td></tr></table></div><p>For detailed information, see the <span class="content_text"><a href="http://oss.sgi.com/projects/ogl-sample/registry/APPLE/client_storage.txt" target="_blank">OpenGL specification for the Apple client storage extension</a></span>.</p><a name="//apple_ref/doc/uid/TP40001987-CH407-SW21" title="Apple Texture Range and Rectangle Texture"></a><h3>Apple Texture Range and Rectangle Texture</h3><p>The Apple texture range  extension  (<code>APPLE_texture_range</code>) lets you define a region of memory used for texture data. Typically you specify an address range that encompasses the storage for a set of textures. This allows the OpenGL driver to optimize memory usage by creating a single memory mapping for all of the textures. You can also provide a hint as to how the data should be stored: cached or shared. The cached hint specifies to cache texture data  in video memory. This hint is recommended when you have textures that you plan to use multiple times or that use linear filtering. The shared hint indicates that data should be mapped into a region of memory that enables the GPU to access the texture data directly (via DMA) without the need to copy it. This hint is best when you are using large images only once, perform nearest-neighbor filtering, or need to scale down the size of an image. </p><p>The texture range extension defines the following routine for making a single memory mapping for all of the textures used by your application:</p><div class="codesample"><table><tr><td scope="row"><pre>void glTextureRangeAPPLE(GLenum target, GLsizei length, GLvoid *pointer);<span></span></pre></td></tr></table></div><p><code>target</code> is a valid texture target, such as <code>GL_TEXTURE_2D</code>. </p><p><code>length</code> specifies the number of bytes in the address space referred to by the <code>pointer</code> parameter.</p><p><code>*pointer</code> points to the address space that your application provides for texture storage.</p><p>You provide the hint parameter and a parameter value to to the OpenGL function <code>glTexParameteri</code>. The possible values for the storage hint parameter (<code>GL_TEXTURE_STORAGE_HINT_APPLE</code>) are <code>GL_STORAGE_CACHED_APPLE</code> or <code>GL_STORAGE_SHARED_APPLE</code>. </p><p>Some hardware requires texture dimensions to be a power-of-two before the hardware can upload the data using DMA. The rectangle texture extension (<code>ARB_texture_rectangle</code>) was introduced to allow texture targets for textures of any dimensions—that is, rectangle textures (<code>GL_TEXTURE_RECTANGLE_ARB</code>). You need to use the rectangle texture extension together with the Apple texture range extension to ensure OpenGL uses DMA to access your texture data. These extensions allow you to bypass the OpenGL driver, as shown in  <span class="content_text">Figure 9-5</span>.</p><p>Note that OpenGL does not use DMA for a power-of-two texture target (<code>GL_TEXTURE_2D</code>). So, unlike the rectangular texture, the power-of-two texture will  incur one additional copy and performance won't be quite as fast. The performance typically isn't an issue because games, which are the applications most likely to use power-of-two textures, load textures at the start of a game or level and don't upload textures in real time as often as applications that use rectangular textures, which usually play video or display images.</p><p>The next section has code examples that use the texture range and rectangle textures together with the Apple client storage extension.</p><br/><div><a name="//apple_ref/doc/uid/TP40001987-CH407-SW4" title="Figure 9-5The texture range extension eliminates a data copy"></a><p><strong>Figure 9-5&nbsp;&nbsp;</strong>The texture range extension eliminates a data copy</p><img src = "../art/texturedata_range_ext.jpg" alt = "The texture range extension eliminates a data copy" ></div><br/><p>For detailed information on these extensions, see the <span class="content_text"><a href="http://developer.apple.com/graphicsimaging/opengl/extensions/apple_texture_range.html" target="_top">OpenGL specification for the Apple texture range extension</a></span> and the  <span class="content_text"><a href="http://oss.sgi.com/projects/ogl-sample/registry/ARB/texture_rectangle.txt" target="_blank">OpenGL specification for the ARB texture rectangle extension</a></span>.</p><a name="//apple_ref/doc/uid/TP40001987-CH407-SW25" title="Combining Extensions"></a><h3>Combining Extensions</h3><p>You can use the Apple client storage extension along with the Apple texture range extension to streamline the texture data path in your application. When used together, OpenGL moves texture data directly into video memory, as shown in <span class="content_text">Figure 9-6</span>. The GPU directly accesses your data (via DMA). The set up is slightly different for rectangular and power-of-two textures. The code examples in this section upload textures to the GPU. You can also use these extensions to download textures, see <span class="content_text"><a href="opengl_texturedata.html#//apple_ref/doc/uid/TP40001987-CH407-SW13">“Downloading Texture Data.”</a></span></p><br/><div><a name="//apple_ref/doc/uid/TP40001987-CH407-SW11" title="Figure 9-6Combining extensions to eliminate data copies"></a><p><strong>Figure 9-6&nbsp;&nbsp;</strong>Combining extensions to eliminate data copies</p><img src = "../art/texturedata_combining_ext.jpg" alt = "Combining extensions to eliminate two data copies" ></div><br/><p><span class="content_text">Listing 9-1</span> shows how to use the extensions for a rectangular texture. After enabling the texture rectangle extension you need to bind the rectangular texture to a target. Next, set up the storage hint. Call <code>glPixelStorei</code> to set up the Apple client storage extension. Finally, call the function <code>glTexImage2D</code> with a with a rectangular texture target and a pointer to your texture data. </p><div class="notebox"><a name="//apple_ref/doc/uid/TP40001987-CH407-SW26" title="Note"></a><p><strong>Note:</strong>&nbsp;The texture rectangle extension limits what can be done with rectangular textures. To understand the limitations in detail, read the <span class="content_text"><a href="http://oss.sgi.com/projects/ogl-sample/registry/ARB/texture_rectangle.txt" target="_blank">OpenGL extension for texture rectangles</a></span>. See <span class="content_text"><a href="opengl_texturedata.html#//apple_ref/doc/uid/TP40001987-CH407-SW3">“Working with Non–Power-of-Two Textures”</a></span> for an overview of the limitations and an alternative to using this extension.</p></div><a name="//apple_ref/doc/uid/TP40001987-CH407-SW7" title="Listing 9-1Using texture extensions for a rectangular texture"></a><p class="codesample"><strong>Listing 9-1&nbsp;&nbsp;</strong>Using texture extensions for a rectangular texture</p><div class="codesample"><table><tr><td scope="row"><pre>glEnable (GL_TEXTURE_RECTANGLE_ARB);<span></span></pre></td></tr><tr><td scope="row"><pre>glBindTexture(GL_TEXTURE_RECTANGLE_ARB, id);<span></span></pre></td></tr><tr><td scope="row"><pre>glTexParameteri(GL_TEXTURE_RECTANGLE_ARB,<span></span></pre></td></tr><tr><td scope="row"><pre>        GL_TEXTURE_STORAGE_HINT_APPLE,<span></span></pre></td></tr><tr><td scope="row"><pre>        GL_STORAGE_CACHED_APPLE);<span></span></pre></td></tr><tr><td scope="row"><pre>glPixelStorei(GL_UNPACK_CLIENT_STORAGE_APPLE, GL_TRUE);<span></span></pre></td></tr><tr><td scope="row"><pre>glTexImage2D(GL_TEXTURE_RECTANGLE_ARB,<span></span></pre></td></tr><tr><td scope="row"><pre>            0, GL_RGBA, sizex, sizey, GL_BGRA,<span></span></pre></td></tr><tr><td scope="row"><pre>            GL_UNSIGNED_INT_8_8_8_8_REV,<span></span></pre></td></tr><tr><td scope="row"><pre>            myImagePtr);<span></span></pre></td></tr></table></div><p>Setting up a power-of-two texture to use these extensions is similar to what's needed to set up a rectangular texture, as you can see by looking at <span class="content_text">Listing 9-2</span>. The difference is that the <code>GL_TEXTURE_2D</code> texture target replaces the <code>GL_TEXTURE_RECTANGLE_ARB</code> texture target. </p><a name="//apple_ref/doc/uid/TP40001987-CH407-SW5" title="Listing 9-2Using texture extensions for a power-of-two texture"></a><p class="codesample"><strong>Listing 9-2&nbsp;&nbsp;</strong>Using texture extensions for a power-of-two texture</p><div class="codesample"><table><tr><td scope="row"><pre>glBindTexture(GL_TEXTURE_2D, myTextureName);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>glTexParameteri(GL_TEXTURE_2D,<span></span></pre></td></tr><tr><td scope="row"><pre>        GL_TEXTURE_STORAGE_HINT_APPLE,<span></span></pre></td></tr><tr><td scope="row"><pre>        GL_STORAGE_CACHED_APPLE);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>glPixelStorei(GL_UNPACK_CLIENT_STORAGE_APPLE, GL_TRUE);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA,<span></span></pre></td></tr><tr><td scope="row"><pre>            sizex, sizey, GL_BGRA,<span></span></pre></td></tr><tr><td scope="row"><pre>            GL_UNSIGNED_INT_8_8_8_8_REV, myImagePtr);<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40001987-CH407-SW22" title="Optimal Data Formats and Types"></a><h2>Optimal Data Formats and Types</h2><p>The best format and data type combinations to use for texture data are: </p><ul class="simple"><li><p><code>GL_BGRA</code>, <code>GL_UNSIGNED_INT_8_8_8_8_REV</code></p></li><li><p><code>GL_BGRA</code>, <code>GL_UNSIGNED_SHORT_1_5_5_5_REV</code>)</p></li><li><p><code>GL_YCBCR_422_APPLE</code>, <code>GL_UNSIGNED_SHORT_8_8_REV_APPLE</code></p></li></ul><p>The combination <code>GL_RGBA</code>  and <code>GL_UNSIGNED_BYTE</code> needs to be swizzled by many cards when the data is loaded, so it's not recommended.</p><a name="//apple_ref/doc/uid/TP40001987-CH407-SW3" title="Working with Non&acirc;&#128;&#147;Power-of-Two Textures"></a><h2>Working with Non–Power-of-Two Textures</h2><p>With more and more frequency, OpenGL is being used to process video and images, which typically have dimensions that are not a power-of-two. Until OpenGL 2.0, the texture rectangle extension (<code>ARB_texture_rectangle</code>) provided the only option for a rectangular texture target. This extension, however, imposes the following restrictions on rectangular textures:</p><ul class="ul"><li class="li"><p>You can't use mipmap filtering with them.</p></li><li class="li"><p>You can use only these wrap modes: <code>GL_CLAMP</code>, <code>GL_CLAMP_TO_EDGE</code>, and <code>GL_CLAMP_TO_BORDER</code>.</p></li><li class="li"><p>The texture cannot have  a border.</p></li><li class="li"><p>The texture uses non-normalized texture coordinates. (See <span class="content_text">Figure 9-7</span>.)</p></li></ul><p>OpenGL 2.0 adds another option for a rectangular texture target through the <code>ARB_texture_non_power_of_two</code> extension, which supports these textures without the limitations of the <code>ARB_texture_rectangle</code> extension. Before using it, you must check to make sure the functionality is available. You'll also want to consult the <span class="content_text"><a href="http://oss.sgi.com/projects/ogl-sample/registry/ARB/texture_non_power_of_two.txt" target="_blank">OpenGL specification for the non—power-of-two extension</a></span>.</p><br/><div><a name="//apple_ref/doc/uid/TP40001987-CH407-SW12" title="Figure 9-7Normalized and non-normalized coordinates"></a><p><strong>Figure 9-7&nbsp;&nbsp;</strong>Normalized and non-normalized coordinates</p><img src = "../art/coordinate_system.jpg" alt = "Normalized and non-normalized coordinates" ></div><br/><p>If your code runs on a system that does not support either the <code>ARB_texture_rectangle</code> or <code>ARB_texture_non_power_of_two</code> extensions you have these options for working with with rectangular images:</p><ul class="ul"><li class="li"><p>Use the OpenGL function <code>gluScaleImage</code> to scale the image so that it fits in a rectangle whose dimensions are a power of two. The image undoes the scaling effect when you draw the image from the properly sized rectangle back into a polygon that has the correct aspect ratio for the image. </p><div class="notebox"><a name="//apple_ref/doc/uid/TP40001987-CH407-SW27" title="Note"></a><p><strong>Note:</strong>&nbsp;This option can result in the loss of some data. But if your application runs on hardware that doesn't support the <code>ARB_texture_rectangle</code> extension, you may need to use this option.</p></div></li><li class="li"><p>Segment the image into power-of-two rectangles, as shown in <span class="content_text">Figure 9-8</span> by using one image buffer and different texture pointers. Notice how the sides and corners of the image shown in <span class="content_text">Figure 9-8</span> are segmented into increasingly smaller rectangles to ensure that every rectangle has dimensions that are a power of two. Special care may be needed at the borders between each segment to avoid filtering artifacts if the texture is scaled or rotated.</p><p>The <em><a href="../../../../../samplecode/OpenGL_Image/index.html#//apple_ref/doc/uid/DTS10000538" target="_top">OpenGL Image</a></em> sample application available on <span class="content_text"><a href="../../../../../samplecode/GraphicsImaging/idxOpenGL-date.html#//apple_ref/doc/uid/TP30000925-TP30000424-TP30000549" target="_top">Sample Code > Graphics &amp; Imaging > OpenGL</a></span> contains segmentation code and demonstrates other OpenGL features that support high-performance image display.</p></li></ul><br/><div><a name="//apple_ref/doc/uid/TP40001987-CH407-SW18" title="Figure 9-8An image segmented into power-of-two tiles"></a><p><strong>Figure 9-8&nbsp;&nbsp;</strong>An image segmented into power-of-two tiles</p><img src = "../art/tiled_image.jpg" alt = "An image segmented into power-of-two tiles" ></div><br/><a name="//apple_ref/doc/uid/TP40001987-CH407-SW28" title="Creating Textures from Image Data "></a><h2>Creating Textures from Image Data </h2><p>OpenGL on the Macintosh provides several options for creating high-quality textures from image data. Mac OS X supports floating-point pixel values, multiple image file formats, and a variety of color spaces. You can import a floating-point image into a floating-point texture. <span class="content_text">Figure 9-9</span> shows an image used to texture a cube.</p><br/><div><a name="//apple_ref/doc/uid/TP40001987-CH407-SW19" title="Figure 9-9Using an image as a texture for a cube"></a><p><strong>Figure 9-9&nbsp;&nbsp;</strong>Using an image as a texture for a cube</p><img src = "../art/image_as_texture.jpg" alt = "Using an image as a texture for a cube" ></div><br/><p>For Cocoa, you need to provide a bitmap representation. You can create an <code>NSBitmapImageRep</code> object from the contents of an <code>NSView</code> object. For either Cocoa or Carbon, you can use the Image I/O framework (see <em><a href="../../../Reference/CGImageSource/index.html#//apple_ref/doc/uid/TP40001399" target="_top">CGImageSource Reference</a></em>). This framework has support for many different file formats, floating-point data, and a variety of color spaces. Furthermore, it is easy to use. You can  import image data as a texture simply by supplying a <code>CFURL</code> object that specifies the location of the texture. There is no need for you to convert the image to an intermediate integer RGB format.</p><a name="//apple_ref/doc/uid/TP40001987-CH407-SW29" title="Creating a Texture from a Cocoa View"></a><h3>Creating a Texture from a Cocoa View</h3><p>You can use the <code>NSView</code> class or a subclass of it for texturing in OpenGL. The process is to first store the image data from an <code>NSView</code> object in an <code>NSBitmapImageRep</code> object so that the image data is in a format that can be readily used as texture data by OpenGL. Then, after setting up the texture target, you supply the bitmap data to the OpenGL function <code>glTexImage2D</code>. Note that you must have a valid, current OpenGL context set up. </p><div class="notebox"><a name="//apple_ref/doc/uid/TP40001987-CH407-SW30" title="Note"></a><p><strong>Note:</strong>&nbsp;You can't create an OpenGL texture from image data that's provided by a view created from the following classes: <code>NSProgressIndicator</code>, <code>NSMovieView</code>, and <code>NSOpenGLView</code>. This is because these views do not use the window backing store, which is what the method  <code>initWithFocusedViewRect:</code> reads from.</p></div><p><span class="content_text">Listing 9-3</span> shows a routine that uses this process to create  a texture from the contents of an <code>NSView</code> object. A detailed explanation for each numbered line of code appears following the listing.</p><a name="//apple_ref/doc/uid/TP40001987-CH407-SW10" title="Listing 9-3Building an OpenGL texture from an NSView object"></a><p class="codesample"><strong>Listing 9-3&nbsp;&nbsp;</strong>Building an OpenGL texture from an <code>NSView</code> object</p><div class="codesample"><table><tr><td scope="row"><pre>-(void)myTextureFromView:(NSView*)theView<span></span></pre></td></tr><tr><td scope="row"><pre>                textureName:(GLuint*)texName<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    NSBitmapImageRep * bitmap = [NSBitmapImageRep alloc]; <span>// 1</span></pre></td></tr><tr><td scope="row"><pre>    int samplesPerPixel = 0;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    [theView lockFocus]; <span>// 2</span></pre></td></tr><tr><td scope="row"><pre>    [bitmap initWithFocusedViewRect:[theView bounds]]; <span>// 3</span></pre></td></tr><tr><td scope="row"><pre>    [theView unlockFocus];<span></span></pre></td></tr><tr><td scope="row"><pre>    glPixelStorei(GL_UNPACK_ROW_LENGTH, [bitmap pixelsWide]); <span>// 4</span></pre></td></tr><tr><td scope="row"><pre>    glPixelStorei (GL_UNPACK_ALIGNMENT, 1); <span>// 5</span></pre></td></tr><tr><td scope="row"><pre>    if (*texName == 0) <span>// 6</span></pre></td></tr><tr><td scope="row"><pre>            glGenTextures (1, texName);<span></span></pre></td></tr><tr><td scope="row"><pre>    glBindTexture (GL_TEXTURE_RECTANGLE_ARB, *texName); <span>// 7</span></pre></td></tr><tr><td scope="row"><pre>    glTexParameteri(GL_TEXTURE_RECTANGLE_ARB,<span></span></pre></td></tr><tr><td scope="row"><pre>                    GL_TEXTURE_MIN_FILTER, GL_LINEAR); <span>// 8</span></pre></td></tr><tr><td scope="row"><pre>    samplesPerPixel = [bitmap samplesPerPixel]; <span>// 9</span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>   if(![bitmap isPlanar] &amp;&amp;<span></span></pre></td></tr><tr><td scope="row"><pre>       (samplesPerPixel == 3 || samplesPerPixel == 4)) { <span>// 10</span></pre></td></tr><tr><td scope="row"><pre>        glTexImage2D(GL_TEXTURE_RECTANGLE_ARB,<span></span></pre></td></tr><tr><td scope="row"><pre>                     0,<span></span></pre></td></tr><tr><td scope="row"><pre>                     samplesPerPixel == 4 ? GL_RGBA8 : GL_RGB8,<span></span></pre></td></tr><tr><td scope="row"><pre>                     [bitmap pixelsWide],<span></span></pre></td></tr><tr><td scope="row"><pre>                     [bitmap pixelsHigh],<span></span></pre></td></tr><tr><td scope="row"><pre>                     0,<span></span></pre></td></tr><tr><td scope="row"><pre>                     samplesPerPixel == 4 ? GL_RGBA : GL_RGB,<span></span></pre></td></tr><tr><td scope="row"><pre>                     GL_UNSIGNED_BYTE,<span></span></pre></td></tr><tr><td scope="row"><pre>                    [bitmap bitmapData]);<span></span></pre></td></tr><tr><td scope="row"><pre>    } else {<span></span></pre></td></tr><tr><td scope="row"><pre>       // Your code to report unsupported bitmap data<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>   [bitmap release]; <span>// 11</span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>Here's what the code does: </p><ol class="ol"><li class="li"><p>Allocates an <code>NSBitmapImageRep</code> object. </p></li><li class="li"><p>Locks the focus on the the <code>NSView</code> object so that subsequent commands take effect in coordinate system of the <code>NSView</code> object. You must invoke <code>lockFocus</code> before invoking methods that send commands to the window server, which is the case with the next line of code. Later, you must balance a <code>lockFocus</code> message with an <code>unlockFocus</code> message.</p></li><li class="li"><p>Initializes the <code>NSBitmapImageRep</code> object with bitmap data from the current view using the bounds returned by the <code>NSView</code> object passed to the <code>myTextureFromView:textureName</code> routine.</p></li><li class="li"><p>Sets the appropriate unpacking row length for the bitmap.</p></li><li class="li"><p>Sets the byte-aligned unpacking that's needed for bitmaps that are 3 bytes per pixel.</p></li><li class="li"><p>If a texture object is not passed in, generates a new texture object.</p></li><li class="li"><p>Binds the texture name to the texture target.</p></li><li class="li"><p>Sets filtering so that it does not use a mipmap, which would be redundant for the texture rectangle extension.</p></li><li class="li"><p>Gets the number of samples per pixel.</p></li><li class="li"><p>Checks to see if the bitmap is nonplanar and is either a 24-bit RGB bitmap or a 32-bit RGBA bitmap. If so, retrieves the pixel data using the <code>bitmapData</code> method, passing it along with other appropriate parameters to the OpenGL function for specifying a 2D texture image.</p></li><li class="li"><p>Releases the <code>NSBitmapImageRep</code> object when it is no longer needed.</p></li></ol><a name="//apple_ref/doc/uid/TP40001987-CH407-SW31" title="Creating a Texture from a Quartz Image Source"></a><h3>Creating a Texture from a Quartz Image Source</h3><p>Quartz images (<code>CGImageRef</code> data type) are defined in the Core Graphics framework (<code>ApplicationServices/CoreGraphics.framework/CGImage.h</code>) while the image source data type for reading image data and creating Quartz images from an image source is declared in the Image I/O framework (<code>ApplicationServices/ImageIO.framework/CGImageSource.h</code>). Quartz provides routines that read a wide variety of image data. </p><p>To use a Quartz image as a texture source, follow these steps:</p><ol class="ol"><li class="li"><p>Create a Quartz image source by supplying a <code>CFURL</code> object to the function <code><a href="../../../Reference/CGImageSource/Reference/reference.html#//apple_ref/c/func/CGImageSourceCreateWithURL" target="_top">CGImageSourceCreateWithURL</a></code>.</p></li><li class="li"><p>Create a Quartz image by extracting an image from the image source, using the function <code><a href="../../../Reference/CGImageSource/Reference/reference.html#//apple_ref/c/func/CGImageSourceCreateImageAtIndex" target="_top">CGImageSourceCreateImageAtIndex</a></code>.</p></li><li class="li"><p>Extract the image dimensions using the function <code><a href="../../../Reference/CGImage/Reference/reference.html#//apple_ref/c/func/CGImageGetWidth" target="_top">CGImageGetWidth</a></code> and <code><a href="../../../Reference/CGImage/Reference/reference.html#//apple_ref/c/func/CGImageGetHeight" target="_top">CGImageGetHeight</a></code>. You'll need these to calculate the storage required for the texture.</p></li><li class="li"><p>Allocate storage for the texture.</p></li><li class="li"><p>Create a color space for the image data. </p></li><li class="li"><p>Create a Quartz bitmap graphics context for drawing. Make sure to set up the context for pre-multiplied alpha.</p></li><li class="li"><p>Draw the image to the bitmap context.</p></li><li class="li"><p>Release the bitmap context.</p></li><li class="li"><p>Set the pixel storage mode by calling the function <code>glPixelStorei</code>.</p></li><li class="li"><p>Create and bind the texture.</p></li><li class="li"><p>Set up the appropriate texture parameters.</p></li><li class="li"><p>Call <code>glTexImage2D</code>, supplying the image data. </p></li><li class="li"><p>Free the image data.</p></li></ol><p><span class="content_text">Listing 9-4</span> shows a code fragment that performs these steps. Note that you must have a valid, current OpenGL context.</p><a name="//apple_ref/doc/uid/TP40001987-CH407-SW9" title="Listing 9-4Using a Quartz image as a texture source"></a><p class="codesample"><strong>Listing 9-4&nbsp;&nbsp;</strong>Using a Quartz image as a texture source</p><div class="codesample"><table><tr><td scope="row"><pre>CGImageSourceRef myImageSourceRef = CGImageSourceCreateWithURL(url, NULL);<span></span></pre></td></tr><tr><td scope="row"><pre>CGImageRef myImageRef = CGImageSourceCreateImageAtIndex (myImageSourceRef, 0, NULL);<span></span></pre></td></tr><tr><td scope="row"><pre>GLint myTextureName;<span></span></pre></td></tr><tr><td scope="row"><pre>size_t width = CGImageGetWidth(myImageRef);<span></span></pre></td></tr><tr><td scope="row"><pre>size_t height = CGImageGetHeight(myImageRef);<span></span></pre></td></tr><tr><td scope="row"><pre>CGRect rect = {{0, 0}, {width, height}};<span></span></pre></td></tr><tr><td scope="row"><pre>void * myData = calloc(width * 4, height);<span></span></pre></td></tr><tr><td scope="row"><pre>CGColorSpaceRef space = CGColorSpaceCreateDeviceRGB();<span></span></pre></td></tr><tr><td scope="row"><pre>CGContextRef myBitmapContext = CGBitmapContextCreate (myData,<span></span></pre></td></tr><tr><td scope="row"><pre>                        width, height, 8,<span></span></pre></td></tr><tr><td scope="row"><pre>                        width*4, space,<span></span></pre></td></tr><tr><td scope="row"><pre>                        kCGBitmapByteOrder32Host |<span></span></pre></td></tr><tr><td scope="row"><pre>                          kCGImageAlphaPremultipliedFirst);<span></span></pre></td></tr><tr><td scope="row"><pre>CGContextDrawImage(myBitmapContext, rect, myImageRef);<span></span></pre></td></tr><tr><td scope="row"><pre>CGContextRelease(myBitmapContext);<span></span></pre></td></tr><tr><td scope="row"><pre>glPixelStorei(GL_UNPACK_ROW_LENGTH, width);<span></span></pre></td></tr><tr><td scope="row"><pre>glPixelStorei(GL_UNPACK_ALIGNMENT, 1);<span></span></pre></td></tr><tr><td scope="row"><pre>glGenTextures(1, &amp;myTextureName);<span></span></pre></td></tr><tr><td scope="row"><pre>glBindTexture(GL_TEXTURE_RECTANGLE_ARB, myTextureName);<span></span></pre></td></tr><tr><td scope="row"><pre>glTexParameteri(GL_TEXTURE_RECTANGLE_ARB,<span></span></pre></td></tr><tr><td scope="row"><pre>                    GL_TEXTURE_MIN_FILTER, GL_LINEAR);<span></span></pre></td></tr><tr><td scope="row"><pre>glTexImage2D(GL_TEXTURE_RECTANGLE_ARB, 0, GL_RGBA8, width, height,<span></span></pre></td></tr><tr><td scope="row"><pre>                    0, GL_BGRA_EXT, GL_UNSIGNED_INT_8_8_8_8_REV, myData);<span></span></pre></td></tr><tr><td scope="row"><pre>free(myData);<span></span></pre></td></tr></table></div><p>For more information on using Quartz, see <em><a href="../../drawingwithquartz2d/index.html#//apple_ref/doc/uid/TP30001066" target="_top">Quartz 2D Programming Guide</a></em>, <em><a href="../../../Reference/CGImage/index.html#//apple_ref/doc/uid/TP30000956" target="_top">CGImage Reference</a></em>, and <em><a href="../../../Reference/CGImageSource/index.html#//apple_ref/doc/uid/TP40001399" target="_top">CGImageSource Reference</a></em>.</p><a name="//apple_ref/doc/uid/TP40001987-CH407-SW34" title="Getting Decompressed Raw Pixel Data from a Source Image"></a><h3>Getting Decompressed Raw Pixel Data from a Source Image</h3><p>You can use the Image I/O framework together with a Quartz data provider to obtain decompressed raw pixel data from a source image, as shown in <span class="content_text">Listing 9-5</span>. You can then use the pixel data for your OpenGL texture. The data has the same format as the source image, so you need to make sure that you use a source image that has the layout you need.</p><p>Alpha is not premultiplied for the pixel data obtained in <span class="content_text">Listing 9-5</span>, but alpha is premultiplied for the pixel data you get when using the code described in <span class="content_text"><a href="opengl_texturedata.html#//apple_ref/doc/uid/TP40001987-CH407-SW29">“Creating a Texture from a Cocoa View”</a></span> and <span class="content_text"><a href="opengl_texturedata.html#//apple_ref/doc/uid/TP40001987-CH407-SW31">“Creating a Texture from a Quartz Image Source.”</a></span></p><a name="//apple_ref/doc/uid/TP40001987-CH407-SW33" title="Listing 9-5Getting pixel data from a source image"></a><p class="codesample"><strong>Listing 9-5&nbsp;&nbsp;</strong>Getting pixel data from a source image</p><div class="codesample"><table><tr><td scope="row"><pre>CGImageSourceRef myImageSourceRef = CGImageSourceCreateWithURL(url, NULL);<span></span></pre></td></tr><tr><td scope="row"><pre>CGImageRef myImageRef = CGImageSourceCreateImageAtIndex (myImageSourceRef, 0, NULL);<span></span></pre></td></tr><tr><td scope="row"><pre>CFDataRef data = CGDataProviderCopyData(CGImageGetDataProvider(myImageRef));<span></span></pre></td></tr><tr><td scope="row"><pre>void *pixelData = CFDataGetBytePtr(data);<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40001987-CH407-SW13" title="Downloading Texture Data"></a><h2>Downloading Texture Data</h2><p>A texture download operation uses the same data path as an upload operation except that the data path is reversed. Downloading transfers texture data, using direct memory access (DMA),  from VRAM into a texture that can then be accessed directly by your application. You can use the Apple client range, texture range, and texture rectangle extensions for downloading, just as you would for uploading.</p><p>To download texture data using the Apple client storage, texture range, and texture rectangle extensions:</p><ul class="ul"><li class="li"><p>Bind a texture name to a texture target.</p></li><li class="li"><p>Set up the extensions</p></li><li class="li"><p>Call the function <code>glCopyTexSubImage2D</code> to copy a texture subimage from the specified window coordinates. This call initiates an asynchronous DMA transfer to system memory the next time you call a flush routine. The CPU doesn't wait for this call to complete. </p></li><li class="li"><p>Call the function <code><!--a-->glGetTexImage<!--/a--></code> to transfer the texture into system memory. Note that the parameters must match the ones that you used to set up the texture when you called the function  <code><!--a-->glTexImage2D<!--/a--></code>. This call is the synchronization point; it waits until the transfer is finished. </p></li></ul><p><span class="content_text">Listing 9-6</span> shows a code fragment that downloads a rectangular texture that uses cached memory. Your application processes data between the <code>glCopyTexSubImage2D</code> and <code><!--a-->glGetTexImage<!--/a--></code> calls. How much processing? Enough so that your application does not need to wait for the GPU.</p><a name="//apple_ref/doc/uid/TP40001987-CH407-SW8" title="Listing 9-6Code that downloads texture data "></a><p class="codesample"><strong>Listing 9-6&nbsp;&nbsp;</strong>Code that downloads texture data </p><div class="codesample"><table><tr><td scope="row"><pre>glBindTexture(GL_TEXTURE_RECTANGLE_ARB, myTextureName);<span></span></pre></td></tr><tr><td scope="row"><pre>glTexParameteri(GL_TEXTURE_RECTANGLE_ARB, GL_TEXTURE_STORAGE_HINT_APPLE,<span></span></pre></td></tr><tr><td scope="row"><pre>                GL_STORAGE_SHARED_APPLE);<span></span></pre></td></tr><tr><td scope="row"><pre>glPixelStorei(GL_UNPACK_CLIENT_STORAGE_APPLE, GL_TRUE);<span></span></pre></td></tr><tr><td scope="row"><pre>glTexImage2D(GL_TEXTURE_RECTANGLE_ARB, 0, GL_RGBA,<span></span></pre></td></tr><tr><td scope="row"><pre>                sizex, sizey, GL_BGRA,<span></span></pre></td></tr><tr><td scope="row"><pre>                GL_UNSIGNED_INT_8_8_8_8_REV, myImagePtr);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>glCopyTexSubImage2D(GL_TEXTURE_RECTANGLE_ARB,<span></span></pre></td></tr><tr><td scope="row"><pre>                0, 0, 0, 0, 0, image_width, image_height);<span></span></pre></td></tr><tr><td scope="row"><pre>glFlush();<span></span></pre></td></tr><tr><td scope="row"><pre>// Do other work processing here, using a double or triple buffer<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>glGetTexImage(GL_TEXTURE_RECTANGLE_ARB, 0, GL_BGRA,<span></span></pre></td></tr><tr><td scope="row"><pre>                GL_UNSIGNED_INT_8_8_8_8_REV, pixels);<span></span></pre></td></tr></table></div><p></p><a name="//apple_ref/doc/uid/TP40001987-CH407-SW16" title="Double Buffering Texture Data"></a><h2>Double Buffering Texture Data</h2><p>When you use any technique that allows the GPU to access your texture data directly, such as the texture range extension, it's possible for the GPU and CPU to access the data at the same time. To avoid such a collision, you must synchronize the GPU and the CPU. The simplest way is shown in <span class="content_text">Figure 9-10</span>. Your application works on the data, flushes it to the GPU and waits until the GPU is finished before working on the data again. </p><p>One technique for ensuring that the GPU is finished executing commands before your application sends more data is to insert a token into the command stream and use that to determine when the CPU can touch the data again, as described in <span class="content_text"><a href="../opengl_vertexdata/opengl_vertexdata.html#//apple_ref/doc/uid/TP40001987-CH406-SW1">“Fence Extension.”</a></span> <span class="content_text">Figure 9-10</span> uses the fence extension command <code>glFinishObject</code> to synchronize buffer updates for a stream of single-buffered texture data. Notice that when the CPU is processing texture data, the GPU is idle. Similarly, when the GPU is processing texture data, the CPU is idle. It's much more efficient for the GPU and CPU to work asynchronously than to work synchronously. Double buffering data is a technique that allows you to process data asynchronously, as shown in <span class="content_text"><a href="opengl_texturedata.html#//apple_ref/doc/uid/TP40001987-CH407-SW20">Figure 9-11</a></span>.</p><br/><div><a name="//apple_ref/doc/uid/TP40001987-CH407-SW17" title="Figure 9-10Single-buffered data"></a><p><strong>Figure 9-10&nbsp;&nbsp;</strong>Single-buffered data</p><img src = "../art/single_buffering.jpg" alt = "Single-buffered data" ></div><br/><p>To double buffer data, you must supply two sets of data to work on. Note in <span class="content_text">Figure 9-11</span> that while the GPU is rendering one frame of data, the CPU processes the next. After the initial startup, neither processing unit is idle. Using the <code>glFinishObject</code> function provided by the fence extension ensures that buffer updating is synchronized. </p><br/><div><a name="//apple_ref/doc/uid/TP40001987-CH407-SW20" title="Figure 9-11Double-buffered data"></a><p><strong>Figure 9-11&nbsp;&nbsp;</strong>Double-buffered data</p><img src = "../art/double_buffering.jpg" alt = "Double-buffered data" ></div><br/><a name="//apple_ref/doc/uid/TP40001987-CH407-SW32" title="See Also"></a><h2>See Also</h2><p>OpenGL extension specifications:</p><ul class="ul"><li class="li"><p><span class="content_text"><a href="http://oss.sgi.com/projects/ogl-sample/registry/APPLE/client_storage.txt" target="_blank">APPLE_client_storage</a></span></p></li><li class="li"><p><span class="content_text"><a href="http://developer.apple.com/graphicsimaging/opengl/extensions/apple_texture_range.html" target="_top">APPLE_texture_range</a></span></p></li><li class="li"><p><span class="content_text"><a href="http://oss.sgi.com/projects/ogl-sample/registry/ARB/texture_rectangle.txt" target="_blank">ARB_texture_rectangle</a></span></p></li><li class="li"><p><span class="content_text"><a href="http://oss.sgi.com/projects/ogl-sample/registry/ARB/texture_non_power_of_two.txt" target="_blank">ARB_texture_non_power_of_two</a></span></p></li></ul><p>OpenGL sample code projects (<span class="content_text"><a href="../../../../../samplecode/GraphicsImaging/idxOpenGL-date.html#//apple_ref/doc/uid/TP30000925-TP30000424-TP30000549" target="_top">Sample Code > Graphics &amp; Imaging > OpenGL</a></span>):</p><ul class="ul"><li class="li"><p><em><a href="../../../../../samplecode/OpenGL_Image/index.html#//apple_ref/doc/uid/DTS10000538" target="_top">OpenGL Image</a></em> segments a rectangular image into several power-of-two textures and shows how to use OpenGL for high performance image display.</p></li><li class="li"><p><em><a href="../../../../../samplecode/QuartzComposerTexture/index.html#//apple_ref/doc/uid/DTS10003649" target="_top">Quartz Composer Texture</a></em> shows how to use the <code>QCRenderer</code> class to render a Quartz Composer composition into an OpenGL pixel buffer, create a texture from it, and use the texture in an OpenGL scene.</p></li><li class="li"><p><em><a href="../../../../../samplecode/TexturePerformanceDemo/index.html#//apple_ref/doc/uid/DTS10003725" target="_top">TexturePerformanceDemo</a></em> provides code that uploads textures using two different ways, one of which is more optimized than the other.</p></li><li class="li"><p><em><a href="../../../../../samplecode/TextureRange/index.html#//apple_ref/doc/uid/DTS10000551" target="_top">TextureRange</a></em> shows how to use various OpenGL extensions to optimize uploading texture data.</p></li><li class="li"><p><em><a href="../../../../../samplecode/NSGLImage/index.html#//apple_ref/doc/uid/DTS10003451" target="_top">NSGLImage</a></em> demonstrates  how to use the <code>NSImage</code> and <code>NSBitmapImageRep</code> classes for texturing.</p></li></ul><p>More information on the Quartz API and how to use Quartz:</p><ul class="ul"><li class="li"><p><em><a href="../../../Reference/CGImageSource/index.html#//apple_ref/doc/uid/TP40001399" target="_top">CGImageSource Reference</a></em> describes the <code>CGImageSourceRef</code> data type and the functions that operate on it.</p></li><li class="li"><p><em><a href="../../../Reference/CGColorSpace/index.html#//apple_ref/doc/uid/TP30000949" target="_top">CGColorSpace Reference</a></em> describes the <code>CGColorSpaceRef</code> data type and the functions that operate on it.</p></li><li class="li"><p><em><a href="../../drawingwithquartz2d/index.html#//apple_ref/doc/uid/TP30001066" target="_top">Quartz 2D Programming Guide</a></em> describes how to write code that uses all the Quartz data types, including the <code>CGImageSourceRef</code> and <code>CGColorSpaceRef</code> data types.</p></li></ul>

        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../opengl_vertexdata/opengl_vertexdata.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../opengl_fsaa/opengl_fsaa.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2004, 2008 Apple Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2008-06-09<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/GraphicsImaging/Conceptual/OpenGL-MacProgGuide/opengl_texturedata/opengl_texturedata.html%3Fid%3DTP40001987-3.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/GraphicsImaging/Conceptual/OpenGL-MacProgGuide/opengl_texturedata/opengl_texturedata.html%3Fid%3DTP40001987-3.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/GraphicsImaging/Conceptual/OpenGL-MacProgGuide/opengl_texturedata/opengl_texturedata.html%3Fid%3DTP40001987-3.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>