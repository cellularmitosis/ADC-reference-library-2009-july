<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>ProcDoggie - /UEvents.p</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../samplecode/LegacyTechnologies/idxCarbon-date.html">Carbon</a> &gt; <A HREF="javascript:location.replace('index.html');">ProcDoggie</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/Carbon/idxProcessManagement-date.html" target="_blank">Carbon > Process Management</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">ProcDoggie</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/UEvents.p</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/ProcDoggie.p</option>
<option value="listing2.html">/StubLDEF/StubLDEF.p</option>
<option value="listing3.html">/UDialogUtils.p</option>
<option value="listing4.html">/UEmergMem.p</option>
<option value="listing5.html">/UEvents.p</option>
<option value="listing6.html">/UGlobals.p</option>
<option value="listing7.html">/UMenuHandler.p</option>
<option value="listing8.html">/UProcessGuts.p</option>
<option value="listing9.html">/UProcessLDEF.p</option>
<option value="listing10.html">/UProcessUtils.p</option></select>
				</p>
				</form>
				<p><strong><a href="ProcDoggie.zip">Download Sample</a></strong> (&#147;ProcDoggie.zip&#148;, 94.4K)<BR>
<strong><a href="ProcDoggie.dmg">Download Sample</a></strong> (&#147;ProcDoggie.dmg&#148;, 163.0K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">{  File:    UEvents.p  Contains:  This file is responsible for responding to events.  The main event loop        in ProcDoggie.p and calls the DoEvent routine for each event it gets.  Written by: Forrest Tanaka    Copyright:  Copyright &copy; 1988-1999 by Apple Computer, Inc., All Rights Reserved.        You may incorporate this Apple sample source code into your program(s) without        restriction. This Apple sample source code has been provided &quot;AS IS&quot; and the        responsibility for its operation is yours. You are not permitted to redistribute        this Apple sample source code as &quot;Apple sample source code&quot; after having made        changes. If you're going to re-distribute the source, we require that you make        it clear in the source that the code was descended from Apple sample source        code, but that you've made changes.  Change History (most recent first):        7/27/1999  Karl Groethe  Updated for Metrowerks Codewarror Pro 2.1        }UNIT UEvents;{[j=20/57/1$] Pasmat Options}INTERFACE  USES    Events;  PROCEDURE DoEvent(anEvent: EventRecord);IMPLEMENTATION  (******************************************************************************** Used Units*******************************************************************************)  USES    AppleEvents    ,Fonts    ,ToolUtils    ,DiskInit    ,SegLoad    ,GestaltEqu        (* Application *)    ,UGlobals    ,UEmergMem    ,UProcessUtils    ,UMenuHandler    ,UProcessGuts    ;(******************************************************************************** Constants*******************************************************************************)  CONST    kBecomingActive = TRUE; {Pass to DoActivateEvt; indicates becoming active}{$S Main}(******************************************************************************** Public: DoWindowDrag** A rectangle that covers all screen can be retrieved from the desktop region's* rgnBBox.  The desktop region can be retrieved by calling GetGrayRgn.*******************************************************************************)  PROCEDURE DoWindowDrag (anEvent:       EventRecord;                          clickedWindow: WindowPtr);    VAR      dragBounds: Rect; {Window can be dragged over this rectangle}  BEGIN    (* GetGrayRgn^^.rgnBBox covers the desktop over all screens *)    dragBounds := GetGrayRgn^^.rgnBBox;    DragWindow (clickedWindow, anEvent.where, dragBounds)  END;{$S Main}(******************************************************************************** Public: DoContentClick** As new kinds of windows are added to this application, this routine will have* to be able to detect the new kind of window and dispatch to the routine that* handles clicks in that kind of window.*******************************************************************************)  PROCEDURE DoContentClick (anEvent:       EventRecord;                            clickedWindow: WindowPtr);    VAR      currWindow: WindowPtr; {Pointer to the current front window}  BEGIN    currWindow := FrontWindow;    (* Clicked window not in front; activate it *)    IF currWindow &lt;&gt; clickedWindow THEN      SelectWindow (clickedWindow)    ELSE      IF IsProcessListWindow (clickedWindow) THEN        ClickProcessListWindow (clickedWindow, anEvent)  END;{$S Main}(******************************************************************************** Public: DoUpdateEvt** As new kinds of windows are added to this application, this routine will have* to be able to detect the new kind of window and dispatch to the routine that* handles update events in that kind of window.*******************************************************************************)  PROCEDURE DoUpdateEvt (anEvent: EventRecord);    VAR      eventWindow: WindowPtr; {Pointer to the window to update}  BEGIN    eventWindow := WindowPtr(anEvent.message);    (* Update the window that needs it *)    SetPort (eventWindow);    BeginUpdate (eventWindow);    IF IsProcessListWindow (eventWindow) THEN      DrawProcessListWindow (eventWindow)    ELSE IF IsProcessInfoWindow (eventWindow) THEN      DrawProcessInfoWindow (eventWindow);    EndUpdate (eventWindow)  END;{$S Main}(******************************************************************************** Public: DoActivateEvt** As new kinds of windows are added to this application, this routine will have* to be able to detect the new kind of window and dispatch to the routine that* handles activate events in that kind of window.*******************************************************************************)  PROCEDURE DoActivateEvt (eventWind:      WindowPtr;                           becomingActive: Boolean);  BEGIN    IF IsProcessListWindow (eventWind) THEN      ActivateProcessListWindow (eventWind, becomingActive);  END;{$S Main}(******************************************************************************** DoMouseDown - Mouse-down event dispatcher** When a mouseDown event is received in the main event loop, this routine is* called to determine which area on the screens the mouseDown was, and to* dispatch to the appropriate routine to handle mouseDown events in that area.* The mouseDown event is passed in the anEvent parameter.** See the UMenuHandler unit for routines that handle mouse-down events in the* menu bar, and the UWindowHandler unit for routines that handle mouse-down* events in the windows.*******************************************************************************)  PROCEDURE DoMouseDown (anEvent: EventRecord);    VAR      clickArea: Integer;   {Area of the screen that was clicked}      eventWind: WindowPtr; {Pointer the clicked window, if any}  BEGIN    (* Find clicked area of screen or window *)    clickArea := FindWindow (anEvent.where, (*&lt;*)eventWind);    (* Jump to mouseDown-handling routine appropriate for screen area *)    CASE clickArea OF      inMenuBar:        DoMenuChoice (MenuSelect (anEvent.where));      inContent:        DoContentClick (anEvent, eventWind);      inGoAway:        IF TrackGoAway (eventWind, anEvent.where) THEN          DoWindowClose (eventWind);      inDrag:        DoWindowDrag (anEvent, eventWind)      OTHERWISE        (* do nothing *) ;    END  END;{$S Main}(******************************************************************************** DoKeyDown - Key-down event dispatcher** When a keyDown or autoKey event is received in the main event loop, this* routine is called to determine whether key is a command-key equivalent for a* menu item or not.  If the command key isn't down, then the key stroke is* ignored.  Otherwise, MenuKey is called to get the menu ID and item number* of the menu item that corresponds to the command key, if any.  Then* DoMenuChoice is called to dispatch to the appropriate routine for the chosen* menu item.  The keyDown or autoKey event is passed in anEvent.** See the UMenuHandler unit for routines that handle menu events.*******************************************************************************)  PROCEDURE DoKeyDown (anEvent: EventRecord);    VAR      theKey: Char; {ASCII code of key that was pressed}  BEGIN    (* Get the ASCII code of the pressed key *)    theKey := CHR (BAND (anEvent.message, charCodeMask));    (* If anEvent was keyDown and command key was down, it's menu command *)    IF (anEvent.what = keyDown) AND (BAND (anEvent.modifiers, cmdKey) &lt;&gt; 0)        THEN      DoMenuChoice (MenuKey (theKey))  END;{$S Main}(******************************************************************************** DoDiskEvt - Handle a disk-insert event** This routine is called whenever this application receives an event indicating* that a disk was inserted.  If the disk can't be mounted, the message field of* the event reflects the error, and we call DIBadMount to allow the user to* format the disk.*******************************************************************************)  PROCEDURE DoDiskEvt (anEvent: EventRecord);    CONST      kSysAlertLeft = 80; {Left coord of DIBadMount alert in screen coords}      kSysAlertTop  = 80; {Top coord of DIBadMount alert in screen coords}    VAR      cornerPoint: Point; {Top-left corner of DIBadMount alert}      error:       OSErr;  BEGIN    IF HiWord (anEvent.message) &lt;&gt; noErr THEN      BEGIN        SetPt ((*&lt;*)cornerPoint, kSysAlertLeft, kSysAlertTop);        error := DIBadMount (cornerPoint, anEvent.message)      END  END;{$S Main}(******************************************************************************** Public: DoOSEvt** When an OS Event is received, it can be a suspend or resume event.*******************************************************************************)  PROCEDURE DoOSEvt (anEvent: EventRecord);    VAR      eventWindow: WindowPtr; {Pointer to window being activated/deactivated}      osEvtKind:   Byte;      {Kind of OSEvt; mouse-moved or suspend/resume}  BEGIN    (* Only care if anEvent is suspend/resume event *)    osEvtKind := BAND (BSR (anEvent.message, 24), $00FF);    IF osEvtKind = suspendResumeMessage THEN      BEGIN        (* It's a suspend/resume event; suspend or resume? *)        eventWindow := FrontWindow;        IF BAND (anEvent.message, 1) &lt;&gt; 0 THEN          BEGIN            (* Resume event; set the cursor and activate front window *)            InitCursor;            IF eventWindow &lt;&gt; NIL THEN              DoActivateEvt (eventWindow, kBecomingActive);          END        ELSE          BEGIN            (* Suspend event; deactivate the front window *)            IF eventWindow &lt;&gt; NIL THEN              DoActivateEvt (eventWindow, NOT kBecomingActive);          END      END  END;{$S Main}(******************************************************************************** DoHighLevelEvent - Handle a high-level event** This routine handles the high-level event specified by anEvent.  The only* high-level events that this application handles are AppleEvents, so I just* pass the high-level event to AEProcessAppleEvent.  AEProcessAppleEvent calls* the appropriate AppleEvent handler routine to handle that particular kind of* AppleEvent.*******************************************************************************)  PROCEDURE DoHighLevelEvent (anEvent: EventRecord);    VAR      error: OSErr;  BEGIN    error := AEProcessAppleEvent (anEvent);  END;{$S Main}(******************************************************************************** DoEvent - Do an event from the main event loop, and elsewhere.********************************************************************************)  PROCEDURE DoEvent(anEvent: EventRecord);  BEGIN    CASE anEvent.what OF      mouseDown:        DoMouseDown (anEvent);      keyDown, autoKey:        DoKeyDown (anEvent);      updateEvt:        DoUpdateEvt (anEvent);      diskEvt:        DoDiskEvt (anEvent);      activateEvt:        DoActivateEvt (WindowPtr(anEvent.message),            BAND (anEvent.modifiers, activeFlag) &lt;&gt; 0);      osEvt:        DoOSEvt (anEvent);      kHighLevelEvent:        DoHighLevelEvent (anEvent)      OTHERWISE        (* do nothing *) ;    END  END;END.</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/ProcDoggie/listing5.html%3Fid%3DDTS10000315-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/ProcDoggie/listing5.html%3Fid%3DDTS10000315-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/ProcDoggie/listing5.html%3Fid%3DDTS10000315-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>