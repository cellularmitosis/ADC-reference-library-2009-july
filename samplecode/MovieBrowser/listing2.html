<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>MovieBrowser - /MovieBrowser.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/QuickTime/index.html">QuickTime</a> &gt; <a href="../../samplecode/QuickTime/idxMovieBasics-date.html">Movie Basics</a> &gt; <A HREF="javascript:location.replace('index.html');">MovieBrowser</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">MovieBrowser</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/MovieBrowser.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/BrowserMaker.c</option>
<option value="listing2.html">/MovieBrowser.c</option></select>
				</p>
				</form>
				<p><strong><a href="MovieBrowser.zip">Download Sample</a></strong> (&#147;MovieBrowser.zip&#148;, 14.2K)<BR>
<strong><a href="MovieBrowser.dmg">Download Sample</a></strong> (&#147;MovieBrowser.dmg&#148;, 72.4K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/*  File:    MovieBrowser.c  Written by:  Peter Hoddie  Copyright:  &copy; 1992-1994 by Apple Computer, Inc., all rights reserved.    Change History (most recent first):  &lt;1&gt;     12/8/94    khs    changed the format of the file to the new look and feel*/// INCLUDES#include &lt;Aliases.h&gt;#include &lt;AppleEvents.h&gt;#include &lt;Dialogs.h&gt;#include &lt;Errors.h&gt;#include &lt;Events.h&gt;#include &lt;Memory.h&gt;#include &lt;Movies.h&gt;#include &lt;ToolUtils.h&gt;#include &lt;LowMem.h&gt;#include &lt;SegLoad.h&gt;#include &lt;Fonts.h&gt;#include &lt;GestaltEqu.h&gt;#include &lt;Devices.h&gt;#include &lt;Resources.h&gt;// STRUCTUREStypedef struct Document {  WindowPtr      w;  Movie        m;  MovieController    mc;  short        page;  short        pageCount;  short        curResID;  short        resRef;  Track        firstTextTrack;  FSSpec        fss;  Rect        movieArea;  Rect        scrollArea;  Boolean        noButtons;  Boolean        showController;  Rect        sprocketsRectTop;  Rect        sprocketsRectBottom;  Rect        scrollAndSprocketsArea;  long        scrollOffset;  long        scrollPhaseShift;  RGBColor      backgroundColor;  Rect        thumbnailSize;  TimeValue      **lastMovieTime;  Handle        names;  PicHandle      titleBackground;  Rect        titleRect;  Rect        titleArea;  Str255        movieName;  Point        titlePlace;  short        lastPageClick;  unsigned long    lastPageClickTime;} Document, *DocumentPtr;typedef long (*DocFunction)(DocumentPtr d, void *refCon);// FUNCTION PROTOTYPESvoid doAnAlert(StringPtr s, short err);void colorMenus(void);Boolean doMenuItem(long selection);void DoContentClick(DocumentPtr d, Point where, unsigned long clickTime);DocumentPtr OpenDocument(FSSpec *fss);void CloseDocument(DocumentPtr d);void GoToPage(DocumentPtr d, short pageNum);DocumentPtr GetWindowDocument(WindowPtr w);long ForEachDocument(DocFunction df, void *refCon);long TestOneEvent(DocumentPtr d, EventRecord *e);long IdleOneDocument(DocumentPtr d, void *refCon);PicHandle GetArrow(DocumentPtr d, Boolean right, Rect *bounds);void GetScrollArea(DocumentPtr d, Rect *bounds);void ActivateDocument(DocumentPtr d);void UpdateDocument(DocumentPtr d);void OpenFinderDocs(void);OSErr MissedAEParameters (AppleEvent *message);pascal OSErr OpenDocMessage(AppleEvent *message, AppleEvent *reply, long refcon);pascal OSErr QuitAppMessage(AppleEvent *message, AppleEvent *reply, long refcon);// GLOBALSshort gAppResFile;Boolean gDone = false;GWorldPtr gSprockets = 0;Str255 gLastSearchText;unsigned long gLastWNETime;Boolean gInBackground = false;long gSysVersion = 0;// DEFINES// don't give the system too much time...#define kWNEInterval (90)#define kBetweenThumbSize (2)// FUNCTIONSvoid doAnAlert(StringPtr s, short err){  Str31 s1;  NumToString(err, s1);  ParamText(s, err ? s1 : 0, 0, 0);  Alert(128, 0);}void colorMenus(void){  MenuHandle mh;  short count, i;  DocumentPtr d = GetWindowDocument(FrontWindow());  mh = GetMHandle(129);  DisableItem(mh, 2);  if (FrontWindow()) EnableItem(mh, 2);  mh = GetMHandle(130);  count = CountMItems(mh);  for (i = 1; i &lt;= count; i++)    CheckItem(mh, i, d &amp;&amp; (i == (d-&gt;page + 1)));  mh = GetMHandle(131);  DisableItem(mh, 1);  DisableItem(mh, 3);  DisableItem(mh, 4);  DisableItem(mh, 5);  DisableItem(mh, 6);  DisableItem(mh, 8);  DisableItem(mh, 9);  DisableItem(mh, 11);  if (d) {    if (d-&gt;firstTextTrack) {      EnableItem(mh, 8);      if (gLastSearchText[0])        EnableItem(mh, 9);    }    if (d-&gt;m)      EnableItem(mh, 4);    EnableItem(mh, 11);    CheckItem(mh, 11, d-&gt;showController);  }  }Boolean doMenuItem(long selection){  short menu = HiWord(selection);  short item = LoWord(selection);  Boolean done = false;  DocumentPtr d = GetWindowDocument(FrontWindow());  switch (menu) {    case 128:      if (item &gt; 2) {        Str255 daName;        GetItem(GetMHandle(128), item, daName);        OpenDeskAcc(daName);      }      else {        short item = 0;        short saveRes = CurResFile();        DialogPtr d;        short kind;        Handle h;        Rect r;                UseResFile(gAppResFile);        d = GetNewDialog(129, nil, (WindowPtr)-1);        SetPort(d);        GetDItem(d, 1, &amp;kind, &amp;h, &amp;r);        PenSize(3,3);        InsetRect(&amp;r,-4,-4);        FrameRoundRect(&amp;r,16,16);        while (d &amp;&amp; (item != 1))          ModalDialog(nil, &amp;item);        UseResFile(saveRes);        if (d) DisposDialog(d);      }      break;    case 129:      switch (item) {        case 1:  {            StandardFileReply reply;            OSType docType = 'Dal\x92';                        StandardGetFilePreview(nil, 1, &amp;docType, &amp;reply);            if (reply.sfGood)              OpenDocument(&amp;reply.sfFile);            }            break;        case 2:  CloseDocument(d);            break;        case 4:  done = true;            break;      }      break;    case 130:      GoToPage(GetWindowDocument(FrontWindow()), item - 1);      break;    case 131:      switch (item) {        case 4:  if (d &amp;&amp; d-&gt;m)              PutMovieOnScrap(d-&gt;m, DoTheRightThing);            break;        case 8:  {            DialogPtr dlg = GetNewDialog(130, nil, (WindowPtr)-1);            short kind;            Handle h;            Rect r;            short item = 0;            Str255 str;            ModalFilterProcPtr filter = nil;            if (!dlg) break;            // set up some dialog manager slime if not System 7            if (gSysVersion &lt; 7 ) {              SetDialogDefaultItem(dlg, 1);              SetDialogCancelItem(dlg, 2);              SetDialogTracksCursor(dlg, true);              GetStdFilterProc(&amp;filter);            }            GetDItem(dlg, 4, &amp;kind, &amp;h, &amp;r);            SetIText(h, gLastSearchText);            SelIText(dlg, 4, 0, 32767);            while ((item != 1) &amp;&amp; (item != 2))              ModalDialog(filter, &amp;item);            GetIText(h, str);            DisposDialog(dlg);            if (item == 1 &amp;&amp; str[0]) {              BlockMove(str, gLastSearchText, sizeof(gLastSearchText));              goto doSearch;            }            break;          }          case 9:  {            TimeValue newTime;            OSErr err;            MediaHandler textHandler;            long textOffset;doSearch:            // text media handler really wants lower case letters, so make sure it gets 'em            if (gSysVersion &gt;= 7)              LowerText((Ptr)&amp;gLastSearchText[1], gLastSearchText[0]);            else {              short i = 0;              while (i++ &lt;= gLastSearchText[0]) {                char c = gLastSearchText[i];                if ((c &gt;= 'A') &amp;&amp; (c &lt;= 'Z'))                  gLastSearchText[i] -= 32;              }            }            textHandler = GetMediaHandler(GetTrackMedia(d-&gt;firstTextTrack));            err = FindNextText(textHandler, (Ptr)&amp;gLastSearchText[1], gLastSearchText[0],                findTextWrapAround, GetMovieTime(d-&gt;m, nil),                &amp;newTime, nil, &amp;textOffset);            if (!err &amp;&amp; (newTime != -1)) {              TimeRecord tr;              RGBColor rgb;                            tr.value.lo = newTime;              tr.value.hi = 0;              tr.scale = GetMovieTimeScale(d-&gt;m);              tr.base = 0;              MCDoAction(d-&gt;mc, mcActionGoToTime, &amp;tr);              rgb = (**((GrafVars **)((CGrafPtr)d-&gt;w)-&gt;grafVars)).rgbHiliteColor;              HiliteTextSample(textHandler, newTime, textOffset,                textOffset + gLastSearchText[0], &amp;rgb);            }            else              SysBeep(1);          }          break;          case 11: {            d-&gt;showController = !d-&gt;showController;            MCSetVisible(d-&gt;mc, d-&gt;showController);            break;          }          break;      }  }  HiliteMenu(0);  return done;}DocumentPtr OpenDocument(FSSpec *fss){  OSErr err;  DocumentPtr d;  Rect r;  Point center;  short resID;  Handle h;  d = (DocumentPtr)NewPtrClear(sizeof(Document));  err = MemError();  if (err != noErr) goto bail;  d-&gt;fss = *fss;  d-&gt;resRef = FSpOpenResFile(fss, fsRdPerm);  if ((d-&gt;resRef == -1) || ResError()) {    err = resNotFound;    d-&gt;resRef = 0;    goto bail;  }  d-&gt;lastPageClick = -1;  d-&gt;names = NewHandle(0);  // count the pages, and rememeber their names  resID = 128;  SetResLoad(false);  do {    Handle r;    short id;    OSType rt;    Str255 name;    r = Get1Resource(rAliasType, resID++);    if (r != NULL)      d-&gt;pageCount++;    else      break;    // remember the name    GetResInfo(r, &amp;id, &amp;rt, name);    PtrAndHand(name, d-&gt;names, name[0] + 1);    err = MemError();    if (err != noErr) goto bail;  } while (true);  SetResLoad(true);  // make the window  d-&gt;w = GetNewCWindow(128, nil, (WindowPtr)-1);  if (!d-&gt;w) {    err = memFullErr;    goto bail;  }  SetWTitle(d-&gt;w, fss-&gt;name);  TextFont(GetSysFont());  // get back color  h = Get1Resource('RGB ', 128);  if (h != NULL) {    d-&gt;backgroundColor = **(RGBColor **)h;    ReleaseResource(h);  }  else {    short saveRes = CurResFile();    UseResFile(gAppResFile);      d-&gt;backgroundColor = **(RGBColor **)Get1Resource('RGB ', 128);    UseResFile(saveRes);  }  // pick up first thumbnail pict for measurement  h = Get1Resource('PICT', 128);  if (!h) {    err = resNotFound;    goto bail;  }  d-&gt;thumbnailSize = (**(PicHandle)h).picFrame;  OffsetRect(&amp;d-&gt;thumbnailSize, -d-&gt;thumbnailSize.left, -d-&gt;thumbnailSize.top);  d-&gt;thumbnailSize.right += kBetweenThumbSize;  // show a controller?  d-&gt;showController = false;  h = Get1Resource('MCmc', 128);  if (h) {    d-&gt;showController = **h;    ReleaseResource(h);  }  // make page time table  d-&gt;lastMovieTime = (TimeValue **)NewHandleClear(d-&gt;pageCount * sizeof(TimeValue));  err = MemError();  if (err != noErr) goto bail;  d-&gt;movieArea = **(Rect **)GetResource('RECT', 128);  ReleaseResource(GetResource('RECT', 128));  OffsetRect(&amp;d-&gt;movieArea, -d-&gt;movieArea.left, -d-&gt;movieArea.top);  // figure out what to use for title background  d-&gt;titleBackground = (PicHandle)Get1Resource('PICT', 1048);  if (!d-&gt;titleBackground) {    short saveRes = CurResFile();    UseResFile(gAppResFile);      d-&gt;titleBackground = (PicHandle)GetPicture(1048);    UseResFile(saveRes);  }  LoadResource((Handle)d-&gt;titleBackground);  r = (**d-&gt;titleBackground).picFrame;  OffsetRect(&amp;r, -r.left, -r.top);  OffsetRect(&amp;r, (d-&gt;movieArea.right / 2) - (r.right / 2), 0);  d-&gt;titleRect = r;  OffsetRect(&amp;d-&gt;titleRect, 0, (d-&gt;titleRect.bottom - d-&gt;titleRect.top) / 3);  InsetRect(&amp;r, 0, -((d-&gt;titleRect.bottom - d-&gt;titleRect.top) / 3));  d-&gt;titleArea = r;  OffsetRect(&amp;d-&gt;movieArea, 0, d-&gt;titleArea.bottom);  SizeWindow(d-&gt;w, d-&gt;movieArea.right,    d-&gt;movieArea.bottom + d-&gt;thumbnailSize.bottom + (gSprockets-&gt;portRect.bottom * 2), false);  // figure out how to keep things centered  GetScrollArea(d, &amp;r);  d-&gt;scrollArea = r;  OffsetRect(&amp;r, -r.left, -r.top);  d-&gt;scrollPhaseShift = (d-&gt;thumbnailSize.right) - (r.right % d-&gt;thumbnailSize.right)/2;  // calculate sprockets rect  d-&gt;sprocketsRectTop = d-&gt;scrollArea;  d-&gt;sprocketsRectTop.bottom = d-&gt;scrollArea.top;  d-&gt;sprocketsRectTop.top -= gSprockets-&gt;portRect.bottom;  d-&gt;sprocketsRectBottom = d-&gt;scrollArea;  d-&gt;sprocketsRectBottom.top = d-&gt;scrollArea.bottom;  d-&gt;sprocketsRectBottom.bottom += gSprockets-&gt;portRect.bottom;  UnionRect(&amp;d-&gt;scrollArea, &amp;d-&gt;sprocketsRectTop, &amp;d-&gt;scrollAndSprocketsArea);  UnionRect(&amp;d-&gt;sprocketsRectBottom, &amp;d-&gt;scrollAndSprocketsArea, &amp;d-&gt;scrollAndSprocketsArea);  SetWRefCon(d-&gt;w, (long)d);  SetPort(d-&gt;w);  r = d-&gt;w-&gt;portRect;  GetBestDeviceRect(nil, &amp;r);  if (r.top == 0) r.top += GetMBarHeight();  center.h = (r.left + r.right) &gt;&gt; 1;  center.v = (r.top + r.bottom) &gt;&gt; 1;  r.left = center.h - (d-&gt;w-&gt;portRect.right &gt;&gt; 1);  r.right = r.left + d-&gt;w-&gt;portRect.right;  r.top = center.v - (d-&gt;w-&gt;portRect.bottom &gt;&gt; 1);  r.bottom = r.top + d-&gt;w-&gt;portRect.bottom;  MoveWindow(d-&gt;w, r.left, r.top, false);  AlignWindow(d-&gt;w, false, &amp;d-&gt;movieArea, nil);  ShowWindow(d-&gt;w);  GoToPage(d, d-&gt;page);bail:  if (err) CloseDocument(d);  return d;}void CloseDocument(DocumentPtr d){  if (!d) return;  if (d-&gt;resRef) CloseResFile(d-&gt;resRef);  if (d-&gt;mc) DisposeMovieController(d-&gt;mc);  if (d-&gt;lastMovieTime) DisposHandle((Handle)d-&gt;lastMovieTime);  if (d-&gt;names) DisposHandle(d-&gt;names);  DisposeMovie(d-&gt;m);  if (d-&gt;w) DisposeWindow(d-&gt;w);  DisposPtr((Ptr)d);  ActivateDocument(0);        // clear out the movies menu}DocumentPtr GetWindowDocument(WindowPtr w){  if (!w) return nil;  if (((WindowPeek)w)-&gt;windowKind == userKind)    return (DocumentPtr)GetWRefCon(w);  else    return nil;}void GoToPage(DocumentPtr d, short pageNum){  OSErr err;  short resID;  Movie newMovie = nil;  Point where = {0,0};  Rect r;  short saveRes;  FSSpec movieFile;  Boolean whoCares;  short movieResRef;  AliasHandle alias;  RgnHandle rgn;  short trashID;  OSType trackType;  if (pageNum &lt; 0)    pageNum = d-&gt;pageCount - 1;  else    pageNum = pageNum % d-&gt;pageCount;   resID = pageNum + 128;  if (resID == d-&gt;curResID) return;  // resolve alias to the file  saveRes = CurResFile();  UseResFile(d-&gt;resRef);    alias = (AliasHandle)Get1Resource(rAliasType, resID);  UseResFile(saveRes);  if (!alias) return;  err = ResolveAlias((gSysVersion &gt;= 7) ? &amp;d-&gt;fss : 0, alias, &amp;movieFile, &amp;whoCares);  GetResInfo((Handle)alias, &amp;trashID, &amp;trackType, d-&gt;movieName);  ReleaseResource((Handle)alias);  if (err) return;  // get the movie  SetCursor(*GetCursor(watchCursor));  OpenMovieFile(&amp;movieFile, &amp;movieResRef, fsRdPerm);    SetPort(d-&gt;w);    RGBBackColor(&amp;d-&gt;backgroundColor);        // for erasing    err = NewMovieFromFile(&amp;newMovie, movieResRef, nil, nil,         newMovieActive, nil);    BackColor(whiteColor);  SetCursor(&amp;qd.arrow);  CloseMovieFile(movieResRef);  if (err) return;  // position new movie a little  GetMovieBox(newMovie, &amp;r);  OffsetRect(&amp;r, -r.left, -r.top);  SetMovieBox(newMovie, &amp;r);  // restore movie's previous time  SetMovieTimeValue(newMovie, (*d-&gt;lastMovieTime)[pageNum]);  // position movie in window  if (d-&gt;mc) {    TimeValue saveTime;    // invalidate the old one    rgn = MCGetWindowRgn(d-&gt;mc, d-&gt;w);    if (rgn) {      InvalRgn(rgn);      DisposeRgn(rgn);    }    // store the old movie's time    saveTime = GetMovieTime(d-&gt;m, nil);    (*d-&gt;lastMovieTime)[d-&gt;page] = saveTime;    SetMovieVolume(newMovie, GetMovieVolume(d-&gt;m));      // don't lose the volume setting    // change the movie on the controller    MCSetVisible(d-&gt;mc, false);      MCSetMovie(d-&gt;mc, newMovie, d-&gt;w, where);      MCPositionController(d-&gt;mc, &amp;d-&gt;movieArea, nil, 0);    if (d-&gt;showController)      MCSetVisible(d-&gt;mc, true);  }  else {    // create a new controller    d-&gt;mc = NewMovieController(newMovie, &amp;d-&gt;movieArea, d-&gt;showController ? 0 : mcNotVisible);    if (!d-&gt;mc) return;    MCDoAction(d-&gt;mc, mcActionSetKeysEnabled, (void *)true);  }  // update state  DisposeMovie(d-&gt;m);  d-&gt;m = newMovie;  d-&gt;curResID = resID;  d-&gt;page = pageNum;  // look for text  {  long trackCount, i;  d-&gt;firstTextTrack = nil;  trackCount = GetMovieTrackCount(d-&gt;m);  for (i=1; i&lt;=trackCount; i++) {    Track t = GetMovieIndTrack(d-&gt;m, i);    OSType mediaType;    GetMediaHandlerDescription(GetTrackMedia(t), &amp;mediaType, nil, nil);    if (mediaType == 'text') {      d-&gt;firstTextTrack = t;      break;    }  }  }  // invalidate the new one  rgn = MCGetWindowRgn(d-&gt;mc, d-&gt;w);  if (rgn) {    InvalRgn(rgn);    DisposeRgn(rgn);  }  // update the title variables  {  FontInfo fi;  short width;    InvalRect(&amp;d-&gt;titleRect);  GetFontInfo(&amp;fi);  width = StringWidth(d-&gt;movieName);  d-&gt;titlePlace.h = ((d-&gt;titleRect.right + d-&gt;titleRect.left) / 2) - (width / 2);  d-&gt;titlePlace.v = ((d-&gt;titleRect.top + d-&gt;titleRect.bottom) / 2) + (fi.ascent / 2);  }}void DoContentClick(DocumentPtr d, Point where, unsigned long clickTime){  Rect r;  short scrollValue = 0;  unsigned long lastTicks = TickCount();  long delayTime = 15;  Rect mustRect = d-&gt;w-&gt;portRect;  PicHandle showPict = nil, restorePict = nil;  if (!d) return;  SetPort(d-&gt;w);  GlobalToLocal(&amp;where);tryAgain:  // try left arrow  GetArrow(d, false, &amp;r);  if (PtInRect(where, &amp;r) &amp;&amp; PtInRect(where, &amp;mustRect)) {    // go left    if (d-&gt;scrollOffset != 0)      d-&gt;scrollOffset--;    else      d-&gt;scrollOffset = d-&gt;pageCount - 1;    scrollValue = +1;    mustRect = r;    restorePict = GetPicture(1024);    showPict = GetPicture(1026);    d-&gt;lastPageClick = -1;    goto gotHit;  }  // try right arrow  GetArrow(d, true, &amp;r);  if (PtInRect(where, &amp;r) &amp;&amp; PtInRect(where, &amp;mustRect)) {    // go right    if (d-&gt;scrollOffset != (d-&gt;pageCount - 1))      d-&gt;scrollOffset++;    else      d-&gt;scrollOffset = 0;    scrollValue = -1;    mustRect = r;    restorePict = GetPicture(1025);    showPict = GetPicture(1027);    goto gotHit;  }  r = d-&gt;scrollArea;  if (PtInRect(where, &amp;r) &amp;&amp; PtInRect(where, &amp;mustRect)) {    // clicked on an image    short internalOffset = (where.h - r.left + d-&gt;scrollPhaseShift) / d-&gt;thumbnailSize.right;    Boolean wasIn, inRect;    Rect clipRect;    r = d-&gt;scrollArea;    ClipRect(&amp;r);    clipRect = r;    r.right = r.left + d-&gt;thumbnailSize.right;    OffsetRect(&amp;r, internalOffset * d-&gt;thumbnailSize.right, 0);    OffsetRect(&amp;r, -d-&gt;scrollPhaseShift, 0);    PenMode(patXor);    PenPat((ConstPatternParam)&amp;qd.gray);    PenSize(3, 3);    FrameRect(&amp;r);    wasIn = true;    while (StillDown()) {      GetMouse(&amp;where);      inRect = PtInRect(where, &amp;r);      if (inRect != wasIn) {        FrameRect(&amp;r);        wasIn = inRect;      }      ClipRect(&amp;d-&gt;w-&gt;portRect);        ForEachDocument(IdleOneDocument, nil);      ClipRect(&amp;clipRect);    }    if (wasIn) FrameRect(&amp;r);    PenNormal();    ClipRect(&amp;d-&gt;w-&gt;portRect);    if (wasIn) {      short newPage = (d-&gt;scrollOffset + internalOffset) % d-&gt;pageCount;      SInt32 dTime = LMGetDoubleTime();            if (   (  d-&gt;lastPageClick == newPage) &amp;&amp;           ( (d-&gt;lastPageClickTime + dTime) &gt;= clickTime)          ) {        Fixed curRate;        MCDoAction(d-&gt;mc, mcActionGetPlayRate, &amp;curRate);        if (!curRate) {          EventRecord whoCares;          TimeValue t = GetMovieTime(d-&gt;m, nil);          TimeValue movieDur = GetMovieDuration(d-&gt;m);          Fixed preferredRate = GetMoviePreferredRate(d-&gt;m);          if (t == movieDur) t = 0;          PrerollMovie(d-&gt;m, t, preferredRate);          EventAvail(0, &amp;whoCares);          EventAvail(0, &amp;whoCares);          EventAvail(0, &amp;whoCares);          UpdateDocument(d);          MCIdle(d-&gt;mc);          MCIdle(d-&gt;mc);          MCIdle(d-&gt;mc);          MCDoAction(d-&gt;mc, mcActionPlay, (void *)preferredRate);        }        d-&gt;lastPageClick = -1;        d-&gt;lastPageClickTime += 500;      }      else {        if (newPage == d-&gt;page) {          MCDoAction(d-&gt;mc, mcActionPlay, (void *)0);          d-&gt;lastPageClick = newPage;        }        else {          GoToPage(d, newPage);          d-&gt;lastPageClick = newPage;        }      }      d-&gt;lastPageClickTime = clickTime;    }    r = mustRect;    goto gotHit;  }gotHit:  if (scrollValue) {    Rect r;    RgnHandle rgn;    if (showPict) DrawPicture(showPict, &amp;mustRect);    r = d-&gt;scrollArea;    rgn = NewRgn();    if (rgn != NULL) {      RGBBackColor(&amp;d-&gt;backgroundColor);        ScrollRect(&amp;r, d-&gt;thumbnailSize.right * scrollValue, 0, rgn);      BackColor(whiteColor);      InvalRgn(rgn);      DisposeRgn(rgn);      UpdateDocument(d);      ClipRect(&amp;d-&gt;w-&gt;portRect);      do {        ForEachDocument(IdleOneDocument, nil);      } while (StillDown() &amp;&amp; ((unsigned long)TickCount()) &lt; (lastTicks + delayTime));      if (StillDown()) {        lastTicks = TickCount();        GetMouse(&amp;where);        delayTime -= 3;        if (delayTime &lt; 0) delayTime = 0;        scrollValue = 0;        goto tryAgain;      }    }  }  if (restorePict) DrawPicture(restorePict, &amp;mustRect);}PicHandle GetArrow(DocumentPtr d, Boolean right, Rect *bounds){  PicHandle aPict;  Rect r;  if (d-&gt;noButtons) {    SetRect(bounds, 0, 0, 0, 0);    return GetPicture(1024);  }  if (!right) {    // left arrow    aPict = GetPicture(1024);    r = (**aPict).picFrame;    OffsetRect(&amp;r, -r.left + 5, -r.top);    OffsetRect(&amp;r, 0, d-&gt;w-&gt;portRect.bottom - r.bottom);  }  else {    // right arrow    aPict = GetPicture(1025);    r = (**aPict).picFrame;    OffsetRect(&amp;r, -r.left, -r.top);    OffsetRect(&amp;r, d-&gt;w-&gt;portRect.right - r.right - 5, d-&gt;w-&gt;portRect.bottom - r.bottom);  }  OffsetRect(&amp;r, 0, -(d-&gt;thumbnailSize.bottom/2) + (r.bottom - r.top)/2);  OffsetRect(&amp;r, 0, -(gSprockets-&gt;portRect.bottom * 3)/2);  if (bounds) *bounds = r;  return aPict;}void GetScrollArea(DocumentPtr d, Rect *bounds){  Rect r, r1, r2;  short bottom;  long maxWidth = (d-&gt;pageCount * d-&gt;thumbnailSize.right);  GetArrow(d, false, &amp;r1);  GetArrow(d, true, &amp;r2);  bottom = d-&gt;w-&gt;portRect.bottom - ((gSprockets-&gt;portRect.bottom * 3)/2);  SetRect(&amp;r, r1.right, bottom - d-&gt;thumbnailSize.bottom, r2.left, bottom);  InsetRect(&amp;r, 4, 0);  if ((r.right - r.left) &gt; maxWidth) {    // don't wrap    short center = (r1.right + r2.left) / 2;    r.right = r.left + maxWidth;    OffsetRect(&amp;r, -r.left + (center - (r.right - r.left)/2), 0);    d-&gt;noButtons = true;  }  *bounds = r;}void UpdateDocument(DocumentPtr d){  PicHandle aPict;  Rect r;  RgnHandle rgn = 0;  Rect scrollArea;  if (!d) return;  if (d-&gt;mc)    rgn = MCGetWindowRgn(d-&gt;mc, d-&gt;w);  scrollArea = d-&gt;scrollArea;  BeginUpdate(d-&gt;w);    SetPort(d-&gt;w);    ClipRect(&amp;d-&gt;w-&gt;portRect);    if (rgn) {      DiffRgn(d-&gt;w-&gt;clipRgn, rgn, d-&gt;w-&gt;clipRgn);      RectRgn(rgn, &amp;d-&gt;scrollAndSprocketsArea);      DiffRgn(d-&gt;w-&gt;clipRgn, rgn, d-&gt;w-&gt;clipRgn);      RectRgn(rgn, &amp;d-&gt;titleRect);      DiffRgn(d-&gt;w-&gt;clipRgn, rgn, d-&gt;w-&gt;clipRgn);    }    RGBForeColor(&amp;d-&gt;backgroundColor);      PaintRect(&amp;d-&gt;w-&gt;portRect);    ForeColor(blackColor);    if (rgn)      UnionRgn(d-&gt;w-&gt;clipRgn, rgn, d-&gt;w-&gt;clipRgn);    // draw the title    LoadResource((Handle)d-&gt;titleBackground);    HNoPurge((Handle)d-&gt;titleBackground);      DrawPicture(d-&gt;titleBackground, &amp;d-&gt;titleRect);    HPurge((Handle)d-&gt;titleBackground);    MoveTo(d-&gt;titlePlace.h, d-&gt;titlePlace.v);    TextFont(GetSysFont());    DrawString(d-&gt;movieName);    // left arrow    aPict = GetArrow(d, false, &amp;r);    DrawPicture(aPict, &amp;r);    // right arrow    aPict = GetArrow(d, true, &amp;r);    DrawPicture(aPict, &amp;r);    // sprockets    {    Rect r1 = d-&gt;sprocketsRectTop;    Rect r2 = d-&gt;sprocketsRectBottom;    Rect clip;    short pageOffset;    UnionRect(&amp;r1, &amp;r2, &amp;clip);    ClipRect(&amp;clip);    pageOffset = d-&gt;scrollPhaseShift;    r1.left -= pageOffset;    r2.left = r1.left;    r1.right = r1.left + gSprockets-&gt;portRect.right;    r2.right = r1.right;    while (r1.left &lt; d-&gt;scrollArea.right) {      CopyBits((BitMap *)*gSprockets-&gt;portPixMap, &amp;d-&gt;w-&gt;portBits, &amp;gSprockets-&gt;portRect,          &amp;r1, srcCopy, nil);      CopyBits((BitMap *)*gSprockets-&gt;portPixMap, &amp;d-&gt;w-&gt;portBits, &amp;gSprockets-&gt;portRect,          &amp;r2, srcCopy, nil);      OffsetRect(&amp;r1, gSprockets-&gt;portRect.right, 0);      OffsetRect(&amp;r2, gSprockets-&gt;portRect.right, 0);    }    }    // thumbnails    {    short firstPage;    short resID;    Rect thumbRect;    short saveRes = CurResFile();    r = scrollArea;    ClipRect(&amp;r);    firstPage = d-&gt;scrollOffset;    resID = firstPage + 128;    thumbRect = r;    thumbRect.right = thumbRect.left + d-&gt;thumbnailSize.right;    OffsetRect(&amp;thumbRect, -d-&gt;scrollPhaseShift, 0);    UseResFile(d-&gt;resRef);    while (thumbRect.left &lt; r.right) {      Rect whoCares;      if ((resID - 128) &gt;= d-&gt;pageCount)        resID = 128;      if (SectRect(&amp;(**d-&gt;w-&gt;visRgn).rgnBBox, &amp;thumbRect, &amp;whoCares)) {        PicHandle p = GetPicture(resID);        MoveTo(thumbRect.left, thumbRect.top);        LineTo(thumbRect.left, thumbRect.bottom);        MoveTo(thumbRect.right - 1, thumbRect.top);        LineTo(thumbRect.right - 1, thumbRect.bottom);        if (p) {          Rect r = thumbRect;          r.right--;          r.left++;          LoadResource((Handle)p);          HNoPurge((Handle)p);            DrawPicture(p, &amp;r);          HPurge((Handle)p);        }      }      OffsetRect(&amp;thumbRect, d-&gt;thumbnailSize.right, 0);      resID++;    }    UseResFile(saveRes);    }    ClipRect(&amp;d-&gt;w-&gt;portRect);        // dividing line    {    Rect r = d-&gt;scrollAndSprocketsArea;    RGBColor aColor;    r.left = 0;    r.right = d-&gt;w-&gt;portRect.right;    r.top -= (gSprockets-&gt;portRect.bottom/2) + 2;    aColor = d-&gt;backgroundColor;    aColor.red -= (aColor.red /6);    aColor.green -= (aColor.green /6);    aColor.blue -= (aColor.blue /6);    RGBForeColor(&amp;aColor);    MoveTo(r.left, r.top);    LineTo(r.right, r.top);    aColor = d-&gt;backgroundColor;    aColor.red += (aColor.red /6);    aColor.green += (aColor.green /6);    aColor.blue += (aColor.blue /6);    RGBForeColor(&amp;aColor);    MoveTo(r.left, r.top + 1);    LineTo(r.right, r.top + 1);    }  EndUpdate(d-&gt;w);  if (rgn) DisposeRgn(rgn);}void ActivateDocument(DocumentPtr d){  MenuHandle mh = GetMHandle(130);  short count, index = 0;  Ptr p;  char c[2];  count = CountMItems(mh);  while (count--)    DelMenuItem(mh, count + 1);  if (!d) return;  count = d-&gt;pageCount;  HLock(d-&gt;names);  p = *d-&gt;names;  c[0] = 1;  c[1] = 'e';  while (count--) {    AppendMenu(mh, (StringPtr)&amp;c);    SetItem(mh, ++index, (StringPtr)p);    p += (*p + 1);  }  HUnlock(d-&gt;names);}long IdleOneDocument(DocumentPtr d, void *refCon){  if (d-&gt;mc)    MCIdle(d-&gt;mc);  return 0;}long ForEachDocument(DocFunction df, void *refCon){  WindowPtr w = FrontWindow();  long result = 0;  while (w) {    DocumentPtr d = GetWindowDocument(w);    if (d) {      result = (df)(d, refCon);      if (result) break;    }    w = (WindowPtr)((WindowPeek)w)-&gt;nextWindow;  }  return result;}long TestOneEvent(DocumentPtr d, EventRecord *e){  if (d-&gt;mc &amp;&amp; d-&gt;m)    return MCIsPlayerEvent(d-&gt;mc, e);  return 0;}void OpenFinderDocs(void){  short printIt, docCount;        // no printing  CountAppFiles(&amp;printIt, &amp;docCount);    if (docCount &gt; 0) {    short j;    for(j = 1; j &lt;= docCount; j++){      FSSpec fss;      AppFile apfile;      GetAppFiles(j,&amp;apfile);      FSMakeFSSpec(apfile.vRefNum, 0, apfile.fName, &amp;fss);      OpenDocument(&amp;fss);      ClrAppFiles(j);    }  }}OSErr MissedAEParameters (AppleEvent *message){  DescType typeCode;  Size actualSize;  OSErr err;  err = AEGetAttributePtr(message, keyMissedKeywordAttr, typeWildCard,      &amp;typeCode, nil, 0L, &amp;actualSize);  if (err == errAEDescNotFound)    return(noErr);  return(err = noErr ? errAEEventNotHandled : err);}pascal OSErr OpenDocMessage(AppleEvent *message, AppleEvent *reply, long refcon){  FSSpec fss;  AEDescList docList;  long index, itemsInList;  Size actualSize;  AEKeyword keywd;  DescType typeCode;  OSErr err;  if ((err = AEGetParamDesc(message, keyDirectObject, typeAEList, &amp;docList)) != noErr)    return(err);  if ((err = MissedAEParameters(message)) != noErr)    return(err);  if ((err = AECountItems(&amp;docList, &amp;itemsInList)) != noErr)    return(err);  for (index = 1; index &lt;= itemsInList; index++)    {    if ((err = AEGetNthPtr(&amp;docList, index, typeFSS, &amp;keywd, &amp;typeCode,          (Ptr)&amp;fss, sizeof(FSSpec), &amp;actualSize)) != noErr)      break;      OpenDocument(&amp;fss);    }  return(AEDisposeDesc(&amp;docList));}pascal OSErr QuitAppMessage(AppleEvent *message, AppleEvent *reply, long refcon){  OSErr err;  if ((err = MissedAEParameters(message)) != noErr)    return(err);  gDone = true;  return(noErr);}void main(void){  OSErr err;  long response;  // initialize the world  InitGraf(&amp;qd.thePort);  InitFonts();  InitWindows();  InitMenus();  TEInit();  InitDialogs(0L);  InitCursor();  MaxApplZone();    // find the system version (used later)  Gestalt(gestaltSystemVersion, &amp;gSysVersion);  gSysVersion = (gSysVersion &gt;&gt; 8) &amp; 0x0F;  // must have QuickTime around  if (Gestalt(gestaltQuickTime, &amp;response)) {    doAnAlert(&quot;\pPlease install QuickTime(tm).&quot;, 0);    return;  }  if (response &lt; 0x01508000) {    doAnAlert(&quot;\pMovieBrowser(tm) required QuickTime 1.5 or later.&quot;, 0);    return;  }  err = EnterMovies();  if (err) {    doAnAlert(&quot;\pEnterMovies failed.&quot;, err);    return;  }  SetMenuBar(GetNewMBar(128));  DrawMenuBar();  AddResMenu(GetMHandle(128), 'DRVR');  gAppResFile = CurResFile();  gLastSearchText[0] = 0;  gLastWNETime = TickCount();  // load up the sprockets picture  {  PicHandle p = GetPicture(1028);  Rect r;  CGrafPtr savePort;  GDHandle saveGD;  if (!p) return;  r = (**p).picFrame;  if (NewGWorld(&amp;gSprockets, 1, &amp;r, 0, 0, 0) != noErr) {    doAnAlert(&quot;\pOut of memory&quot;, -108);    return;  }  LockPixels(gSprockets-&gt;portPixMap);  GetGWorld(&amp;savePort, &amp;saveGD);  SetGWorld(gSprockets, nil);    EraseRect(&amp;r);    DrawPicture(p, &amp;r);  SetGWorld(savePort, saveGD);  ReleaseResource((Handle)p);  }  if((Gestalt(gestaltAppleEventsAttr, &amp;response) ? false : response != 0)) {    AEInstallEventHandler(kCoreEventClass, kAEOpenDocuments,        (AEEventHandlerProcPtr)OpenDocMessage, 0, false);    AEInstallEventHandler(kCoreEventClass, kAEQuitApplication,        (AEEventHandlerProcPtr)QuitAppMessage, 0, false);  }  OpenFinderDocs();  do {    EventRecord e;    long result;    DocumentPtr d;    unsigned long ticksNow = TickCount();    Boolean mustGetEvent = gInBackground;    if (!mustGetEvent) {      // see if we have a pending update      WindowRef w = LMGetWindowList();      while (w) {        if (!EmptyRect(&amp;(**((WindowPeek)w)-&gt;updateRgn).rgnBBox)) {          mustGetEvent = true;          break;        }        w = (WindowPtr)(((WindowPeek)w)-&gt;nextWindow);      }    }    if (mustGetEvent || ((gLastWNETime + kWNEInterval) &lt; ticksNow)) {      WaitNextEvent(everyEvent, &amp;e, 0, nil);      gLastWNETime = ticksNow;    }    else {      if (OSEventAvail(mDownMask | keyDownMask, &amp;e))        WaitNextEvent(everyEvent, &amp;e, 0, nil);      else        e.what = nullEvent;    }#ifdef THINK_C        result = ForEachDocument((DocFunction)TestOneEvent, &amp;e);#else    result = ForEachDocument(TestOneEvent, &amp;e);#endif    if (result) continue;    switch (e.what) {      case mouseDown:        {        short part;        WindowPtr whichWindow;        part = FindWindow(e.where, &amp;whichWindow);        if (part) {          switch (part) {            case inMenuBar:                  colorMenus();                  gDone = doMenuItem(MenuSelect(e.where));                  break;            case inSysWindow:                  SystemClick(&amp;e, whichWindow);                  break;            case inContent:                  if (whichWindow != FrontWindow()) {                    SelectWindow(whichWindow);                    break;                  }                  DoContentClick(GetWindowDocument(whichWindow), e.where, e.when);                  break;            case inDrag:                  d = GetWindowDocument(whichWindow);                    if (d != NULL) {                    Rect r;                    GetMovieBox(d-&gt;m, &amp;r);                    DragAlignedWindow(whichWindow, e.where, &amp;qd.screenBits.bounds, &amp;r, nil);                  }                  else                    DragWindow(whichWindow, e.where, &amp;qd.screenBits.bounds);                  break;            case inGrow:                  break;            case inGoAway:                  if (TrackGoAway(whichWindow, e.where))                    CloseDocument(GetWindowDocument(whichWindow));                  break;          }        }        }        break;      case updateEvt:        UpdateDocument(GetWindowDocument((WindowPtr)e.message));        break;      case keyDown:        {        char c;        c = e.message &amp; charCodeMask;        if (e.modifiers &amp; cmdKey) {          colorMenus();          gDone = doMenuItem(MenuKey(c));        }        }        break;      case app4Evt:          if ((e.message &amp; 0xFF000000L) == 0x01000000L) {          if (e.message &amp; 1) {            InitCursor();            ActivateDocument(GetWindowDocument(FrontWindow()));            gInBackground = false;          }          else            gInBackground = true;        }        break;      case activateEvt:        ActivateDocument(GetWindowDocument((WindowPtr)e.message));        break;      case kHighLevelEvent:        AEProcessAppleEvent(&amp;e);        break;    }  } while (!gDone);  // QuickTime will take care of cleaning up after itself...}</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/MovieBrowser/listing2.html%3Fid%3DDTS10000846-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/MovieBrowser/listing2.html%3Fid%3DDTS10000846-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/MovieBrowser/listing2.html%3Fid%3DDTS10000846-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>