import java.awt.Color;import java.awt.Image;import java.awt.Component;import java.awt.MediaTracker;import java.awt.Button;import java.awt.Toolkit;import java.awt.event.KeyEvent;import java.io.*;import java.net.URL;import java.net.MalformedURLException;/* Copyright: 	© Copyright 1999 Apple Computer, Inc. All rights reserved. *	 * Disclaimer:	IMPORTANT:  This Apple software is supplied to you by Apple Computer, Inc. *				("Apple") in consideration of your agreement to the following terms, and your *				use, installation, modification or redistribution of this Apple software *				constitutes acceptance of these terms.  If you do not agree with these terms, *				please do not use, install, modify or redistribute this Apple software. * *				In consideration of your agreement to abide by the following terms, and subject *				to these terms, Apple grants you a personal, non-exclusive license, under AppleÕs *				copyrights in this original Apple software (the "Apple Software"), to use, *				reproduce, modify and redistribute the Apple Software, with or without *				modifications, in source and/or binary forms; provided that if you redistribute *				the Apple Software in its entirety and without modifications, you must retain *				this notice and the following text and disclaimers in all such redistributions of *				the Apple Software.  Neither the name, trademarks, service marks or logos of *				Apple Computer, Inc. may be used to endorse or promote products derived from the *				Apple Software without specific prior written permission from Apple.  Except as *				expressly stated in this notice, no other rights or licenses, express or implied, *				are granted by Apple herein, including but not limited to any patent rights that *				may be infringed by your derivative works or by other works in which the Apple *				Software may be incorporated. * *				The Apple Software is provided by Apple on an "AS IS" basis.  APPLE MAKES NO *				WARRANTIES, EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION THE IMPLIED *				WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY AND FITNESS FOR A PARTICULAR *				PURPOSE, REGARDING THE APPLE SOFTWARE OR ITS USE AND OPERATION ALONE OR IN *				COMBINATION WITH YOUR PRODUCTS. * *				IN NO EVENT SHALL APPLE BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL OR *				CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE *				GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) *				ARISING IN ANY WAY OUT OF THE USE, REPRODUCTION, MODIFICATION AND/OR DISTRIBUTION *				OF THE APPLE SOFTWARE, HOWEVER CAUSED AND WHETHER UNDER THEORY OF CONTRACT, TORT *				(INCLUDING NEGLIGENCE), STRICT LIABILITY OR OTHERWISE, EVEN IF APPLE HAS BEEN *				ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */ public class Util{	public static final Color GSBColor  = Color.black;	public static final Color GSWColor  = Color.white;	public static final Color GS1Color  = new Color(238, 238, 238);	public static final Color GS2Color  = new Color(221, 221, 221);	public static final Color GS3Color  = new Color(204, 204, 204);	public static final Color GS4Color  = new Color(187, 187, 187);	public static final Color GS5Color  = new Color(170, 170, 170);	public static final Color GS6Color  = new Color(153, 153, 153);	public static final Color GS7Color  = new Color(136, 136, 136);	public static final Color GS8Color  = new Color(119, 119, 119);	public static final Color GS9Color  = new Color(102, 102, 102);	public static final Color GS10Color = new Color( 85,  85,  85);	public static final Color GS11Color = new Color( 68,  68,  68);	public static final Color GS12Color = new Color( 34,  34,  34);	public static final Color GSA1Color = new Color( 51,  51,  51);	public static final Color GSA2Color = new Color( 17,  17,  17);	/**	 * Completely loads the Image referenced by the given filename.	 * This will block until the image is loaded.	 * @param filename the path of the Image to load.	 * @param watcher the component to use to load the image.	 * @param if true, the image location is treated as a resource relative to the	 * watcher component's class file; if false the location is treated as an absolute file path.	 * @return the loaded Image, or null if the loading fails.	 */	public static Image loadImage(String filename, Component watcher, boolean isResource)	{		Image image = null;				if (filename != null)		{			URL url = null;						if (isResource)				url = watcher.getClass().getResource(filename);			else			{				try				{					url = new URL("file", "", filename);				}				catch(MalformedURLException exc)				{					exc.printStackTrace();				}			}						if (url == null)			{				System.err.println("loadImage() could not find \"" + filename + "\"");			}			else			{				image = watcher.getToolkit().getImage(url);			    if (image == null)			    {					System.err.println("loadImage() getImage() failed for \"" + filename + "\"");			    }			    else			    {					MediaTracker tracker = new MediaTracker(watcher);					        try			        {			            tracker.addImage(image, 0);			            tracker.waitForID(0);			        }			        catch (InterruptedException e) { System.err.println("loadImage(): " + e); }			        finally			        {				    	boolean isError = tracker.isErrorAny();				    	if (isError)				    	{					    	System.err.println("loadImage() failed to load \"" + filename + "\"");					    	int flags = tracker.statusAll(true);							    	boolean loading = 0 != (flags & MediaTracker.LOADING);					    	boolean aborted = 0 != (flags & MediaTracker.ABORTED);					    	boolean errored = 0 != (flags & MediaTracker.ERRORED);					    	boolean complete = 0 != (flags & MediaTracker.COMPLETE);					    	System.err.println("loading: " + loading);					    	System.err.println("aborted: " + aborted);					    	System.err.println("errored: " + errored);					    	System.err.println("complete: " + complete);					    }			        }			    }			}		}				return image;	}	/**	 * Reads in a text file to a String.	 * There is probably a more elegant solution, but this works.	 * @param file, the local path to the text file to read.	 * @param localRef, a class file which the text file is local to.	 * @return the string containing the contents of the file.	 * @throws java.io.FileNotFoundException if the given file can not	 * be found to be read.	 */	public static String readTextResourceFile(String filePath, Object localRef) throws FileNotFoundException	{		String result = "";				if (filePath != null && localRef != null)		{			InputStream inStream = localRef.getClass().getResourceAsStream(filePath);			if (inStream == null)				throw new FileNotFoundException("Could not find \"" + filePath + "\"");							//Create a new buffered input stream out of the raw input stream, with a buffer of 8k.			BufferedInputStream in = new BufferedInputStream(inStream, 8192);			try			{				StringBuffer sb = new StringBuffer();								int c = in.read();				while (c != -1)				{					sb = sb.append((char)c);					c = in.read();				}								result = new String(sb);			}			catch (IOException exc)			{				exc.printStackTrace();			}		}		return result;	}		/**	 * Replaces a given substring with the supplied string in the source string.	 * @param what is the substring of the source string to replace.	 * @param with is the string to use instead.	 * @param source is the original string.	 * @return the modified string with all occurances of 'what' replaced by 'with'	 */	public static String replace(String what, String with, String source)	{		String result = new String(source);				int index = source.indexOf(what);		while (index >= 0)		{			result = (result.substring(0, index) + with + result.substring(index + what.length()));			index = result.indexOf(what);		}				return result;	}		/**	 * A function to simulate a click on the target button.	 * This will make the button draw as if it had been pressed and	 * released, and the button will fire an Action event as if	 * the button were pressed.	 * For use with the Apple MRJ 2.1 EA3 and later.	 */	public static void simulateClick(Button target)	{		if (target != null)		{			KeyEvent keyEvent = new KeyEvent(target, KeyEvent.KEY_PRESSED, 			                               System.currentTimeMillis(), 0, KeyEvent.VK_ENTER, 			                               (char)KeyEvent.VK_ENTER);			target.dispatchEvent(keyEvent);		}	}	/**	 * Calculates a random number between and including the given range.	 * @param min is the minimum value the random number will be.	 * @param max is the maximum value the random number will be.	 * @return a random number between min and max inclusively.	 * @exception IllegalArgumentException if min is not less than max.	 */	public static int rangedRandom(int min, int max)	{		if (min > max)			throw new IllegalArgumentException("min (" + min + ") must be less than max (" + max + ").");				int range = max - min;		double rand = Math.random();		return (int)((rand * range) + min + 0.5);	}}