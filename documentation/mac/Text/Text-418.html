<!-- Generated by Harlequin WebMaker 2.2.3 (23-Apr-1996)
LispWorks 3.2.2 -->
<HTML> <HEAD>
<TITLE>Calling the Text Services Manager(IM: Tx)</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING418></A>



<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->


<!-- Main Body -->

<CENTER>
<P>
<A HREF="Text-417.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="Text-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="Text-594.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="Text-419.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="Text-2.html"><B>Text</B></A> / <BR><DD><A HREF="Text-409.html"><B>Chapter 7 - Text Services Manager</B></A> / <A HREF="Text-416.html"><B>Using the Text Services Manager (for Client Applications)</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING418-0></A>
<H2><A NAME=MARKER-2-61></A><A NAME=MARKER-9-117></A>Calling the Text Services Manager</H2>
 The application interface to the Text Services Manager consists of application-level calls that your client application uses to send information to text service components by way of the Text Services Manager. They are documented in detail under <A HREF=Text-426.html#MARKER-9-223>"Text Services Manager Routines for Client Applications" on page 7-48</A>. The Text Services Manager maps many of those calls to equivalent component-level calls to text service components. Those text service component routines are described under <A HREF=Text-466.html#MARKER-9-318>"Text Service Component Routines" on page 7-84</A>.<P>
 This section describes how your client application can use the application interface to the Text Services Manager to<P>
<UL>
<LI>prepare for communication with the Text Services Manager
<LI>create an internal record called a TSM document
<LI>make text services other than text input available to the user
<LI>activate and deactivate a TSM document
<LI>give text service components a chance to handle events, respond to menu selections, and set the shape of the cursor
<LI>explicitly confirm text within the active input area
<LI>terminate communication with the Text Services Manager<P>
</UL>
<A NAME=HEADING418-10></A>
<H3>Initializing as a TSM-Aware Application</H3>
 <A NAME=MARKER-2-80></A>If your client application plans to use any of the Text Services Manager application-interface routines, it must call <CODE>InitTSMAwareApplication</CODE> at startup, immediately after calling the rest of the Toolbox initialization routines. See <A HREF=#MARKER-9-119>Listing 7-1</A>.<P>
<B>Listing 7-1  <A NAME=MARKER-9-119></A>Initializing as a TSM-aware application</B><P>
<PRE>
FUNCTION Initialize: OSErr;
VAR
   myErr:   OSErr;
BEGIN
   InitGraf(@thePort);
   InitFonts;
   InitWindows;
   InitMenus;
   TEInit;
   InitDialogs(NIL);
   InitCursor;

   IF (InitTSMAwareApplication = noErr) THEN
      Initialize := DoNew;       {application routine that }
                                 { creates window &amp; TSM document}
END;
</PRE>
     The Text Services Manager records the fact that your client application is TSM-aware, and allocates any private data storage as necessary.<A NAME=MARKER-2-120></A><P>
<A NAME=HEADING418-15></A>
<H3><A NAME=MARKER-9-121></A>Creating a TSM Document</H3>
 <A NAME=MARKER-2-32></A>Your client application needs to create an internal record called a <A NAME=MARKER-2-62></A><B>TSM document</B> (defined by the <CODE>TSMDocument</CODE> data type) before it can use any services provided through the Text Services Manager. A TSM document is a private data structure that is associated with each of your application's documents that use a text service. You cannot access the TSM document record directly. You call the <CODE>NewTSMDocument</CODE> function to instruct the Text Services Manager to create the TSM document. The Text Services Manager returns a TSM document ID, an identifier that you supply in subsequent calls to the Text Services Manager.<P>
 Typically, you create a TSM document for each window that your application uses. Use the <CODE>supportedInterfaceTypes</CODE> array to indicate which text service interfaces you support. Currently only one interface is defined--<CODE>'tsvc'</CODE>, the component type for text services components. Pass any data you like in the <CODE>refcon</CODE> parameter to the call. The Text Services Manager returns the <CODE>refcon</CODE> value in the <CODE>keyAETSMDocumentRefcon</CODE> parameter of any Apple event sent to your application. You can then use the <CODE>refcon</CODE> value to determine which TSM document and window the Apple event belongs to.<P>
 <A HREF=#MARKER-9-124>Listing 7-2</A> shows the sample application's <CODE>DoNew</CODE> function, which is called from the initialization routine presented in <A HREF=#MARKER-9-119>Listing 7-1</A>. The call to <CODE>NewTSMDocument</CODE> specifies that the application supports one interface type (<CODE>kTextService</CODE>). <CODE>NewTSMDocument</CODE> opens the default input method for the current keyboard script, assigns it to this document, and returns the TSM document ID in the <CODE>idocID</CODE> parameter. The routine makes use of a modified window record (type <CODE>MyWindowRecord</CODE>) that is a standard window record with an additional field for holding the TSM document ID.<P>
<B>Listing 7-2  <A NAME=MARKER-9-124></A>Creating a new TSM document and associating it with a window</B><P>
<PRE>
FUNCTION DoNew: OSErr;
VAR
   wRecordPtr:       myWindowPtr;
   window:           WindowPtr;
   supportedTypes:   InterfaceTypeList;
   myErr:            OSErr;
BEGIN
   supportedTypes[0] := kTextService;
                              {allocate storage for window record}
   wRecordPtr := myWindowPtr(NewPtr(sizeof(myWindowRecord)));
   IF wRecordPtr &lt;&gt; NIL THEN
   BEGIN
      IF gColorQDAvailable THEN
         window := GetNewCWindow(kWINDResID, Ptr(wRecordPtr),  
                                 WindowPtr(-1))
      ELSE
         window := GetNewWindow(kWINDResID, Ptr(wRecordPtr),  
                                 WindowPtr(-1));
      IF window = NIL THEN                   {couldn't get window}
      BEGIN
         DisposePtr(Ptr(wRecordPtr));                 {clean up}
         DoNew := kWindowFailed;
         Exit(DoNew);
      END;
      myErr := NewTSMDocument(1, supportedTypes,
                              wRecordPtr^.idocID, 
                              LongInt(wRecordPtr));
   END;
   {do other window intialization, like creating scroll bars}
   DoNew := myErr;
END;
</PRE>
<A NAME=HEADING418-21></A>
<H3><A NAME=MARKER-2-125></A>Making Text Services Available to the User</H3>
 <A NAME=MARKER-2-63></A>Text services that are input methods are always displayed in the keyboard menu. System software takes care of that; your application does not need to list input methods. However, your application may wish to provide a menu or scrolling list to display other types of available text services. (Note that, currently, no text services other than input methods are available. This capability is provided for future extensibility.)<P>
 To obtain a list of the available text services on the user's system, call the <CODE>GetServiceList</CODE> function. You pass it an array of interface types (to indicate the types of services you want returned in the list) and a pointer to a data structure (to hold the list). The function returns the number of available components, and a name and component identifier for each one.<P>
 Because text service components can be registered or unregistered at any time, your client application should periodically call either <CODE>GetServiceList</CODE> or the Component Manager function <CODE>GetComponentListModSeed</CODE> to see if the list of registered text service components may have changed.<P>
<DL>
<DT><B>IMPORTANT</B>
<DD>If your client application displays a list or menu of text service components, do not show input methods. They are already displayed in the Keyboard menu. To show them in two places would be confusing to users.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
 The Text Services Manager automatically opens input methods; your client application does not have to open them. You do have to explicitly open all other types of text services, however. If the user chooses a text service from a menu or list that you have displayed, you need to open that text service.<P>
 You call the <CODE>OpenTextService</CODE> function to associate the text service component with the current TSM document. <CODE>OpenTextService</CODE> then returns a valid component instance to indicate that the text service component has been opened and initialized.<P>
 Whenever a user wishes to close a text service component that you have opened, call the <CODE>CloseTextService</CODE> function. <A NAME=MARKER-2-127></A>  <A NAME=MARKER-2-128></A><P>
<A NAME=HEADING418-29></A>
<H3><A NAME=MARKER-2-129></A>Activating and Deactivating a TSM Document</H3>
 <A NAME=MARKER-2-130></A>To notify the Text Services Manager that a window in your client application associated with a TSM document has been activated, and that you are ready to use a text service component, use the <CODE>ActivateTSMDocument</CODE> function.<P>
 <A NAME=MARKER-2-131></A><A HREF=#MARKER-9-132>Listing 7-3</A> shows how to handle activating and deactivating a TSM document. You specify the document using the ID assigned to it when it was created (with the <CODE>NewTSMDocument</CODE> function). This routine, like the previous samples, assumes that the application has an extended window record with a field, <CODE>idocID</CODE>, that contains the TSM document ID.<P>
<B>Listing 7-3  <A NAME=MARKER-9-132></A>Activating and deactivating a TSM document</B><P>
<PRE>
PROCEDURE DoActivate(window: WindowPtr; becomingActive: Boolean);
VAR
   myErr:   OSErr;
BEGIN
   IF becomingActive THEN
      myErr := ActivateTSMDocument(MyWindowPtr(window)^.idocID)
   ELSE
      myErr := DeactivateTSMDocument(MyWindowPtr(window)^.idocID);
END;
</PRE>
 When the Text Services Manager receives an ActivateTSMDocument call, it deactivates the currently active TSM document (if it hasn't already been explicitly deactivated) and stores the new document as the currently active TSM document. If the specified text service component for the document has a menu, the Text Services Manager inserts the menu into the menu bar as an application or system menu.<P>
 When a window in your client application associated with a TSM document has been deactivated, you should call the <CODE>DeactivateTSMDocument</CODE> function. The Text Services Manager in turn calls the text service component function <CODE>DeactivateTextService</CODE> for any text service components associated with the TSM document being deactivated.<P>
 Input-method text services are handled in a special way: the identity of the input method of the deactivated document is retained by the Text Services Manager, and compared with the input method used by the next <I>activated</I> document. If the newly active document uses the same input method, the Text Services Manager will simply activate the new instance of the same input method. If the documents use different input methods, the previous input method is then closed, and any windows belonging to it are closed and menus are removed. The new input method is then activated. Not closing an input method until it is actually unneeded avoids extra removal and immediate redisplay of input method palettes and menus.<A NAME=MARKER-2-133></A>  <A NAME=MARKER-2-134></A>  <A NAME=MARKER-2-64></A><P>
<A NAME=HEADING418-37></A>
<H3><A NAME=MARKER-2-285></A>Passing Events, Menu Selections, and Cursor Setting</H3>
 Whenever your client application receives an event from the Event Manager function <CODE>WaitNextEvent</CODE>, you need to give each text service component an opportunity to handle that event, if appropriate. Use the <CODE>TSMEvent</CODE> function to let the Text Services Manager dispatch the events to the correct text service component. You provide a pointer to the event record containing the event. The Text Services Manager passes the event in turn to each component associated with the currently active TSM document, starting with input methods. If the event is handled by a component, <CODE>TSMEvent</CODE> returns <CODE>TRUE</CODE> and the event is changed to a null event. If the event is not handled, <CODE>TSMEvent</CODE> returns <CODE>FALSE</CODE> and you are responsible for handling the event.<P>
 <A HREF=#MARKER-9-137>Listing 7-4</A> is a partial example of an event handler in which the application passes events to the Text Services Manager for routing to text service components. If no text service component handles an event, the application handles it. The global variable <CODE>gUsingTSM</CODE> is <CODE>TRUE</CODE> if the Text Services Manager is present and the application is making use of it.<P>
<B>Listing 7-4  <A NAME=MARKER-9-137></A>Passing events to a text service component</B><P>
<PRE>
PROCEDURE MyDoEvent(event: eventRecord);
VAR
   handledByTS:   Boolean;
   gotEvent:      Boolean;
BEGIN
   WHILE TRUE DO
   BEGIN
      IF gHasWaitNextEvent THEN
      BEGIN
         gotEvent := WaitNextEvent(everyEvent, event, 
                                    kSleep, NIL);
         handledByTS := FALSE;
         IF (gUsingTSM AND gotEvent) THEN
            handledByTS := TSMEvent(event);
      END;
      IF gotEvent AND (NOT handledByTS) THEN

         {process event in normal way}
         ;
   END;
END;
</PRE>
 <A NAME=MARKER-9-72></A>Whenever a user chooses a menu item, it may be from a text service component's menu; your application must therefore give the text service component a chance to respond. (This situation occurs only with text service components that are not input methods.) To do this, use the <CODE>TSMMenuSelect</CODE> function with the result from the Menu Manager function <CODE>MenuSelect</CODE> in the <CODE>menuResult</CODE> parameter. If <CODE>TSMMenuSelect</CODE> returns <CODE>TRUE</CODE>, then the text service component has handled the menu selection, so your client application does not need to do so. However, your application is still responsible for removing the highlighting from the menu title after the selection has been handled.<P>
 <A NAME=MARKER-2-343></A>Your client application is generally responsible for setting the cursor to an appropriate shape. However, the text service component may have its own cursor requirements when the cursor is within the boundaries of its windows or palettes. To allow a text service component to set the cursor, use the SetTSMCursor function. Call it whenever you would normally set the cursor yourself. If <CODE>SetTSMCursor</CODE> returns <CODE>TRUE</CODE>, the cursor is either on a text service component window or on the active input area and a text service component has set the cursor. In this case, you should not set the cursor.<A NAME=MARKER-2-140></A>  <A NAME=MARKER-2-141></A>  <A NAME=MARKER-2-367></A> <P>
<A NAME=HEADING418-44></A>
<H3><A NAME=MARKER-2-143></A>Confirming Active Text Within a TSM Document</H3>
 <A NAME=MARKER-2-144></A>Normally, an input method text service component ejects finished input from the active input area continually as it processes user events, sending the confirmed text to your application with the Update Active Input Area Apple event.<P>
 Circumstances may arise in which you need to confirm input in progress before the text service component ejects it (that is, before the user presses Return). If, for example, the user clicks the mouse in text outside the active input area, that constitutes an implicit user acceptance of the text in the active input area. You should explicitly terminate any active input and save the text that is in the active input area by calling the <CODE>FixTSMDocument</CODE> function. The text service component sends the confirmed text to your application and empties the active input area.<P>
 <A HREF=#MARKER-9-145>Listing 7-5</A> shows what happens when the user clicks the go-away box of the active document window after entering some text in the active input area. The global variable <CODE>gIDocID</CODE> represents the ID of the active TSM document.<P>
<B>Listing 7-5  <A NAME=MARKER-9-145></A>Confirming text in an active input area</B><P>
<PRE>
PROCEDURE DoMouseDown (event: EventRecord);
VAR
   part:       Integer;
   theWindow:  WindowPtr;
   myErr:      OSErr;
BEGIN
   part := FindWindow(event.where, theWindow);
   CASE part OF
      inContent:
         DoContentClick(theWindow, event);

      inDrag:
         DragWindow(theWindow, event.where,
                              theWindow^.portRect);
   
      inGoAway:
         IF TrackGoAway(theWindow, event.where) THEN
         BEGIN
            myErr := FixTSMDocument(gIDocID);   {confirm text}
            DoActivate(theWindow, FALSE);    {deactivate window}
            HideWindow(theWindow);              {put it away}
            gVisible := FALSE;
         END;
   END;
END;  
</PRE>
<A NAME=HEADING418-50></A>
<H3><A NAME=MARKER-9-305></A>Deleting a TSM Document</H3>
 <A NAME=MARKER-2-368></A>When your client application closes a document window and no longer needs its associated TSM document, it needs to call the <CODE>DeleteTSMDocument</CODE> function to inform the Text Services Manager that the TSM document should be deleted.<P>
 The Text Services Manager closes the text service components for the specified TSM document by calling the Component Manager <CODE>CloseComponent</CODE> function for each open text service component. It then disposes of the internal TSM document record for the specified TSM document.<P>
<A NAME=HEADING418-53></A>
<H3>Closing Down as a TSM-Aware Application</H3>
 <A NAME=MARKER-2-347></A>To let the Text Services Manager perform needed housekeeping chores when your application has closed, your client application needs to call <CODE>CloseTSMAwareApplication</CODE> just before quitting, as shown in <A HREF=#MARKER-9-149>Listing 7-6</A>.<P>
<B>Listing 7-6  <A NAME=MARKER-9-149></A>Closing a TSM-aware application</B><P>
<PRE>
FUNCTION DoQuitApplication: OSErr;
VAR
   myErr:   OSErr;
BEGIN

   {app-specific clean up}

   myErr := CloseTSMAwareApplication;  {ignore the error}
   ExitToShell;
END;
</PRE>
<A NAME=HEADING418-57></A>
<H3><A NAME=MARKER-2-150></A>Requesting a Floating Input Window for Text Entry</H3>
 <A NAME=MARKER-9-369></A>Your client application may need to provide for users who prefer to enter text using a floating input window instead of entering text directly in the line of a document. For example, when the text font size is too small for reading ideographic characters, too big for convenient entry directly into the document window, or is being greeked, users may prefer a floating input window.<P>
 Your client application calls the <CODE>UseInputWindow</CODE> function with the <CODE>useInputWindow</CODE> parameter set to <CODE>TRUE</CODE> to display a floating input window for the TSM document you specify in the <CODE>idocID</CODE> parameter to the call. To display floating input windows for all documents associated with your application, you set the <CODE>idocID</CODE> parameter to <CODE>NIL</CODE> and the <CODE>useInputWindow</CODE> parameter to <CODE>TRUE</CODE>. To return to inline input, call <CODE>UseInputWindow</CODE> with the <CODE>useInputWindow</CODE> parameter set to <CODE>FALSE</CODE>. <A NAME=MARKER-2-370></A>  <A NAME=MARKER-2-349></A><P>
<A NAME=HEADING418-60></A>
<H3><A NAME=MARKER-2-300></A>Associating Input Methods With Scripts and Languages</H3>
 <A NAME=MARKER-2-371></A>If you use the application-interface routines, the Text Services Manager automatically associates a default input method with your TSM document every time the current script and language change. Although it is unlikely that it would ever need to, your client application can use Text Services Manager routines to control that automatic association.<P>
 <A NAME=MARKER-2-372></A>The Operating System uses the <CODE>GetDefaultInputMethod</CODE> and <CODE>SetDefaultInputMethod</CODE> functions to associate an input method with a given script and language. When the user uses the Keyboard menu, Keyboard control panel, or other device for controlling input method preferences, these functions establish permanent associations (they last across restarts).<P>
 <A NAME=MARKER-2-373></A>The Text Services Manager maintains a current text service language that it uses to synchronize input methods to the current script system and language. The Operating System calls the <CODE>SetTextServiceLanguage</CODE> function when the user switches the keyboard script, and the floating window service calls the <CODE>GetTextServiceLanguage</CODE> function to determine the text service language.<P>
 <A NAME=MARKER-2-158></A>These routines make use of the script-language record, described under <A HREF=Text-423.html#MARKER-9-202>"Identifying the Supported Scripts and Languages" on page 7-42</A>.<P>
 If your client application uses the Text Services Manager application-interface routines, the Text Services Manager automatically synchronizes the input method to the current text service language and there is no need to make the calls described here. If your client application bypasses the Text Services Manager and uses the text service component routines, the Text Services Manager does not provide automatic input method synchronization and you may have to make some of these calls yourself. See <A HREF=Text-420.html#MARKER-9-173>"Direct Access to Text Service Components" on page 7-36</A> for more information on the Component Manager and on how to communicate directly with text service components.  <A NAME=MARKER-2-350></A><P>
</BLOCKQUOTE>
<HR>
<center>
<A HREF="Text-417.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="Text-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="Text-594.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="Text-419.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="Text-3.html">&copy; Apple Computer, Inc.</A><br>6 JUL 1996</center></font><P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML>  
