<html><head><title></title></head>
<body bgcolor="#ffffff">
 
 
<h1>
<FONT COLOR="#000066">
<a name="816">
 <a name="//apple_ref/java/cl/FetchSpecification">FetchSpecification</a>
</a>
</FONT>
</h1>
<p><B>Extends:</B><BR>  
next.util.NextObject

<p><B>Implements:</B><BR>
next.util.Coding

<p><a name="829"></a>
<a name="description"></a>
<H2>Class Description
</H2>
A FetchSpecification collects the criteria needed to select and order a group of records or enterprise objects, whether from an external repository such as a relational database or an internal store such as an EditingContext. A FetchSpecification contains these elements:<p>
<ul><li>The name of an entity for which to fetch records or objects. This is the only mandatory element.<p>
<li>A Qualifier, indicating which properties to select by and how to do so.<p>
<li>An array of SortOrderings, which indicate how the selected records or objects should be ordered when fetched.<p>
<li>An indicator of whether to produce distinct results or not. Normally if a record or object is selected several times, such as when forming a join, it appears several times in the fetched results. A FetchSpecification that makes distinct selections causes duplicates to be filtered out, so that each record or object selected appears exactly once in the result set.<p>
<li>An indicator of whether to fetch deeply or not. This is used with inheritance hierarchies when fetching for an entity with sub-entities. A deep fetch produces all instances of the entity and its sub-entities, while a shallow fetch produces instances only of the entity in the fetch specification.<p>
<li>A dictionary of hints, which a DatabaseContext or other object can use to optimize or alter the results of the fetch.<p>
</ul>FetchSpecifications are most often used with the method <code>objectsWithFetchSpecification</code>, defined by ObjectStore, EditingContext, and next.eo.DatabaseContext, but next.eo.AdaptorChannel and next.eo.DatabaseChannel also define methods that use FetchSpecifications.<p>
<HR WIDTH=50% ALIGN=LEFT>
<h2>Interfaces Implemented</h2>  


<dl>
<dt>next.util.Coding<dl><dl><dl><dl>
<dt>encodeWithCoder</dl>
</dl></dl></dl></dl>
<a name="833">
<HR WIDTH=50% ALIGN=LEFT>
<h2>Method Types
</h2>
</a><dl>
<dt>Constructors<dl><dl><dl><dl>
<dt><a href="#1694">FetchSpecification</a></dl>
</dl></dl></dl><dt>Setting the qualifier<dl><dl><dl><dl>
<dt><a href="#1994">setQualifier</a><dt><a href="#1924">qualifier</a></dl>
</dl></dl></dl><dt>Sorting<dl><dl><dl><dl>
<dt><a href="#886">setSortOrderings</a><dt><a href="#911">sortOrderings</a></dl>
</dl></dl></dl><dt>Removing duplicates<dl><dl><dl><dl>
<dt><a href="#2009">setUsesDistinct</a><dt><a href="#1003">usesDistinct</a></dl>
</dl></dl></dl><dt>Fetching objects in an inheritance hierarchy<dl><dl><dl><dl>
<dt><a href="#1969">setIsDeep</a><dt><a href="#1891">isDeep</a><dt><a href="#840">setEntityName</a><dt><a href="#1856">entityName</a></dl>
</dl></dl></dl><dt>Specifying hints to affect fetching behavior<dl><dl><dl><dl>
<dt><a href="#1964">setHints</a><dt><a href="#1886">hints</a></dl>
</dl></dl></dl><dt>Locking objects<dl><dl><dl><dl>
<dt><a href="#1974">setLocksObjects</a><dt><a href="#1902">locksObjects</a></dl>
</dl></dl></dl><dt>Refreshing refetched objects<dl><dl><dl><dl>
<dt><a href="#1999">setRefreshesRefetchedObjects</a><dt><a href="#1929">refreshesRefetchedObjects</a></dl>
</dl></dl></dl></dl>
<HR WIDTH=50% ALIGN=LEFT>
<a name="1649"></a>
<a name="cons"></a>
<h2>Constructors</h2>  


<a name="1694"></a>
<h3>
 FetchSpecification
</h3>
public <code>next.eo.FetchSpecification</code>()

<P>public <code>next.eo.FetchSpecification</code>(java.lang.String <em>entityName</em>, next.eo.Qualifier <em>qualifier</em>, 
next.util.ImmutableVector <em>sortOrderings</em>)

<P>public <code>next.eo.FetchSpecification</code>(java.lang.String <em>entityName</em>, next.eo.Qualifier <em>qualifier</em>, 
next.util.ImmutableVector <em>sortOrderings</em>, boolean <em>distinctFlag</em>, boolean <em>deepFlag</em>, 
next.util.ImmutableHashtable <em>hints</em>)

<P>public <code>next.eo.FetchSpecification</code>(next.util.Coder <em>aCoder</em>)

<P>Creates a new FetchSpecification with the arguments specified. If no arguments are provided, the new FetchSpecification has no state, except that it fetches deeply and doesn't use distinct. Use the <code>set...</code> methods to add other parts of the specification. Minimally, you must set the entity name.<p>
If only <em>entityName</em>, <em>qualifier</em>, and <em>sortOrderings</em> are provided, the new FetchSpecification is deep, doesn't perform distinct selection, and has no hints.<p>
If <em>aCoder</em> is provided, the new FetchSpecification is decoded from <em>aCoder</em>. This constructor, together with <code>encodeWithCoder</code>, provide the basis for archiving and distributing qualifiers. <em>aCoder</em> is specified when a FetchSpecification is being read from an archive file; you never specify this constructor directly. For more information, see the next.util.Coding interface specification in the <em>Foundation Framework Reference</em>.<p>
<HR WIDTH=50% ALIGN=LEFT>
<a name="instm"></a>
<h2>Instance Methods</h2>  


<a name="1856"></a>
<h3>
 <a name="//apple_ref/java/instm/FetchSpecification/entityName">entityName</a>
</h3>
public java.lang.String <code>entityName</code>()

<P>Returns the name of the entity to be fetched.<p>
<B>See also: </B>  
<a href="#1891"><code>isDeep</code></a>, <a href="#840"><code>setEntityName</code></a>
<p><hr WIDTH=25% ALIGN=LEFT>
<a name="1886"></a>
<h3> <a name="//apple_ref/java/instm/FetchSpecification/hints">hints</a></h3>
public next.util.ImmutableHashtable <code>hints</code>()

<P>Returns the receiver's hints, which other objects can use to alter or optimize fetch operations. DatabaseContext's <code>objectsWithFetchSpecification</code> uses a hint to prefetch the destinations of relationships, for example.<p>
<B>See also: </B>  
<a href="#1964"><code>setHints</code></a>
<p><hr WIDTH=25% ALIGN=LEFT>
<a name="1891"></a>
<h3> <a name="//apple_ref/java/instm/FetchSpecification/isDeep">isDeep</a></h3>
public boolean <code>isDeep</code>()

<P>Returns <code>true</code> if a fetch should include sub-entities of the receiver's entity, <code>false</code> if it shouldn't. FetchSpecifications are deep by default.<p>
For example, if you have a Person entity with two sub-entities, Employee and Customer, fetching Persons deeply also fetches all Employees and Customers matching the qualifier. Fetching Persons shallowly fetches only Persons matching the qualifier.<p>
<B>See also: </B>  
<a href="#1969"><code>setIsDeep</code></a>
<p><hr WIDTH=25% ALIGN=LEFT>
<a name="1902"></a>
<h3> <a name="//apple_ref/java/instm/FetchSpecification/locksObjects">locksObjects</a></h3>
public boolean <code>locksObjects</code>()

<P>Returns <code>true</code> if a fetch should result in the selected objects being locked in the data repository, <code>false</code> if it shouldn't. The default is <code>false</code>.<p>
<B>See also: </B>  
<a href="#1974"><code>setLocksObjects</code></a>
<p><hr WIDTH=25% ALIGN=LEFT>
<a name="1924"></a>
<h3> <a name="//apple_ref/java/instm/FetchSpecification/qualifier">qualifier</a></h3>
public next.eo.Qualifier <code>qualifier</code>()

<P>Returns the Qualifier that indicates which records or objects the receiver is to fetch.<p>
<B>See also: </B>  
<a href="#1994"><code>setQualifier</code></a>
<p><hr WIDTH=25% ALIGN=LEFT>
<a name="1929"></a>
<h3> <a name="//apple_ref/java/instm/FetchSpecification/refreshesRefetchedObjects">refreshesRefetchedObjects</a></h3>
public boolean <code>refreshesRefetchedObjects</code>()

<P>Returns <code>true</code> if existing objects are overwritten with fetched values when they've been updated or changed. Returns <code>false</code> if existing objects aren't touched when their data is refetched (the fetched data is simply discarded). The default is <code>false</code>.<p>
<B>See also: </B>  
<a href="#1999"><code>setRefreshesRefetchedObjects</code></a>
<p><hr WIDTH=25% ALIGN=LEFT>
<a name="840"></a>
<h3> <a name="//apple_ref/java/instm/FetchSpecification/setEntityName">setEntityName</a></h3>
public void <code>setEntityName</code>(java.lang.String <em>entityName</em>)

<P>Sets the name of the root entity to be fetched to <em>entityName</em>.<p>
<B>See also: </B>  
<a href="#1891"><code>isDeep</code></a>, <a href="#1856"><code>entityName</code></a>
<p><hr WIDTH=25% ALIGN=LEFT>
<a name="1964"></a>
<h3> <a name="//apple_ref/java/instm/FetchSpecification/setHints">setHints</a></h3>
public void <code>setHints</code>(next.util.ImmutableHashtable <em>hints</em>)

<P>Sets the receiver's hints to <em>hints</em>. Any object that uses a FetchSpecification can define its own hints that it uses to alter or optimize fetch operations. For example, DatabaseContext uses hints identified by the keys PrefetchingRelationshipHintKey and CustomQueryExpressionHintKey. DatabaseContext is the only class in Enterprise Objects Framework that defines fetch specification hints. For information about DatabaseContext's hints, see the DatabaseContext class specification .<p>
<B>See also: </B>  
<a href="#1886"><code>hints</code></a>
<p><hr WIDTH=25% ALIGN=LEFT>
<a name="1969"></a>
<h3> <a name="//apple_ref/java/instm/FetchSpecification/setIsDeep">setIsDeep</a></h3>
public void <code>setIsDeep</code>(boolean <em>flag</em>)

<P>Controls whether a fetch should include sub-entities of the receiver's entity. If <em>flag</em> is <code>true</code>, sub-entities are also fetched; if <em>flag</em> is <code>false</code>, they aren't. FetchSpecifications are deep by default.<p>
For example, if you have a Person entity, class, and table with two sub-entities and subclasses, Employee and Customer, fetching Persons deeply also fetches all Employees and Customers matching the qualifier, while fetching Persons shallowly fetches only Persons matching the qualifier.<p>
<B>See also: </B>  
<a href="#1891"><code>isDeep</code></a>
<p><hr WIDTH=25% ALIGN=LEFT>
<a name="1974"></a>
<h3> <a name="//apple_ref/java/instm/FetchSpecification/setLocksObjects">setLocksObjects</a></h3>
public void <code>setLocksObjects</code>(boolean <em>flag</em>)

<P>Controls whether a fetch should result in the selected objects being locked in the data repository. If <em>flag</em> is <code>true</code> it should, if <code>false</code> it shouldn't. The default is <code>false</code>.<p>
<B>See also: </B>  
<a href="#1902"><code>locksObjects</code></a>
<p><hr WIDTH=25% ALIGN=LEFT>
<a name="1994"></a>
<h3> <a name="//apple_ref/java/instm/FetchSpecification/setQualifier">setQualifier</a></h3>
public void <code>setQualifier</code>(next.eo.Qualifier <em>qualifier</em>)

<P>Sets the receiver's qualifier to <em>qualifier</em>.<p>
<B>See also: </B>  
<a href="#1924"><code>qualifier</code></a>
<p><hr WIDTH=25% ALIGN=LEFT>
<a name="1999"></a>
<h3> <a name="//apple_ref/java/instm/FetchSpecification/setRefreshesRefetchedObjects">setRefreshesRefetchedObjects</a></h3>
public void <code>setRefreshesRefetchedObjects</code>(boolean <em>flag</em>)

<P>Controls whether existing objects are overwritten with fetched values when they've have been updated or changed. If <em>flag</em> is <code>true</code>, they are; if <em>flag</em> is <code>false</code>, they aren't (the fetched data is simply discarded). The default is <code>false</code>.<p>
For example, suppose that you fetch an employee object and then refetch it, without changing the employee between fetches. In this case, you want to refresh the employee when you refetch it, because another application might have updated the object since your first fetch. To keep your employee in sync with the employee data in the external repository, you'd need to replace the employee's outdated values with the new ones. On the other hand, if you were to fetch the employee, change it, and then refetch it, you would not want to refresh the employee. If you to refreshed it-whether or not another application had changed the employee-you would lose the changes that you had made to the object.<p>
You can get finer-grain control on a DatabaseContext's refreshing behavior than you can with a FetchSpecification by using the delegate method <code>databaseContextShouldUpdateCurrentSnapshot</code>. For more information see the DatabaseContext class specification and DatabaseContextDelegates interface specification.<p>
<B>See also: </B>  
<a href="#1929"><code>refreshesRefetchedObjects</code></a>
<p><hr WIDTH=25% ALIGN=LEFT>
<a name="886"></a>
<h3> <a name="//apple_ref/java/instm/FetchSpecification/setSortOrderings">setSortOrderings</a></h3>
public void <code>setSortOrderings</code>(next.util.ImmutableVector <em>sortOrderings</em>)

<P>Sets the receiver's array of SortOrderings to <em>sortOrderings</em>. When a fetch is performed with the receiver, the results are sorted by applying each SortOrdering in the array.<p>
<B>See also: </B>  
<a href="../SortOrdering/Frameset.html#1432" target="_top"><code>sortedVectorUsingKeyOrderVector</code></a> (SortOrdering), <a href="../SortOrdering/Frameset.html#1442" target="_top"><code>sortVectorUsingKeyOrderVector</code></a> 
(SortOrdering), <a href="#911"><code>sortOrderings</code></a>
<p><hr WIDTH=25% ALIGN=LEFT>
<a name="2009"></a>
<h3> <a name="//apple_ref/java/instm/FetchSpecification/setUsesDistinct">setUsesDistinct</a></h3>
public void <code>setUsesDistinct</code>(boolean <em>flag</em>)

<P>Controls whether duplicate objects or records are removed after fetching. If <em>flag</em> is <code>true</code> they're removed; if <em>flag</em> is <code>false</code> they aren't. FetchSpecifications by default don't use distinct.<p>
<B>See also: </B>  
<a href="#1003"><code>usesDistinct</code></a>
<p><hr WIDTH=25% ALIGN=LEFT>
<a name="911"></a>
<h3> <a name="//apple_ref/java/instm/FetchSpecification/sortOrderings">sortOrderings</a></h3>
public next.util.ImmutableVector <code>sortOrderings</code>()

<P>Returns the receiver's array of SortOrderings. When a fetch is performed with the receiver, the results are sorted by applying each SortOrdering in the array.<p>
<B>See also: </B>  
<a href="../SortOrdering/Frameset.html#1432" target="_top"><code>sortedVectorUsingKeyOrderVector</code></a> (SortOrdering), <a href="../SortOrdering/Frameset.html#1442" target="_top"><code>sortVectorUsingKeyOrderVector</code></a> 
(SortOrdering), <a href="#886"><code>setSortOrderings</code></a>
<p><hr WIDTH=25% ALIGN=LEFT>
<a name="1003"></a>
<h3> <a name="//apple_ref/java/instm/FetchSpecification/usesDistinct">usesDistinct</a></h3>
public boolean <code>usesDistinct</code>()

<P>Returns <code>true</code> if duplicate objects or records are removed after fetching, <code>false</code> if they aren't. FetchSpecifications by default don't use distinct.<p>
<B>See also: </B>  
<a href="#2009"><code>setUsesDistinct</code></a>
<p><hr WIDTH=25% ALIGN=LEFT>
<a name="1644"></a>
<h3> <a name="//apple_ref/java/instm/FetchSpecification/"></a></h3>

 
 


<i>Copyright &#169; 1998, Apple Computer, Inc.   All rights
reserved.</i>

<!-- Last updated: 01/21/98 12:30:25 -->

</body>
</html>
