/*	File:		TCommandTimer.h	Contains:	TCommandTimer is used to provide the game with a clock that periodically samples the				input device -- currently, just the keyboard.  The inputs beind received can be				used to synchronize the game action.				This code implements a time manager task that periodically grabs the state of				the keyboard.  It stores these in a buffer where the main application task 				can retrieve it.				We create a buffer for two seconds worth of commands, although in practice we'll				almost never need more than about a 1/10 of a second.				Eventually, this code will also probably need to deal with networking tasks.	Written by: Timothy Carroll		Copyright:	Copyright © 1996-1999 by Apple Computer, Inc., All Rights Reserved.				You may incorporate this Apple sample source code into your program(s) without				restriction. This Apple sample source code has been provided "AS IS" and the				responsibility for its operation is yours. You are not permitted to redistribute				this Apple sample source code as "Apple sample source code" after having made				changes. If you're going to re-distribute the source, we require that you make				it clear in the source that the code was descended from Apple sample source				code, but that you've made changes.	Change History (most recent first):				7/2/1999	Karl Groethe	Updated for Metrowerks Codewarror Pro 2.1								8/7/98		Timothy Carroll	Switched from VBL to timer task and completely											overhauled the interface.								8/15/96		Timothy Carroll	Initial Release									1/23/96     Timothy Carroll	Added include for Moofwars.h so that MrC will											compile					*/#ifndef _TCOMMANDTIMER_#define _TCOMMANDTIMER_#pragma once#include <Events.h>#if PRAGMA_STRUCT_ALIGN#pragma options align=power#endif// TInputState holds all of the data for one "frame" of the game.  For the moment,// we're just sending back a copy of the KeyMap, but in the future we might grab// the state of the mouse, network events, and so on.struct TInputState{	KeyMap		keys;};// All of the data for the command object is stored in a separate struct.struct CommandTimerData;class TCommandTimer{	public:		TCommandTimer (void);		~TCommandTimer (void);			// Call this routine with the number of frames per second that the inputs should	// be sampled.  If you pass in 0, then no timer or buffer is created. IsCommandWaiting	// will always return true, and RetrieveCommand and PeekCommand just sample the inputs.		OSStatus Initialize (SInt16 framesDesired);				// If IsAcceptingCommands is true, the timer is running.  Some functions can		// only be called if the timer is stopped.		Boolean IsAcceptingCommands (void);		void AcceptCommands (Boolean commands);				// Only call this when the timer is stopped.		void FlushCommands(void);				// PeekCommand does not remove the command from the buffer.  Use sparingly, to		// prevent buffer overflows.		Boolean IsCommandWaiting (void);		Boolean RetrieveCommand (TInputState *command);		Boolean PeekCommand (TInputState *command);	private:		CommandTimerData *timerData;	};#if PRAGMA_STRUCT_ALIGN#pragma options align=reset#endif#endif /* _TCOMMANDTIMER_ */