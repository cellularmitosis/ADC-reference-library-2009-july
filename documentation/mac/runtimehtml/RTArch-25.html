<!-- Generated by Harlequin WebMaker 2.2.3 (30-Apr-1996)
Macintosh Common Lisp Version 3.0kp2p2 [AppGen 3.0b1kp2p2] -->
<HTML> <HEAD>
<TITLE>The Code Fragment Resource</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING25></A>


<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->


<!-- Main Body -->

<CENTER>
<P>
<A HREF="RTArch-24.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="RTArch-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="RTArch-147.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="RTArch-26.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="RTArch-2.html"><B>Mac OS Runtime Architectures</B></A> / <BR><DD><A HREF="RTArch-14.html"><B>Chapter 1 - CFM-Based Runtime Architecture</B></A> / <A HREF="RTArch-23.html"><B>The Structure of Fragments</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING25-0></A>
<H2><A NAME=MARKER-9-74></A>The Code Fragment Resource</H2>
 <A NAME=MARKER-2-75></A>If the Code Fragment Manager is to search for a fragment by name, the file containing the fragment must contain a code fragment resource in the resource fork. A code fragment resource is a resource of type <CODE>'cfrg'</CODE> with ID 0 (<CODE>'cfrg'0</CODE> resource).<P>
 The code fragment resource has the form shown in <A HREF=#MARKER-9-76>Listing 1-2</A>.<P>
<B>Listing 1-2  <A NAME=MARKER-9-76></A>The code fragment resource</B><P>
<PRE>
   struct CFragResource {
      UInt32            reservedA;/* must be zero! */
      UInt32            reservedB;/* must be zero! */
      UInt16            reservedC;/* must be zero! */
      UInt16            version;
      UInt32            reservedD;/* must be zero! */
      UInt32            reservedE;/* must be zero! */
      UInt32            reservedF;/* must be zero! */
      UInt32            reservedG;/* must be zero! */
      UInt16            reservedH;/* must be zero! */
      UInt16            memberCount;
      CFragResourceMemberfirstMember;
   };
</PRE>
<UL>
<LI>The <CODE>version</CODE> field indicates the version of the code fragment resource. The current version is <CODE>1</CODE>.
<LI>The <CODE>memberCount</CODE> field indicates how many fragment entries (<CODE>'cfrg'0</CODE> entries) are described by this resource. 
<LI>Each entry of type <CODE>CFragResourceMember</CODE> describes a fragment entry, listing the type of fragment, its name, location, and so on.<P>
</UL>
 <A NAME=MARKER-2-77></A>Since the <CODE>'cfrg'0</CODE> resource is an array, it is possible to store information for several fragments in one file. The fragments remain separate and the Code Fragment Manager can prepare them independently, but they can be shipped and marketed as a single file. In addition, the code fragment resource can point to fragments of multiple architectures, allowing you to create fat applications and shared libraries that can execute on multiple platforms. See <A HREF=RTArch-86.html#MARKER-9-19>Chapter 7, "Fat Binary Programs,"</A> for more information.<P>
<DL>
<DT><B>Note</B>
<DD>Typically you can use a development tool (such as MergeFragment in MPW) to place multiple fragments in a file.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
 The structure of the code fragment resource is identical for all fragment types, although some of the field values may differ. Field values in the code fragment resource are determined and set at link time, but some may be changed later using a resource editor (such as ResEdit). Field values are defined in <CODE>CodeFragments.h</CODE>.<P>
 A code fragment resource entry has the form shown in <A HREF=#MARKER-9-78>Listing 1-3</A>.<P>
<B>Listing 1-3  <A NAME=MARKER-9-78></A>A code fragment resource entry</B><P>
<PRE>
   struct CFragResourceMember {
      CFragArchitecturearchitecture;
      UInt16         reservedA;  /* zero */
      UInt8          reservedB;  /* zero */
      UInt8          updateLevel;
      CFragVersionNumbercurrentVersion;
      CFragVersionNumberoldDefVersion;
      CFragUsage1UnionuUsage1;
      CFragUsage2UnionuUsage2;
      CFragUsage     usage;
      CFragLocatorKindwhere;
      UInt32         offset;
      UInt32         length;
      UInt32         reservedC;  /* zero */
      UInt32         reservedD;  /* zero */
      UInt16         extensionCount;/* number of extensions */
      UInt16         memberSize; /* total size in bytes */
      unsigned char  name [kDefaultCFragNameLen];
   };
</PRE>
<UL>
<LI>The <CODE>architecture</CODE> field indicates the runtime environment of the fragment. Current values for this field are as follows:<P>
<UL>
<LI><CODE>kPowerPCCFragArch</CODE> for the PowerPC runtime environment
<LI><CODE>kMotorola68KCFragArch</CODE> for the CFM-68K runtime environment 
<LI><CODE>kCompiledCFragArch</CODE>, which is conditionally set at compile time. For example, if you are compiling for the PowerPC runtime environment, this value is set to <CODE>kPowerPCCFragArch</CODE>. You can specify this value in source code that is used for both PowerPC and CFM-68K builds. <P>
</UL>
<LI>The <CODE>updateLevel</CODE> field indicates whether this fragment is a base fragment or one created to update another fragment. This field typically has the value <CODE>kIsCompleteCFrag</CODE> to indicate a base fragment.
<LI>The next two fields, <CODE>currentVersion</CODE> and <CODE>oldDefVersion</CODE>, store the current and oldest definition version numbers that the Code Fragment Manager relies on for checking compatibility with client fragments. If a fragment does not export any symbols, it does not need to check compatibility, and these values can be ignored. 
<LI>The <CODE>uUsage1</CODE> field contains a union defined as<P>
<pre>union CFragUsage1Union {<BR>  UInt32  appStackSize;<BR> };</pre><P>
If the fragment is an application, appStackSize indicates the application stack size. Typically <CODE>appStackSize</CODE> has the value <CODE>kDefaultStackSize</CODE>.
<LI><A NAME=MARKER-2-79></A>The <CODE>uUsage2</CODE> field contains a union defined as <P>
<pre>union CFragUsage2Union { <BR>  SInt16  appSubdirID;<BR> };</pre><P>
If the fragment is an application, <CODE>appSubdirID</CODE> indicates the library directory. By default, the Code Fragment Manager searches the folder containing the application and the Extensions folder when looking for import libraries, but you can specify a library directory in addition to the default search directories (see <A HREF=RTArch-21.html#MARKER-9-55>"Searching for Import Libraries," beginning on page 1-16</A>, for more information). If you do not specify a library directory, this field has the value kNoAppSubFolder. In System 7, if you want to add another library directory, you must change this field to the resource ID of an alias resource (a resource of type <CODE>'alis'</CODE>) in the application's resource fork. This resource should describe the application's library directory. For more information about alias resources, see the chapter "Alias Manager" in Inside Macintosh: Files. 
<LI>The <CODE>usage</CODE> field indicates the type of fragment. Possible values are as follows:<P>
<UL>
<LI><CODE>kApplicationCFrag</CODE> for an application
<LI><CODE>kImportLibraryCFrag</CODE> for an import library
<LI><CODE>kDropInAdditionCFrag</CODE> for a plug-in<P>
</UL>
<LI>The <CODE>where</CODE> field indicates where the fragment is located. Possible values are as follows:<P>
<UL>
<LI><CODE>kDataForkCFragLocator</CODE> if the fragment is in the data fork
<LI><CODE>kMemoryCFragLocator</CODE> if the fragment is stored in ROM
<LI><CODE>kResourceCFragLocator</CODE> if the fragment is stored in a resource <P>
</UL>
<LI>The next two fields, <CODE>offset</CODE> and <CODE>length</CODE>, indicate the starting and ending offsets of the fragment container. For example, the values <CODE>kZeroOffset</CODE> and <CODE>kCFragGoesToEOF</CODE> indicate that the container for the fragment starts at the beginning of the data fork and ends at the end of the data fork. <P>
If the fragment is stored in a resource, the <CODE>offset</CODE> field describes the type of resource, and the <CODE>length</CODE> field contains the resource ID number.
<LI>The field <CODE>extensionCount</CODE> indicates the number of extensions. See <A HREF=#MARKER-9-80>"Extensions to Code Fragment Resource Entries" (page 1-29)</A> for more information. 
<LI>The field <CODE>memberSize</CODE> contains the total size, in bytes, of the code fragment resource entry. This size includes any extensions. 
<LI>The <CODE>name</CODE> field contains the name of the fragment. <P>
</UL>
<A NAME=HEADING25-39></A>
<H3><A NAME=MARKER-9-80></A>Extensions to Code Fragment Resource Entries</H3>
 <A NAME=MARKER-2-81></A>The basic code fragment resource entry structure shown in <A HREF=#MARKER-9-78>Listing 1-3</A> is used for most applications and shared libraries. However, a code fragment resource entry can also contain one or more extensions, which appear directly after the fragment name. Such an extended code fragment resource entry stores additional information about the fragment that may be used by third-party software. For example, while the regular entry might simply indicate that a fragment <CODE>mooLib</CODE> is an import library, an extension could also indicate that it is a SOM class library that inherits from the class <CODE>cow</CODE>. <P>
<DL>
<DT><B>Note</B>
<DD>A code fragment resource can contain any combination of extended and regular entries.<EM></EM><EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
 Padding is added after the <CODE>name</CODE> field to begin the extensions on a 4-byte boundary (the length byte of the <CODE>name</CODE> string does not include this padding). All extensions must be aligned on 4-byte boundaries, with padding added after each if necessary. The <CODE>memberSize</CODE> field includes any padding added after the last extension. <P>
 An extension to the code fragment resource has the form shown in <A HREF=#MARKER-9-82>Listing 1-4</A>. <P>
<B>Listing 1-4  <A NAME=MARKER-9-82></A>Structure of a sample code fragment resource extension</B><P>
<PRE>
   struct CFragResourceSearchExtension {
      CFragResourceExtensionHeaderextensionHeader;
      ExtensionData           data [1];
   };
</PRE>
 The extensionHeader field contains a data structure defined as shown in <A HREF=#MARKER-9-83>Listing 1-5</A>.<P>
<B>Listing 1-5  <A NAME=MARKER-9-83></A>The code fragment resource extension header</B><P>
<PRE>
   struct CFragResourceExtensionHeader {
      UInt16extensionKind;
      UInt16extensionSize;
   };
</PRE>
<UL>
<LI>The <CODE>extensionKind</CODE> field defines the type of extension. Each type defines the format of the information contained in the extension. Currently only one is defined (<CODE>extensionKind</CODE> = <CODE>30EE</CODE>). 
<LI>The <CODE>extensionSize</CODE> field specifies the total size, in bytes, of this extension, including any padding necessary to round the extension to a 4-byte boundary. This size added to the offset of the extension gives the offset of the next extension (if any). <P>
</UL>
 The information that follows the <CODE>extensionHeader</CODE> field depends on the value of <CODE>extensionKind</CODE>. As an example, <A HREF=#MARKER-9-84>Listing 1-6</A> shows the format of the code fragment resource extension of type <CODE>30EE</CODE>.<P>
<B>Listing 1-6  <A NAME=MARKER-9-84></A>A code fragment resource extension of type <CODE>30EE</CODE></B><P>
<PRE>
   struct CFragResourceSearchExtension {
      CFragResourceExtensionHeaderextensionHeader;
      OSType                  libKind;
      unsigned char           qualifiers [1];
   };
</PRE>
<UL>
<LI>The <CODE>libKind</CODE> field indicates the type of fragment. Currently defined values are as follows: <P>
<UL>
<LI><CODE>kFragDocumentPartHandler</CODE> for a part handler 
<LI><CODE>kFragSOMClassLibrary</CODE> for a SOM class library
<LI><CODE>kFragInterfaceDefinition</CODE> for an interface definition library
<LI><CODE>kFragComponentMgrComponent</CODE> for a component used by the Component Manager<P>
</UL>
<LI>After the <CODE>libKind</CODE> field, you can define up to four Pascal-style strings in the <CODE>qualifiers</CODE> field. The values of these strings depend on the <CODE>libKind</CODE> field. The currently defined values are as follows:<P>
<UL>
<LI>For type <CODE>kFragDocumentPartHandler</CODE>, the first qualifier indicates the handler type. The second qualifier indicates the handler subtype (if any).
<LI>For type <CODE>kFragSOMClassLibrary</CODE>, the first qualifier indicates the base class.
<LI>For type <CODE>kFragInterfaceDefinition</CODE>, the first qualifier indicates the interface definition name. 
<LI>For type <CODE>kFragComponentMgrComponent</CODE>, the first qualifier indicates the component type. The second qualifier indicates the component subtype. <P>
For any extension, the fourth qualifier can hold the name of the fragment. Unlike the string in the <CODE>name</CODE> field, this string is visible to the client fragment. <A NAME=MARKER-2-85></A><P>
</UL>
</UL>
<A NAME=HEADING25-65></A>
<H3>Sample Code Fragment Resource Entry Definitions</H3>
 This section contains examples of the most common types of code fragment resource entries. <P>
<A NAME=HEADING25-67></A>
<H4>A PowerPC Application 'cfrg' 0 Resource Definition</H4>
 <A NAME=MARKER-2-86></A><A HREF=#MARKER-9-87>Listing 1-7</A> shows an example of a <CODE>'cfrg'0</CODE> resource definition for a PowerPC application. <P>
<B>Listing 1-7  <A NAME=MARKER-9-87></A>A sample <CODE>'cfrg'0</CODE> resource for a PowerPC runtime application</B><P>
<PRE>
#include &quot;CodeFragmentTypes.r&quot;
resource 'cfrg' (0) {
   {
      kPowerPCCFragArch,/* runtime environment */
      kIsCompleteCFrag, /* base-level library */
      kNoVersionNum,    /* current version number*/
      kNoVersionNum,    /* oldest definition version number */
      kDefaultStackSize,/* use default stack size */
      kNoAppSubFolder,  /* no library directory */
      kApplicationCFrag,/* fragment is an application */
      kDataForkCFragLocator,/* fragment is in the data fork */
      kZeroOffset,      /* beginning offset of fragment */
      kCFragGoesToEOF,  /* ending offset of fragment */
      &quot;mooApp&quot;          /* name of the fragment*/
   }
</PRE>
<UL>
<LI>The value kPowerPCCFragArch indicates that this fragment was created for use with the PowerPC runtime environment. 
<LI>The value kIsCompleteCFrag indicates that the fragment is complete by itself. 
<LI>The constant kNoVersionNum in the next two fields has the value 0, a valid version number.
<LI><A NAME=MARKER-2-88></A>The constant <CODE>kDefaultStackSize</CODE> in the next field indicates that the stack should be given the default size for the current software and hardware configuration. In System 7, you can use stack-adjusting techniques that call <CODE>GetApplLimit</CODE> and <CODE>SetApplLimit</CODE> if you determine at runtime that your application needs a larger or smaller stack. 
<LI>The constant kNoAppSubFolder indicates that there is no library search folder. 
<LI>The value <CODE>kApplicationCFrag </CODE>indicates that this is an application. 
<LI>The value <CODE>kDataForkCFragLocator</CODE> indicates that the fragment is stored in the data fork of the file. 
<LI>The values <CODE>kZeroOffset</CODE> and <CODE>kCFragGoesToEOF</CODE> in the next two fields indicate that the container for the fragment starts at the beginning of the data fork and ends at the end of the data fork. 
<LI>The default fragment name is usually the name of the output file from the linker, but you can assign a specific name if you wish. <A NAME=MARKER-2-89></A><P>
</UL>
<A NAME=HEADING25-80></A>
<H4>A CFM-68K Application 'cfrg' 0 Resource Definition</H4>
 <A NAME=MARKER-2-90></A><A HREF=#MARKER-9-91>Listing 1-8</A> shows a sample <CODE>'cfrg'0</CODE> resource definition for a CFM-68K runtime application. The fields that have values different from those in a PowerPC application <CODE>'cfrg'0</CODE> resource entry are underlined.<P>
<B>Listing 1-8  A sample <CODE>'cfrg'0</CODE> resource for a CFM-68K runtime application<A NAME=MARKER-9-91></A></B><P>
<PRE>
#include &quot;CodeFragmentTypes.r&quot;
resource 'cfrg' (0) {
   {
      kMotorola68KCFragArch,   /* runtime environment */
      kIsCompleteCFrag,        /* base-level library */
      kNoVersionNum,           /* no current version number*/
      kNoVersionNum,           /* no oldest definition version number */
      kDefaultStackSize,       /* use default stack size */
      kNoAppSubFolder,         /* no library directory */
      kApplicationCFrag,       /* fragment is an application */
      kResourceCFragLocator,   /* fragment is in a resource */
      kRSEG,                   /* resource type = 'rseg' */
      kSegIDZero,              /* resource ID = 0 */
      &quot;mooApp&quot;       /* name of the application fragment*/
   }
</PRE>
<UL>
<LI>The constant <CODE>kMotorola68KCFragArch</CODE> in the first field indicates that this fragment was created for use with the CFM-68K runtime environment. 
<LI>The next underlined value, <CODE>kResourceCFragLocator</CODE>, indicates that this is a segmented application stored in resources. 
<LI>The next two underlined fields, <CODE>kRSEG</CODE> and <B>kSegIDZero</B>, tell the Code Fragment Manager that the initial container to load is contained in a resource of type <CODE>'rseg'</CODE> with a resource ID 0. <P>
</UL>
 For more information about the structure of CFM-68K applications, see <A HREF=RTArch-103.html#MARKER-9-16>"CFM-68K Application Structure," beginning on page 9-3</A>. <A NAME=MARKER-2-92></A><P>
<A NAME=HEADING25-88></A>
<H4>A Shared Library 'cfrg' 0 Resource Definition</H4>
 <A NAME=MARKER-2-93></A>Shared libraries have essentially the same <CODE>'cfrg'0</CODE> resource entry for both PowerPC and CFM-68K implementations (only the field indicating the runtime environment differs). <P>
 <A HREF=#MARKER-9-94>Listing 1-9</A> shows the <CODE>'cfrg'0</CODE> resource for an import library (plug-ins are identical except the fragment type is set to <CODE>kDropInAdditionCFrag</CODE>). Values that differ from an application's <CODE>'cfrg'0</CODE> resource are underlined. <P>
<B>Listing 1-9  <A NAME=MARKER-9-94></A>A sample <CODE>'cfrg'0</CODE> resource for an import library</B><P>
<PRE>
#include &quot;CodeFragmentTypes.r&quot;
resource 'cfrg' (0) {
   {
      kPowerPCCFragArch,          /* runtime environment */
      kIsCompleteCFrag,           /* base-level library */
      6,                          /* current version number*/
      4,                          /* oldest definition version number */
      kDefaultStackSize,          /* use default stack size */
      kNoAppSubFolder,            /* no library directory */
      kImportLibraryCFrag,        /* fragment is a library */
      kDataForkCFragLocator,      /* fragment is in the data fork */
      kZeroOffset,                /* fragment starts at offset 0 */
      kCFragGoesToEOF,            /* fragment occupies entire fork */
      &quot;mooLib&quot;                    /* name of the library fragment */
   }
</PRE>
<UL>
<LI>The first two underlined fields store the current and definition version numbers that the Code Fragment Manager relies on for checking compatibility with client fragments. If you do not specify version numbers when you link, the version numbers are set to 0. See <A HREF=RTArch-22.html#MARKER-9-58>"Checking for Compatible Import Libraries," beginning on page 1-19</A>, for more details.
<LI>The application stack size field is ignored for shared libraries. 
<LI>The library directory field is ignored for shared libraries. 
<LI><A NAME=MARKER-2-95></A>The value <CODE>kImportLibraryCFrag</CODE> specifies that this is an import library. A plug-in would have the value <CODE>kDropInAdditionCFrag</CODE>.
<LI>As you do with an application, you may supply a specific library name. However, for an import library you must do so before linking to a client because the fragment name is bound to the client at link ti<A NAME=MARKER-2-96></A>me. <EM><A NAME=MARKER-2-97></A></EM><P>
</UL>
</BLOCKQUOTE>
<HR>
<center>
<A HREF="RTArch-24.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="RTArch-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="RTArch-147.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="RTArch-26.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="RTArch-3.html">&copy; Apple Computer, Inc.</A><br>11 MARCH 1997<P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML> 
