<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>Quartz Programming Guide for QuickDraw Developers: Basic Drawing</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Basic Drawing"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP40001098-CH220" title="Basic Drawing"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../index.html#//apple_ref/doc/uid/TP30000440-TP30000420" target="_top">Carbon</a> &gt; <a href="../../../GraphicsImaging-date.html#//apple_ref/doc/uid/TP30000440-TP30000420-TP30000450" target="_top">Graphics &amp; Imaging</a> &gt; <a href="../tq_intro/tq_intro.html#//apple_ref/doc/uid/TP40001098-CH201-TPXREF101">Quartz Programming Guide for QuickDraw Developers</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../tq_strategies/tq_strategies.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../tq_color/tq_color.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        
        <a name="//apple_ref/doc/uid/TP40001098-CH220-TPXREF101" title="Basic Drawing"></a><h1>Basic Drawing</h1><p>There are some basic similarities between drawing in QuickDraw and Quartz. Drawing, whether in QuickDraw or Quartz, involves obtaining a preconfigured drawing environment, specifying the geometry of shapes, and applying color to shape outlines, interiors, or both. But there are many differences that you will want to be aware of.</p><p>One important difference is that QuickDraw does not always make a clear distinction between specifying the geometry of an object and drawing the object. For example, you can’t specify lines, ovals, or rounded rectangles without drawing them. In Quartz, there is a clean separation between constructing an object (operations such as adding a rectangle to a path or creating a shading) and drawing the object (operations such as stroking and filling the path or drawing the shading).</p><p>There are many other differences. This chapter discusses basic drawing issues and how to accomplish a variety of drawing tasks using Quartz.</p><ul class="ul"><li class="li"><p><span class="content_text"><a href="tq_other.html#//apple_ref/doc/uid/TP40001098-CH220-CJBHEACI">“Coordinate Space”</a></span> describes the QuickDraw, Quartz, and HIView coordinate systems, and how to convert between QuickDraw and Quartz coordinates.</p></li><li class="li"><p><span class="content_text"><a href="tq_other.html#//apple_ref/doc/uid/TP40001098-CH220-CJBFFFEC">“Drawing Destinations”</a></span> compares QuickDraw and Quartz destinations and provides references to code examples that shows how to obtain graphics contexts.</p></li><li class="li"><p><span class="content_text"><a href="tq_other.html#//apple_ref/doc/uid/TP40001098-CH220-CJBJHAFE">“Graphics State and Global Effects”</a></span> lists the Quartz graphics state parameters.</p></li><li class="li"><p><span class="content_text"><a href="tq_other.html#//apple_ref/doc/uid/TP40001098-CH220-CJBGGEED">“Color Blend Modes”</a></span> discusses how paint is composited to a background in Quartz and provides examples of using blend modes to colorize one image and draw a portion of another.</p></li><li class="li"><p><span class="content_text"><a href="tq_other.html#//apple_ref/doc/uid/TP40001098-CH220-CJBICDJJ">“Alternatives to QuickDraw Drawing Functions”</a></span> lists many QuickDraw region functions and suggests alternative functions in Quartz.</p></li><li class="li"><p><span class="content_text"><a href="tq_other.html#//apple_ref/doc/uid/TP40001098-CH220-CJBFDFGA">“Constructing and Drawing Shapes”</a></span> shows how to construct and draw two-dimensional shapes in Quartz and provides emulation routines for many QuickDraw functions.</p></li><li class="li"><p><span class="content_text"><a href="tq_other.html#//apple_ref/doc/uid/TP40001098-CH220-CJBEFGBD">“Converting an Arbitrary QuickDraw Region to a Quartz Path”</a></span> provides a generalized routine for handling region conversions.</p></li><li class="li"><p><span class="content_text"><a href="tq_other.html#//apple_ref/doc/uid/TP40001098-CH220-CJBHAEBG">“Anti-aliasing”</a></span> describes what it is in Quartz and what settings affect it.</p></li><li class="li"><p><span class="content_text"><a href="tq_other.html#//apple_ref/doc/uid/TP40001098-CH220-CJBCFBID">“Clipping”</a></span> compares QuickDraw and Quartz clipping and shows how to use clipping to draw the intersection and difference of two shapes.</p></li></ul><a name="//apple_ref/doc/uid/TP40001098-CH220-CJBHEACI" title="Coordinate Space"></a><h2>Coordinate Space</h2><p>QuickDraw and Quartz coordinate space differ most in the location you draw to and the location of the origin. In Quartz, you draw to user space, which is device-independent and pixel-free. By drawing to user space, you can send the same drawing to any number of destinations—screen, printer, bitmap, PDF—and Quartz converts the user space coordinates to the appropriate device space coordinates. No math required on your part!</p><p>When you draw with Quartz, you need only to work in user space. If for some reason your application needs to obtain the affine transform that Quartz uses to convert between user and device space, you can call the function <code><a href="../../../../GraphicsImaging/Reference/CGContext/Reference/reference.html#//apple_ref/c/func/CGContextGetUserSpaceToDeviceSpaceTransform" target="_top">CGContextGetUserSpaceToDeviceSpaceTransform</a></code>, introduced in Mac OS X v10.4. Quartz also adds functions in Mac OS X v10.4 that convert geometries (points, sizes, and rectangles) between device and user space.</p><p>The Quartz user space is modeled on the Cartesian plane—coordinates are single-precision, floating-point numbers, and by default, the positive y-axis extends upward. In a new graphics context, the origin corresponds to the lower-left corner of the page, as shown in <span class="content_text">Figure 2-1</span>. QuickDraw, by comparison, uses integer coordinates whose origin corresponds to the upper-left corner of a page. HIView, uses floating-point coordinates whose origin corresponds to the upper-left corner of a page.</p><br/><div><a name="//apple_ref/doc/uid/TP40001098-CH220-CJBDBAHB" title="Figure 2-1Comparison of origins for QuickDraw, Quartz, and HIView"></a><p><strong>Figure 2-1&nbsp;&nbsp;</strong>Comparison of origins for QuickDraw, Quartz, and HIView</p><img src = "../art/origin_comparison.gif" alt = "Comparison of origins for QuickDraw, Quartz, and HIView" width="444" height="160"></div><br/><p>You can use Quartz translation and scaling functions to convert between coordinate systems. <span class="content_text">Listing 2-1</span> shows how to switch from Quartz coordinates to one whose origin is in the upper-left corner by modifying the context matrix prior to drawing.</p><a name="//apple_ref/doc/uid/TP40001098-CH220-CJBIGABC" title="Listing 2-1Code that transforms the Quartz origin to be at the upper-left"></a><p class="codesample"><strong>Listing 2-1&nbsp;&nbsp;</strong>Code that transforms the Quartz origin to be at the upper-left</p><div class="codesample"><table><tr><td scope="row"><pre>CGContextSaveGState (myContext);<span></span></pre></td></tr><tr><td scope="row"><pre>CGContextTranslateCTM (myContext, 0, myOrigin.y + myPortHeight);<span></span></pre></td></tr><tr><td scope="row"><pre>CGContextScaleCTM (myContext, 1.0f, -1.0f);<span></span></pre></td></tr><tr><td scope="row"><pre>// Your drawing code here.<span></span></pre></td></tr><tr><td scope="row"><pre>CGContextRestoreGState (myContext);<span></span></pre></td></tr></table></div><p>The function <code><a href="../../../../GraphicsImaging/Reference/CGContext/Reference/reference.html#//apple_ref/c/func/CGContextTranslateCTM" target="_top">CGContextTranslateCTM</a></code> translates the coordinate system so that the <em>y</em> values are moved toward the top of the HIView by the height of the HIView bounding rectangle. If you were to draw now, your drawing would be outside the HIView, not in a visible area.</p><p>The function <code><a href="../../../../GraphicsImaging/Reference/CGContext/Reference/reference.html#//apple_ref/c/func/CGContextScaleCTM" target="_top">CGContextScaleCTM</a></code> code flips the y-coordinates by a factor of –1.0, effectively flipping the coordinates into the HIView. After this operation, the origin is at the lower left of the HIView, with the y values increasing from bottom to top. The x values are unchanged; they still increase from left to right.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40001098-CH220-DontLinkElementID_45" title="Tip"></a><p><strong>Tip:</strong>&nbsp; Spend time to figure out the coordinates and to translate from one coordinate system to the other. Quartz transforms make it easy to switch back and forth, but it’s also easy to make mistakes until you have practiced. Be careful not to perform transformations in the wrong order. If drawing doesn’t show up as you expect, use the function <code><a href="../../../../GraphicsImaging/Reference/CGContext/Reference/reference.html#//apple_ref/c/func/CGContextGetClipBoundingBox" target="_top">CGContextGetClipBoundingBox</a></code> to see if the bounding box of the drawing area is where you expect it to be. See <span class="content_text"><a href="../../../../GraphicsImaging/Conceptual/drawingwithquartz2d/dq_affine/dq_affine.html#//apple_ref/doc/uid/TP30001066-CH204" target="_top">Transforms</a></span> in <em><a href="../../../../GraphicsImaging/Conceptual/drawingwithquartz2d/index.html#//apple_ref/doc/uid/TP30001066" target="_top">Quartz 2D Programming Guide</a></em> for more information.</p></div><p>If you use HIView in conjunction with Quartz, and draw to a graphics context that you obtain from HIView, that graphics context uses HIView coordinates. HIView places the origin in the upper-left corner of the view, but it uses floating-point values just like Quartz does. HIView uses the upper left to ensure that the coordinates of objects, such as controls, do not change as the user resizes the window. When you want to draw a Quartz image (CGImage) to an HIView, make sure that you use the HIView function <code><a href="../../../Reference/HIViewReference/Reference/reference.html#//apple_ref/c/func/HIViewDrawCGImage" target="_top">HIViewDrawCGImage</a></code>, which orients the image appropriately for the HIView coordinate system.</p><p>Keep in mind that text drawing is affected by the coordinate system. Quartz, the HIToolBox, and ATSUI are among the APIs that provide support for drawing text. You need to be aware of the coordinate-system assumptions made by each text drawing function as well as the transformations you’ve performed on the Quartz coordinate system. For example, if you use the default Quartz coordinate system and the Quartz text drawing functions (<code><a href="../../../../GraphicsImaging/Reference/CGContext/Reference/reference.html#//apple_ref/c/func/CGContextShowText" target="_top">CGContextShowText</a></code>, <code><a href="../../../../GraphicsImaging/Reference/CGContext/Reference/reference.html#//apple_ref/c/func/CGContextShowTextAtPoint" target="_top">CGContextShowTextAtPoint</a></code>, <code><a href="../../../../GraphicsImaging/Reference/CGContext/Reference/reference.html#//apple_ref/c/func/CGContextShowGlyphs" target="_top">CGContextShowGlyphs</a></code>, and so forth), then text is drawn in the correct orientation. If you use the default Quartz coordinate system and the HIToolbox text drawing functions (such as <code><!--a-->HIThemeDrawTextBox<!--/a--></code>), text appears inverted. In the case of <code><!--a-->HIThemeDrawTextBox<!--/a--></code> you can remedy this by specifying the option <code>kHIThemeOrientationInverted</code>.</p><p>The details of text drawing and coordinate systems aren’t discussed here. It’s an issue you’ll want to investigate further. However, if you draw text and it either doesn’t appear or it appears inverted, take a close look at the coordinate system, the transformations you’ve performed, and the assumptions of the text drawing function you use. Also keep in mind that Quartz has a text matrix that can be transformed separately from default user space. For more information, see <span class="content_text"><a href="../../../../GraphicsImaging/Conceptual/drawingwithquartz2d/dq_text/dq_text.html#//apple_ref/doc/uid/TP30001066-CH213" target="_top">Text</a></span> in <em><a href="../../../../GraphicsImaging/Conceptual/drawingwithquartz2d/index.html#//apple_ref/doc/uid/TP30001066" target="_top">Quartz 2D Programming Guide</a></em>.</p><a name="//apple_ref/doc/uid/TP40001098-CH220-CJBFFFEC" title="Drawing Destinations"></a><h2>Drawing Destinations</h2><p>In Quartz, all drawing takes place in a drawing environment called a graphics context. You can think of a graphics context as being equivalent to a QuickDraw grafport. Graphics contexts are really drawing destinations that are preconfigured for a specific use, including drawing to a window or printer, creating PDF content, creating a bitmap, drawing to an OpenGL context, or drawing to an offscreen layer. Some graphics contexts are multipaged, such as PDF and printing contexts. Every graphics context has a graphics state stack that you can use to save snapshots of the current drawing state. This allows you to modify the drawing state and then return back to a previous state.</p><p>Although graphics contexts are specialized for different drawing destinations, Quartz is designed to make as few assumptions as possible about the output device. For example, the Print Preview feature in Mac OS X redirects your output from a printing context to a PDF document and then to a raster display, with no loss of information or quality. This means that you simply draw to user space and let Quartz convert those coordinates appropriately for the graphics context.</p><p>Before you perform any drawing in Quartz, you need to obtain a graphics context because most drawing functions operate on a graphics context; that’s where your drawing is directed. Quartz provides creation functions for bitmap graphics contexts, PDF graphics contexts, OpenGL graphics contexts, and layers (which are derived from a graphics context, described in <span class="content_text"><a href="../../../../GraphicsImaging/Conceptual/drawingwithquartz2d/dq_layers/dq_layers.html#//apple_ref/doc/uid/TP30001066-CH219" target="_top">CGLayer Drawing</a></span> in <em><a href="../../../../GraphicsImaging/Conceptual/drawingwithquartz2d/index.html#//apple_ref/doc/uid/TP30001066" target="_top">Quartz 2D Programming Guide</a></em>). </p><p>You obtain graphics contexts that are used for drawing to windows or a printer from the appropriate framework. Carbon (HIView) and Cocoa provide window graphics contexts. See <span class="content_text"><a href="../../../../GraphicsImaging/Conceptual/drawingwithquartz2d/dq_context/dq_context.html#//apple_ref/doc/uid/TP30001066-CH203-CJBDCHAC" target="_top">Creating a Window Graphics Context</a></span> in <em><a href="../../../../GraphicsImaging/Conceptual/drawingwithquartz2d/index.html#//apple_ref/doc/uid/TP30001066" target="_top">Quartz 2D Programming Guide</a></em>.</p><p>The Printing framework manages printing graphics contexts. In Mac OS X v10.4, you use the printing functions <code>PMSessionBeginCGDocument</code> and <code>PMSessionGetCGGraphicsContext</code>. Prior to Mac OS X v10.4 you use <code><a href="../../../../GraphicsImaging/Reference/CorePrintRef/DeprecationAppendix/AppendixADeprecatedAPI.html#//apple_ref/c/func/PMSessionSetDocumentFormatGeneration" target="_top">PMSessionSetDocumentFormatGeneration</a></code> passing the constant <code>kPMGraphicsContextCoreGraphics</code>. See <span class="content_text"><a href="../../../../GraphicsImaging/Conceptual/drawingwithquartz2d/dq_context/dq_context.html#//apple_ref/doc/uid/TP30001066-CH203-CJBJDEFF" target="_top">Obtaining a Graphics Context for Printing</a></span> in <em><a href="../../../../GraphicsImaging/Conceptual/drawingwithquartz2d/index.html#//apple_ref/doc/uid/TP30001066" target="_top">Quartz 2D Programming Guide</a></em>.</p><a name="//apple_ref/doc/uid/TP40001098-CH220-CJBJHAFE" title="Graphics State and Global Effects"></a><h2>Graphics State and Global Effects</h2><p>In a drawing environment the graphics state defines the global framework within which graphics operations execute. A well-designed graphics state model helps to create a stable, consistent drawing environment and makes it easier to use a graphics API.</p><p>Quartz doesn’t maintain any global graphics state as QuickDraw does. Instead, the drawing state is maintained for each graphics context. Graphics contexts have attributes that are fixed at creation time, and parameters that you can modify while drawing. For example, in a bitmap context the pixel data is an attribute and the fill color is a parameter.</p><p>Every graphics context has a graphics state stack that you can use to save and restore snapshots of the current drawing state using the functions <code><a href="../../../../GraphicsImaging/Reference/CGContext/Reference/reference.html#//apple_ref/c/func/CGContextSaveGState" target="_top">CGContextSaveGState</a></code> and <code><a href="../../../../GraphicsImaging/Reference/CGContext/Reference/reference.html#//apple_ref/c/func/CGContextRestoreGState" target="_top">CGContextRestoreGState</a></code>. There is no way in Quartz for you to get the current setting for a graphics state parameter. If you want that information, you need to track the settings yourself. Perhaps a better approach is to think in terms of bracketing your code with calls to save and restore the graphics state. Quartz provides “set” functions for changing each graphic state parameter. Graphics state parameters are discussed in detail in various chapters in <em><a href="../../../../GraphicsImaging/Conceptual/drawingwithquartz2d/index.html#//apple_ref/doc/uid/TP30001066" target="_top">Quartz 2D Programming Guide</a></em>. Start with the Graphics State section in the overview chapter, which includes a cross reference to the chapter that’s appropriate for a particular graphics state parameter.</p><p>The graphic state parameters include the following:</p><ul class="ul"><li class="li"><p>Current transformation matrix (CTM)</p></li><li class="li"><p>Clipping area</p></li><li class="li"><p>Line characteristics: width, join, cap, dash, miter limit</p></li><li class="li"><p>Anti-aliasing setting</p></li><li class="li"><p>Color: fill and stroke setting</p></li><li class="li"><p>Global alpha value (transparency)</p></li><li class="li"><p>Rendering intent</p></li><li class="li"><p>Color space: fill and stroke settings</p></li><li class="li"><p>Text settings: font, font size, character spacing, text drawing mode</p></li><li class="li"><p>Blend mode</p></li></ul><a name="//apple_ref/doc/uid/TP40001098-CH220-CJBGGEED" title="Color Blend Modes"></a><h2>Color Blend Modes</h2><p><code>CopyBits</code> uses transfer modes to combine pixels in a source and destination image in different ways. As stated earlier, Quartz has no replacement for QuickDraw transfer modes. But depending on what you want to achieve, Quartz blend modes might provide the answer. In Quartz, compositing is based on alpha information. A graphics context has a global alpha parameter that determines the opacity of any object that’s drawn, including images. In addition, an image can have its own alpha channel that determines the opacity of each pixel when the image is composited with the background.</p><p>In Mac OS X v10.4 and later, Quartz provides an additional compositing parameter, called the <strong>blend mode</strong>, that determines how source and background colors interact. (Quartz blend modes are based on PDF blend modes.) You can use the blend mode to get special compositing effects such as tinting and colorizing when drawing images. The blend mode is a part of the graphics state in a context, and you can change it by passing a constant to the function <code><a href="../../../../GraphicsImaging/Reference/CGContext/Reference/reference.html#//apple_ref/c/func/CGContextSetBlendMode" target="_top">CGContextSetBlendMode</a></code>. </p><p>When the blend mode is the default value (<code>kCGBlendModeNormal</code>), the blend color is simply the source color. In the normal blend mode Quartz performs alpha blending by combining the components of the source color with the components of the destination color using the formula:</p><p><code>destination = (alpha * source) + (1 - alpha) * destination</code></p><p>Other blend modes combine source and background colors in various ways. For example, the darken blend mode selects the darker of the source and background colors. While blend modes and transfer modes are not the same mathematically, there may be some blend modes that could be used as replacements for transfer modes.</p><p>Blend modes are described in detail in <em><a href="../../../../GraphicsImaging/Conceptual/drawingwithquartz2d/index.html#//apple_ref/doc/uid/TP30001066" target="_top">Quartz 2D Programming Guide</a></em>. In the next two sections you’ll see how you can use the color blend mode to colorize an image and the lighten blend mode to show part of an image. But for detailed information about using all the Quartz blend modes, including examples of the sorts of results you can get, see <span class="content_text"><a href="../../../../GraphicsImaging/Conceptual/drawingwithquartz2d/dq_paths/dq_paths.html#//apple_ref/doc/uid/TP30001066-CH211-BCIGICEF" target="_top">Setting Blend Modes</a></span>. If you depend heavily on transfer modes for advanced imaging effects, also take a look at the <em><a href="../../../../GraphicsImaging/Conceptual/CoreImaging/index.html#//apple_ref/doc/uid/TP30001185" target="_top">Core Image Programming Guide</a></em>, which describes Core Image blend mode filters.</p><a name="//apple_ref/doc/uid/TP40001098-CH220-CJBCCEDC" title="Colorizing an Image"></a><h3>Colorizing an Image</h3><p>One way that you can use the color blend mode is to colorize an image. Draw the image you want to colorize. Then set the blend mode by passing the constant <code>kCGBlendModeColor</code> to the function <code><a href="../../../../GraphicsImaging/Reference/CGContext/Reference/reference.html#//apple_ref/c/func/CGContextSetBlendMode" target="_top">CGContextSetBlendMode</a></code>. Draw and fill a rectangle (or other shape) using the color you want to use for colorizing the image. The code in <span class="content_text">Listing 2-2</span> draws a fully opaque red rectangle (see <span class="content_text"><a href="tq_other.html#//apple_ref/doc/uid/TP40001098-CH220-CJBJCHFD">Figure 2-2</a></span>) over the image of the jumper, to achieve the result shown on the right side of the figure. Note that the entire image of the jumper is not colorized because the red rectangle is smaller than the image.</p><a name="//apple_ref/doc/uid/TP40001098-CH220-CJBHJHJG" title="Listing 2-2Code that uses the color blend mode"></a><p class="codesample"><strong>Listing 2-2&nbsp;&nbsp;</strong>Code that uses the color blend mode</p><div class="codesample"><table><tr><td scope="row"><pre> CGContextSaveGState (context);<span></span></pre></td></tr><tr><td scope="row"><pre> CGContextDrawImage(context, myRect1, image);<span></span></pre></td></tr><tr><td scope="row"><pre> CGContextSetBlendMode(context, kCGBlendModeColor);<span></span></pre></td></tr><tr><td scope="row"><pre> CGContextSetRGBFillColor (context, 0.8, 0.0, 0.0, 1.0);<span></span></pre></td></tr><tr><td scope="row"><pre> CGContextFillRect (context, myRect2);<span></span></pre></td></tr><tr><td scope="row"><pre> CGContextSaveGState (context);<span></span></pre></td></tr></table></div><br/><div><a name="//apple_ref/doc/uid/TP40001098-CH220-CJBJCHFD" title="Figure 2-2A jumper, a red rectangle, and the jumper image colorized"></a><p><strong>Figure 2-2&nbsp;&nbsp;</strong>A jumper, a red rectangle, and the jumper image colorized</p><img src = "../art/colorize.jpg" alt = "A jumper, a red rectangle, and the jumper image colorized" ></div><br/><a name="//apple_ref/doc/uid/TP40001098-CH220-CJBIIDFH" title="Showing Part of an Image"></a><h3>Showing Part of an Image</h3><p>Another interesting effect you can achieve by using a blend mode is to show only a portion of an image. Normally you would achieve this effect using clipping. You use the lighten blend mode and an opaque black shape that defines the area of the image that you want to show. As shown in <span class="content_text">Listing 2-3</span>, you fill a shape (here the code uses a rectangle) with opaque black, set the blend mode to <code>kCGBlendModeLighten</code>, and then draw the image. <span class="content_text"><a href="tq_other.html#//apple_ref/doc/uid/TP40001098-CH220-CJBEGECI">Figure 2-3</a></span> shows the rectangle, the original image of a jumper, and the resulting image. The part of the image you can see coincides exactly with the rectangle.</p><a name="//apple_ref/doc/uid/TP40001098-CH220-CJBBCHHA" title="Listing 2-3Code that uses the lighten blend mode to show part of an image "></a><p class="codesample"><strong>Listing 2-3&nbsp;&nbsp;</strong>Code that uses the lighten blend mode to show part of an image </p><div class="codesample"><table><tr><td scope="row"><pre> CGContextSaveGState (context);<span></span></pre></td></tr><tr><td scope="row"><pre> CGContextSetRGBFillColor (context, 0.0, 0.0, 0.0, 1.0);<span></span></pre></td></tr><tr><td scope="row"><pre> CGContextFillRect (context, myRect);<span></span></pre></td></tr><tr><td scope="row"><pre> CGContextSetBlendMode (context, kCGBlendModeLighten);<span></span></pre></td></tr><tr><td scope="row"><pre> CGContextDrawImage (context, contextRect, image);<span></span></pre></td></tr><tr><td scope="row"><pre> CGContextRestoreGState (context);<span></span></pre></td></tr></table></div><br/><div><a name="//apple_ref/doc/uid/TP40001098-CH220-CJBEGECI" title="Figure 2-3An opaque black rectangle, a jumper, and the resulting image"></a><p><strong>Figure 2-3&nbsp;&nbsp;</strong>An opaque black rectangle, a jumper, and the resulting image</p><img src = "../art/lighten_image.jpg" alt = "An opaque black rectangle, a jumper, and the resulting image" ></div><br/><a name="//apple_ref/doc/uid/TP40001098-CH220-CJBFDFGA" title="Constructing and Drawing Shapes"></a><h2>Constructing and Drawing Shapes</h2><p>You define arbitrary two-dimensional shapes in Quartz using graphics paths. If you haven’t already done so, you should read <span class="content_text"><a href="../../../../GraphicsImaging/Conceptual/drawingwithquartz2d/dq_paths/dq_paths.html#//apple_ref/doc/uid/TP30001066-CH211" target="_top">Paths</a></span> in <em><a href="../../../../GraphicsImaging/Conceptual/drawingwithquartz2d/index.html#//apple_ref/doc/uid/TP30001066" target="_top">Quartz 2D Programming Guide</a></em>. That chapter describes the rich set of path construction and drawing operations, and also describes how to use a path as a clipping mask.</p><p>Quartz provides two sets of functions for drawing paths. One set draws directly to a graphics context. These functions are defined in <em><a href="../../../../GraphicsImaging/Reference/CGContext/index.html#//apple_ref/doc/uid/TP30000950" target="_top">CGContext Reference</a></em> and each use the CGContext prefix. You construct a path in a graphics context by calling functions that add to the path (lines, rectangle, ellipses, and so forth). Then you paint the path (by stroking, filling, or both). After you paint the path, it is no longer accessible; it’s gone from the context.</p><p>The other set of functions draws to a CGPath object (<code><!--a target="_top" -->CGPathRef<!--/a--></code>) data type. These functions are defined in <em><a href="../../../../GraphicsImaging/Reference/CGPath/index.html#//apple_ref/doc/uid/TP30000959" target="_top">CGPath Reference</a></em>, and each use the CGPath prefix. You call functions that build a path in the CGPath object. Then you paint the path (by stroking, filling, or both). As long as you keep the CGPath object around, you can paint the path whenever you like. For shapes that you plan to reuse, CGPath objects are what you want to use.</p><p>Here are a few important differences between paths and regions:</p><ul class="ul"><li class="li"><p>Paths are designed with device and resolution independence in mind. There’s no notion of adding pixels to a path or converting a bitmap into a path.</p></li><li class="li"><p>The functions you use to construct a path are entirely separate from the functions you use to draw the path.</p></li><li class="li"><p>Paths have a direction. The elements in a path—lines, curves, and so on—are sequentially ordered, and this information is retained in the path definition.</p></li><li class="li"><p>Path operations for adding Bézier curves make it possible to construct shapes with complex, curvilinear contours. QuickDraw has nothing comparable to this feature.</p></li><li class="li"><p>When a path is filled with color or used for clipping, Quartz uses standard, well-defined fill rules to determine the area inside the path.</p></li></ul><p>The next sections show how to implement functions that are equivalent to the QuickDraw function <code>PaintArc</code>, <code>FrameArc</code>, <code>PaintOval</code>, <code>FrameOval</code>, <code>PaintRect</code>, and <code>FrameRect</code>. You’ll also see how to create rounded rectangles and how to draw the union and symmetric difference of two shapes. Most of the code in the next sections is excerpted from the QuartzShapes sample code project, which you can download from <span class="content_text"><a href="http://developer.apple.com/samplecode/" target="_top">http://developer.apple.com/samplecode/</a></span>.</p><a name="//apple_ref/doc/uid/TP40001098-CH220-DontLinkElementID_15" title="Arcs: Replacing FrameArc and PaintArc"></a><h3>Arcs: Replacing FrameArc and PaintArc</h3><p><span class="content_text">Figure 2-4</span> shows examples of arcs that are stroked or filled. In Quartz, the general procedure for drawing a shape is to first construct a path and then to fill it, stroke it, or fill and stroke it. To emulate the QuickDraw functions <code>FrameArc</code> and <code>PaintArc</code>, you first need to write a function that creates an arc path. <span class="content_text"><a href="tq_other.html#//apple_ref/doc/uid/TP40001098-CH220-CJBCEHCE">Listing 2-4</a></span> shows a routine that constructs an arc path.</p><br/><div><a name="//apple_ref/doc/uid/TP40001098-CH220-CJBGDGEA" title="Figure 2-4Arcs drawn using Quartz"></a><p><strong>Figure 2-4&nbsp;&nbsp;</strong>Arcs drawn using Quartz</p><img src = "../art/arcs.gif" alt = "Arcs drawn using Quartz" width="342" height="201"></div><br/><p>In addition to the graphics context that you want to draw to, the <code>pathForArc</code> routine takes the same parameters that you would pass to the <code><a href="../../../Reference/QuickDraw_Ref/DeprecationAppendix/AppendixADeprecatedAPI.html#//apple_ref/doc/c_ref/FrameArc" target="_top">FrameArc</a></code> and <code>PaintArc</code> functions: a rectangle whose center specifies the origin of the arc you want to draw as well as the x radius and y radius of the arc, the starting angle (in degrees), and the angle (in degrees) of the arc. A detailed explanation for each numbered line of code appears following the listing.</p><a name="//apple_ref/doc/uid/TP40001098-CH220-CJBCEHCE" title="Listing 2-4A routine that constructs an arc path"></a><p class="codesample"><strong>Listing 2-4&nbsp;&nbsp;</strong>A routine that constructs an arc path</p><div class="codesample"><table><tr><td scope="row"><pre>void pathForArc (CGContextRef context, CGRect r,<span></span></pre></td></tr><tr><td scope="row"><pre>                    int startAngle, int arcAngle)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    float start, end;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    CGContextSaveGState(context);<span>// 1</span></pre></td></tr><tr><td scope="row"><pre>    CGContextTranslateCTM(context, r.origin.x + r.size.width/2,<span>// 2</span></pre></td></tr><tr><td scope="row"><pre>                                 r.origin.y + r.size.height/2);,<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    CGContextScaleCTM(context, r.size.width/2, r.size.height/2);<span>// 3</span></pre></td></tr><tr><td scope="row"><pre>    if (arcAngle > 0) {<span>// 4</span></pre></td></tr><tr><td scope="row"><pre>        start = (90 - startAngle - arcAngle) * M_PI / 180;<span></span></pre></td></tr><tr><td scope="row"><pre>        end = (90 - startAngle) * M_PI / 180;<span></span></pre></td></tr><tr><td scope="row"><pre>    } else {<span></span></pre></td></tr><tr><td scope="row"><pre>        start = (90 - startAngle) * M_PI / 180;<span></span></pre></td></tr><tr><td scope="row"><pre>        end = (90 - startAngle - arcAngle) * M_PI / 180;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    CGContextAddArc (context, 0, 0, 1, start, end, false);<span>// 5</span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    CGContextRestoreGState(context);<span>// 6</span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>Here’s what the code does:</p><ol class="ol"><li class="li"><p>Saves the graphic state. You need to change the current transformation matrix (CTM), so you’ll want to save the graphics state and then restore it later.</p></li><li class="li"><p>Translates the CTM by the x origin of the arc plus half the width and the y origin of the arc plus half the height.</p></li><li class="li"><p>Scales the CTM by half the width and half the height. </p></li><li class="li"><p>Computes the starting and ending angle as measured in radians from the positive x-axis, taking into consideration whether the angle passed to <code>pathForArc</code> is positive or negative.</p></li><li class="li"><p>Adds the arc path to the current context. This call does not paint the arc. The function <code><a href="../../../../GraphicsImaging/Reference/CGContext/Reference/reference.html#//apple_ref/c/func/CGContextAddArc" target="_top">CGContextAddArc</a></code> takes a graphics context, the x- and y- coordinates (in user space) that define the center of the arc. The radius of the arc (in user space coordinates), the angle (in radians) to the starting point of the arc, the angle (in radians) to the ending point of the arc, and a Boolean value that indicates the direction to draw the path.</p></li><li class="li"><p>Restores the graphics state.</p></li></ol><p>The <code>frameArc</code> routine shown in <span class="content_text">Listing 2-5</span>, strokes an arc so that its origin is centered in the rectangle that you pass to the function. It calls the <code>pathForArc</code> routine to create the arc prior to filling the arc and <code>CGContextStrokePath</code> to perform the actual stroking.</p><a name="//apple_ref/doc/uid/TP40001098-CH220-CJBIIBJI" title="Listing 2-5A routine that frames (strokes) an arc"></a><p class="codesample"><strong>Listing 2-5&nbsp;&nbsp;</strong>A routine that frames (strokes) an arc</p><div class="codesample"><table><tr><td scope="row"><pre>void frameArc(CGContextRef context, CGRect r,<span></span></pre></td></tr><tr><td scope="row"><pre>    int startAngle, int arcAngle)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    CGContextBeginPath (context);<span></span></pre></td></tr><tr><td scope="row"><pre>     pathForArc (context,r,startAngle,arcAngle);<span></span></pre></td></tr><tr><td scope="row"><pre>    CGContextStrokePath(context);<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>The <code><!--a-->paintArc<!--/a--></code> routine shown in <span class="content_text">Listing 2-6</span> fills an arc so that its origin is centered in the rectangle that you pass to the function. It calls the <code>pathForArc</code> routine to create the arc prior to filling the arc and calls <code>CGContextFillPath</code> to perform the fill operation.</p><a name="//apple_ref/doc/uid/TP40001098-CH220-CJBFJGFE" title="Listing 2-6A routine that paints (fills) an arc"></a><p class="codesample"><strong>Listing 2-6&nbsp;&nbsp;</strong>A routine that paints (fills) an arc</p><div class="codesample"><table><tr><td scope="row"><pre>void paintArc (CGContextRef context, CGRect r,<span></span></pre></td></tr><tr><td scope="row"><pre>                        int startAngle, int arcAngle)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    CGContextBeginPath (context);<span></span></pre></td></tr><tr><td scope="row"><pre>    CGContextMoveToPoint (context, r.origin.x + r.size.width/2,<span></span></pre></td></tr><tr><td scope="row"><pre>                            r.origin.y + r.size.height/2);<span></span></pre></td></tr><tr><td scope="row"><pre>     pathForArc (context,r,startAngle,arcAngle);<span></span></pre></td></tr><tr><td scope="row"><pre>    CGContextClosePath (context);<span></span></pre></td></tr><tr><td scope="row"><pre>    CGContextFillPath (context);<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40001098-CH220-DontLinkElementID_16" title="Ovals: Replacing FrameOval and Paint Oval"></a><h3>Ovals: Replacing FrameOval and Paint Oval</h3><p><span class="content_text">Figure 2-5</span> shows examples of ovals that are stroked, filled, and both stroked and filled. Prior to Mac OS X v10.4, to emulate the QuickDraw functions <code>FrameOval</code> and <code>PaintOval</code>, you first need to write a function that creates an oval (or elliptical) shaped path. Starting in Mac OS X v10.4, you can frame ovals using the function <code><!--a target="_top" -->CGContextStrokeEllipseInRect<!--/a--></code>, which strokes (frames) an ellipse that fits in the specified rectangle. You paint (fill) ovals using the function <code><a href="../../../../GraphicsImaging/Reference/CGContext/Reference/reference.html#//apple_ref/c/func/CGContextFillEllipseInRect" target="_top">CGContextFillEllipseInRect</a></code>, which fills (paints) an ellipse that fits in the specified rectangle.</p><br/><div><a name="//apple_ref/doc/uid/TP40001098-CH220-CJBGIJFG" title="Figure 2-5Ovals drawn using Quartz"></a><p><strong>Figure 2-5&nbsp;&nbsp;</strong>Ovals drawn using Quartz</p><img src = "../art/ovals.gif" alt = "Ovals drawn using Quartz" width="259" height="226"></div><br/><p>The emulation functions are provided in case you need code that runs on versions of Mac OS X prior to v10.4. <span class="content_text">Listing 2-7</span> constructs an oval path. <span class="content_text"><a href="tq_other.html#//apple_ref/doc/uid/TP40001098-CH220-CJBEAHBG">Listing 2-8</a></span> paints an oval, and <span class="content_text"><a href="tq_other.html#//apple_ref/doc/uid/TP40001098-CH220-CJBHHIFG">Listing 2-9</a></span> frames one. A detailed explanation for each number line of code in <span class="content_text">Listing 2-7</span> follows the listing.</p><a name="//apple_ref/doc/uid/TP40001098-CH220-CJBDJGCD" title="Listing 2-7A routine that constructs an oval path"></a><p class="codesample"><strong>Listing 2-7&nbsp;&nbsp;</strong>A routine that constructs an oval path</p><div class="codesample"><table><tr><td scope="row"><pre>void addOvalToPath(CGContextRef context, CGRect r)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    CGContextSaveGState(context);<span>// 1</span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>     CGContextTranslateCTM(context, r.origin.x + r.size.width/2,<span>// 2</span></pre></td></tr><tr><td scope="row"><pre>                                 r.origin.y + r.size.height/2);<span></span></pre></td></tr><tr><td scope="row"><pre>     CGContextScaleCTM(context, r.size.width/2, r.size.height/2);<span>// 3</span></pre></td></tr><tr><td scope="row"><pre>    CGContextBeginPath(context);<span>// 4</span></pre></td></tr><tr><td scope="row"><pre>    CGContextAddArc(context, 0, 0, 1, 0, 2*pi, true);<span>// 5</span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    CGContextRestoreGState(context);<span>// 6</span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>Here’s what the code does:</p><ol class="ol"><li class="li"><p>Saves the graphics state so that you can restore it later.</p></li><li class="li"><p>Transforms the origin of the CTM to the center of the bounding rectangle. The center of the bounding rectangle will be the center of the oval. </p></li><li class="li"><p>Scales the CTM so that a radius of 1 is equal to the bounds of the rectangle,</p></li><li class="li"><p>Creates a new, empty path in the graphics context.</p></li><li class="li"><p>Adds a circle to the path in the graphics context. But because the CTM is transformed, the circle is subjected to that transformation. After transformation, the circle becomes an oval that lies just inside the bounding rectangle.</p></li><li class="li"><p>Restores the graphics state to what it was prior to transforming the CTM.</p></li></ol><p>The <code>paintOval</code> routine shown in <span class="content_text">Listing 2-8</span> calls the <code>addOvalToPath</code> routine, passing a rectangle to center the oval in, and then fills the path using the Quartz function <code><a href="../../../../GraphicsImaging/Reference/CGContext/Reference/reference.html#//apple_ref/c/func/CGContextFillPath" target="_top">CGContextFillPath</a></code>.</p><a name="//apple_ref/doc/uid/TP40001098-CH220-CJBEAHBG" title="Listing 2-8A routine that paints (fills) an oval"></a><p class="codesample"><strong>Listing 2-8&nbsp;&nbsp;</strong>A routine that paints (fills) an oval</p><div class="codesample"><table><tr><td scope="row"><pre>void paintOval(CGContextRef context, CGRect r)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    addOvalToPath (context,r);<span></span></pre></td></tr><tr><td scope="row"><pre>    CGContextFillPath (context);<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>The <code>frameOval</code> routine shown in <span class="content_text">Listing 2-9</span> calls the <code>addOvalToPath</code> routine, passing a rectangle to center the oval in, and then strokes the path using the Quartz function <code><a href="../../../../GraphicsImaging/Reference/CGContext/Reference/reference.html#//apple_ref/c/func/CGContextStrokePath" target="_top">CGContextStrokePath</a></code>. In QuickDraw, <code>FrameOval</code> completely insets the oval in the rectangle. In the <code>frameOval</code> routine, the path is inset but the stroke is painted with one-half its thickness on each side of the path.</p><a name="//apple_ref/doc/uid/TP40001098-CH220-CJBHHIFG" title="Listing 2-9A routine that frames (strokes) an oval"></a><p class="codesample"><strong>Listing 2-9&nbsp;&nbsp;</strong>A routine that frames (strokes) an oval</p><div class="codesample"><table><tr><td scope="row"><pre>void frameOval(CGContextRef context, CGRect r)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    addOvalToPath(context,r);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    CGContextStrokePath(context);<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40001098-CH220-DontLinkElementID_17" title="Rectangles: Replacing FrameRect and PaintRect"></a><h3>Rectangles: Replacing FrameRect and PaintRect</h3><p><span class="content_text">Figure 2-6</span> shows examples of rectangles that are stroked, filled, and both stroked and filled. Quartz provides convenience functions for stroking and painting rectangles. You can simply use the Quartz functions <code><a href="../../../../GraphicsImaging/Reference/CGContext/Reference/reference.html#//apple_ref/c/func/CGContextStrokeRect" target="_top">CGContextStrokeRect</a></code> and <code><a href="../../../../GraphicsImaging/Reference/CGContext/Reference/reference.html#//apple_ref/c/func/CGContextFillRect" target="_top">CGContextFillRect</a></code>. Keep in mind that in QuickDraw, framing routines completely inset a shape in the specified rectangle. In Quartz, stroking paints a line such that one-half its thickness is on each side of the path.</p><br/><div><a name="//apple_ref/doc/uid/TP40001098-CH220-CJBEAJCJ" title="Figure 2-6Rectangles drawn using Quartz"></a><p><strong>Figure 2-6&nbsp;&nbsp;</strong>Rectangles drawn using Quartz</p><img src = "../art/rectangles.gif" alt = "Rectangles drawn using Quartz" width="233" height="234"></div><br/><a name="//apple_ref/doc/uid/TP40001098-CH220-DontLinkElementID_18" title="Rounded Rectangles"></a><h3>Rounded Rectangles</h3><p><span class="content_text">Figure 2-7</span> shows a series of rounded rectangles that are stroked with black and filled using a variety of translucent colors. To draw a rounded rectangle, you first need to write a function that creates a rounded rectangle path, and then create functions that stroke and fill the rounded rectangle. </p><br/><div><a name="//apple_ref/doc/uid/TP40001098-CH220-CJBECCJD" title="Figure 2-7Rounded rectangles drawn using Quartz"></a><p><strong>Figure 2-7&nbsp;&nbsp;</strong>Rounded rectangles drawn using Quartz</p><img src = "../art/ovalteen.jpg" alt = "Rounded rectangles drawn using Quartz" ></div><br/><p>The <code>addRoundedRectToPath</code> routine shown in <span class="content_text"><a href="tq_other.html#//apple_ref/doc/uid/TP40001098-CH220-CJBGFGAI">Listing 2-10</a></span> constructs a rounded rectangle path by using a series of calls to the function <code><a href="../../../../GraphicsImaging/Reference/CGContext/Reference/reference.html#//apple_ref/c/func/CGContextAddArcToPoint" target="_top">CGContextAddArcToPoint</a></code>. Although you can simply use the code in the listing to construct rounded rectangles, it’s worth taking a moment to understand the <code><a href="../../../../GraphicsImaging/Reference/CGContext/Reference/reference.html#//apple_ref/c/func/CGContextAddArcToPoint" target="_top">CGContextAddArcToPoint</a></code> function. This function adds the arc of a circle to the current subpath. When you call this function directly, you supply two pairs of coordinates— (<em>x1</em>,<em>y1</em>) and (<em>x2</em>,<em>y2</em>)—that define two tangent lines, and a radius that defines the curvature of the arc.</p><p>The arc constructed by the function <code><a href="../../../../GraphicsImaging/Reference/CGContext/Reference/reference.html#//apple_ref/c/func/CGContextAddArcToPoint" target="_top">CGContextAddArcToPoint</a></code> is tangent to two lines: the line from the current point to (<em>x1</em>,<em>y1</em>), and the line from (<em>x1</em>,<em>y1</em>) to (<em>x2</em>,<em>y2</em>). The start and end points of the arc are the tangent points of the lines. If the current point and the first tangent point of the arc (the starting point) are not equal, Quartz appends a straight line segment from the current point to the first tangent point. After adding the arc, the current point is reset to the end point of arc (the second tangent point). </p><p>Now take a look at the <code>addRoundedRectToPath</code> routine in <span class="content_text"><a href="tq_other.html#//apple_ref/doc/uid/TP40001098-CH220-CJBGFGAI">Listing 2-10</a></span>. The routine takes a graphics context, a rectangle into which the rounded rectangle must fit, and the width and height of the oval that defines the rounded corners. A detailed explanation for each numbered line of code appears following <span class="content_text">Listing 2-10</span>.</p><a name="//apple_ref/doc/uid/TP40001098-CH220-CJBGFGAI" title="Listing 2-10A routine that constructs a rounded rectangle path"></a><p class="codesample"><strong>Listing 2-10&nbsp;&nbsp;</strong>A routine that constructs a rounded rectangle path</p><div class="codesample"><table><tr><td scope="row"><pre>static void addRoundedRectToPath(CGContextRef context, CGRect rect,<span></span></pre></td></tr><tr><td scope="row"><pre>                        float ovalWidth,float ovalHeight)<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    float fw, fh;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if (ovalWidth == 0 || ovalHeight == 0) {<span>// 1</span></pre></td></tr><tr><td scope="row"><pre>        CGContextAddRect(context, rect);<span></span></pre></td></tr><tr><td scope="row"><pre>        return;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    CGContextSaveGState(context);<span>// 2</span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    CGContextTranslateCTM (context, CGRectGetMinX(rect),<span>// 3</span></pre></td></tr><tr><td scope="row"><pre>                         CGRectGetMinY(rect));<span></span></pre></td></tr><tr><td scope="row"><pre>    CGContextScaleCTM (context, ovalWidth, ovalHeight);<span>// 4</span></pre></td></tr><tr><td scope="row"><pre>    fw = CGRectGetWidth (rect) / ovalWidth;<span>// 5</span></pre></td></tr><tr><td scope="row"><pre>    fh = CGRectGetHeight (rect) / ovalHeight;<span>// 6</span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    CGContextMoveToPoint(context, fw, fh/2); <span>// 7</span></pre></td></tr><tr><td scope="row"><pre>    CGContextAddArcToPoint(context, fw, fh, fw/2, fh, 1);<span>// 8</span></pre></td></tr><tr><td scope="row"><pre>    CGContextAddArcToPoint(context, 0, fh, 0, fh/2, 1);<span>// 9</span></pre></td></tr><tr><td scope="row"><pre>    CGContextAddArcToPoint(context, 0, 0, fw/2, 0, 1);<span>// 10</span></pre></td></tr><tr><td scope="row"><pre>    CGContextAddArcToPoint(context, fw, 0, fw, fh/2, 1); <span>// 11</span></pre></td></tr><tr><td scope="row"><pre>    CGContextClosePath(context);<span>// 12</span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    CGContextRestoreGState(context);<span>// 13</span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>Here’s what the code does:</p><ol class="ol"><li class="li"><p>If the width or height of the oval is 0, adds a rectangle to the graphics context and returns. In addition, the corner reduces to a right angle, which is simply an ordinary rectangle.</p></li><li class="li"><p>Saves the graphics state so that you can restore it later.</p></li><li class="li"><p>Translates the origin of the graphics context to the lower-left corner of the rectangle.</p></li><li class="li"><p>Normalizes the scale of the graphics context so that the width and height of the arcs are 1.0.</p></li><li class="li"><p>Calculates the width of the rectangle in the new coordinate system.</p></li><li class="li"><p>Calculates the height of the rectangle in the new coordinate system.</p></li><li class="li"><p>Moves to the mid point of the right edge of the rectangle.</p></li><li class="li"><p>Adds an arc to the starting point. This is the upper-right corner of the rounded rectangle.</p></li><li class="li"><p>Adds an arc that defines the upper-left corner of the rounded rectangle.</p></li><li class="li"><p>Adds an arc that defines the lower-left corner of the rounded rectangle.</p></li><li class="li"><p>Adds an arc that defines the lower-right corner of the rounded rectangle.</p></li><li class="li"><p>Closes the path, which connects the current point to the starting point, and terminates the subpath.</p></li><li class="li"><p>Restores the graphics state to what it was previously.</p></li></ol><p>The <code>strokeRoundedRect</code> routine, shown in <span class="content_text">Listing 2-11</span>, calls the <code>addRoundedRectToPath</code> routine, passing a rectangle, and the oval width and height to use for rounding. The routine then strokes the path by using the Quartz function <code><a href="../../../../GraphicsImaging/Reference/CGContext/Reference/reference.html#//apple_ref/c/func/CGContextStrokePath" target="_top">CGContextStrokePath</a></code>.</p><a name="//apple_ref/doc/uid/TP40001098-CH220-CJBCHDDA" title="Listing 2-11A routine that frames (strokes) a rounded rectangle"></a><p class="codesample"><strong>Listing 2-11&nbsp;&nbsp;</strong>A routine that frames (strokes) a rounded rectangle</p><div class="codesample"><table><tr><td scope="row"><pre>void strokeRoundedRect(CGContextRef context, CGRect rect, float ovalWidth,<span></span></pre></td></tr><tr><td scope="row"><pre>                       float ovalHeight)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    CGContextBeginPath(context);<span></span></pre></td></tr><tr><td scope="row"><pre>    addRoundedRectToPath(context, rect, ovalWidth, ovalHeight);<span></span></pre></td></tr><tr><td scope="row"><pre>    CGContextStrokePath(context);<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>The <code>fillRoundedRect</code> routine shown in <span class="content_text">Listing 2-12</span> calls the <code>addRoundedRectToPath</code> routine, passing a rectangle, and the oval width and height to use for rounding. The routine then fills the path using the Quartz function <code><a href="../../../../GraphicsImaging/Reference/CGContext/Reference/reference.html#//apple_ref/c/func/CGContextFillPath" target="_top">CGContextFillPath</a></code>.</p><a name="//apple_ref/doc/uid/TP40001098-CH220-CJBJECAC" title="Listing 2-12A routine that paints (fills) a rounded rectangle"></a><p class="codesample"><strong>Listing 2-12&nbsp;&nbsp;</strong>A routine that paints (fills) a rounded rectangle</p><div class="codesample"><table><tr><td scope="row"><pre>void fillRoundedRect (CGContextRef context, CGRect rect,<span></span></pre></td></tr><tr><td scope="row"><pre>                        float ovalWidth, float ovalHeight)<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    CGContextBeginPath(context);<span></span></pre></td></tr><tr><td scope="row"><pre>    addRoundedRectToPath(context, rect, ovalWidth, ovalHeight);<span></span></pre></td></tr><tr><td scope="row"><pre>    CGContextFillPath(context);<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40001098-CH220-CJBCGDFD" title="Drawing the Union and Symmetric Difference of Two Shapes"></a><h3>Drawing the Union and Symmetric Difference of Two Shapes</h3><p>QuickDraw provides functions to find the union, intersection, or difference of two regions. Quartz has no comparable set operations for paths. However, it’s possible to mimic these operations when filling areas in a path with overlapping shapes. This example demonstrates how to draw the union and symmetric difference (XOR) of two shapes. Drawing the intersection and difference requires clipping, which is described in <span class="content_text"><a href="tq_other.html#//apple_ref/doc/uid/TP40001098-CH220-CJBGDDBG">“A Basic Clipping Example”</a></span> in the section <span class="content_text"><a href="tq_other.html#//apple_ref/doc/uid/TP40001098-CH220-CJBCFBID">“Clipping.”</a></span> </p><p><span class="content_text">Figure 2-8</span> shows the path used in this example. The arrows indicate the counterclockwise direction of each shape. </p><br/><div><a name="//apple_ref/doc/uid/TP40001098-CH220-BCIICIIE" title="Figure 2-8A path with two overlapping shapes"></a><p><strong>Figure 2-8&nbsp;&nbsp;</strong>A path with two overlapping shapes</p><img src = "../art/overlap_rects.gif" alt = "A path with two overlapping shapes" width="160" height="123"></div><br/><p><span class="content_text">Figure 2-9</span> shows a drawing of the union and symmetric difference (XOR) of the two shapes. Their union is drawn using the nonzero winding number fill rule, and their symmetric difference is drawn using the even-odd fill rule. (These rules are described in detail in <em><a href="../../../../GraphicsImaging/Conceptual/drawingwithquartz2d/index.html#//apple_ref/doc/uid/TP30001066" target="_top">Quartz 2D Programming Guide</a></em>.)</p><br/><div><a name="//apple_ref/doc/uid/TP40001098-CH220-BCIHFEAE" title="Figure 2-9Drawing the union (A) and symmetric difference (B) of two shapes"></a><p><strong>Figure 2-9&nbsp;&nbsp;</strong>Drawing the union (A) and symmetric difference (B) of two shapes</p><img src = "../art/union_xor.gif" alt = "Drawing the union (A) and symmetric difference (B) of two shapes" width="383" height="129"></div><br/><p><span class="content_text">Listing 2-13</span> defines the two shapes and constructs path objects that contain one or both shapes. A detailed explanation for each numbered line of code follows the listing.</p><a name="//apple_ref/doc/uid/TP40001098-CH220-CJBFCHED" title="Listing 2-13Code that uses fill rules to draw the union and symmetric difference of two shapes "></a><p class="codesample"><strong>Listing 2-13&nbsp;&nbsp;</strong>Code that uses fill rules to draw the union and symmetric difference of two shapes </p><div class="codesample"><table><tr><td scope="row"><pre>const float width = 80.0;<span></span></pre></td></tr><tr><td scope="row"><pre>const float height = 60.0;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>CGRect rect1 = {{ 0, height/2 }, { width, height }};<span></span></pre></td></tr><tr><td scope="row"><pre>CGRect rect2 = {{ width/2, 0 }, { width, height }};<span></span></pre></td></tr><tr><td scope="row"><pre>CGRect rects[2] = { rect1, rect2 };<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>// Shapes 1 and 2 are declared here but used in the clipping example<span></span></pre></td></tr><tr><td scope="row"><pre>CGMutablePathRef shape1 = CGPathCreateMutable();<span></span></pre></td></tr><tr><td scope="row"><pre>CGMutablePathRef shape2 = CGPathCreateMutable();<span></span></pre></td></tr><tr><td scope="row"><pre>CGMutablePathRef shapes = CGPathCreateMutable();<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>CGPathAddRect (shape1, NULL, rect1);<span></span></pre></td></tr><tr><td scope="row"><pre>CGPathAddRect (shape2, NULL, rect2);<span></span></pre></td></tr><tr><td scope="row"><pre>CGPathAddRects (shapes, NULL, rects, 2);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>CGContextSaveGState (ctx);<span></span></pre></td></tr><tr><td scope="row"><pre>CGContextBeginPath (ctx);<span>// 1</span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>// union<span></span></pre></td></tr><tr><td scope="row"><pre>CGContextAddPath (ctx, shapes);<span>// 2</span></pre></td></tr><tr><td scope="row"><pre>CGContextFillPath (ctx);<span>// 3</span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>CGContextTranslateCTM (ctx, width * 3, 0);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>// symmetric difference (XOR)<span></span></pre></td></tr><tr><td scope="row"><pre>CGContextAddPath (ctx, shapes);<span>// 4</span></pre></td></tr><tr><td scope="row"><pre>CGContextEOFillPath (ctx);<span>// 5</span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>CGContextRestoreGState (ctx);<span></span></pre></td></tr><tr><td scope="row"><pre>// Your code should include calls to CGPathRelease to release each path<span></span></pre></td></tr></table></div><p>Here’s what the code does:</p><ol class="ol"><li class="li"><p>Replaces the current path (if any) in the context with a new, empty path.</p></li><li class="li"><p>Adds the two shapes to the current path.</p></li><li class="li"><p>Fills the current path using the nonzero winding number rule. Both shapes have the same direction, so the entire area is filled. </p></li><li class="li"><p>Adds the two shapes to the current path again. This is necessary because the fill operation in the previous step consumes the path.</p></li><li class="li"><p>Fills the path using the even-odd rule. This time, the area common to both shapes is not filled.</p></li></ol><a name="//apple_ref/doc/uid/TP40001098-CH220-CJBEFGBD" title="Converting an Arbitrary QuickDraw Region to a Quartz Path"></a><h2>Converting an Arbitrary QuickDraw Region to a Quartz Path</h2><p>Regions in QuickDraw and paths in Quartz are very different abstractions. Regions are pixel based and don’t retain any information about the contours or boundaries of the shapes they represent. Paths are vector-based representations of the contours of shapes, with no concept of pixels. Converting a region into a path may be inefficient, and the contours of the converted path may not look smooth or scale well. Quartz does not provide a function to convert a region into a path. If at all possible, you will want to replace our use of regions with Quartz abstractions rather than perform this type of conversion. However, if you must, it is possible to write a program to perform the conversion yourself. </p><p>This section demonstrates how to write code that converts an arbitrary QuickDraw region into a Quartz path by taking a divide-and-conquer approach. The first step is to describe a region in terms of vectors. Rectangles are ideal for this purpose. It turns out that any region can be decomposed into a sequence of rectangles in top-down or left-right order. QuickDraw provides the function <code><a href="../../../Reference/QuickDraw_Ref/Reference/reference.html#//apple_ref/c/func/QDRegionToRects" target="_top">QDRegionToRects</a></code> for exactly this purpose. </p><p>On the Quartz side, several functions exist for adding rectangles to graphics paths. The only remaining problem is to convert the rectangles into the floating-point <code><a href="../../../../GraphicsImaging/Reference/CGGeometry/Reference/reference.html#//apple_ref/c/tdef/CGRect" target="_top">CGRect</a></code> format used by Quartz, which is easy to do.</p><p>The sample code in <span class="content_text">Listing 2-14</span> shows how to write two custom functions that work together to perform the conversion. A detailed explanation for each numbered line of code follows the listing.</p><ul class="ul"><li class="li"><p><code>MyConvertRegionToPath</code> creates a new path, performs the conversion, and returns the path to the caller.</p></li><li class="li"><p><code>MyRegionToRectsCallback</code> converts a QuickDraw rectangle into a Quartz rectangle and appends it to the new path.</p></li></ul><p>When you use the converted path to draw in a graphics context with a flipped coordinate space, the path will have the same orientation as the region.</p><a name="//apple_ref/doc/uid/TP40001098-CH220-BCIDJJDH" title="Listing 2-14Routines that convert a QuickDraw region into a Quartz path"></a><p class="codesample"><strong>Listing 2-14&nbsp;&nbsp;</strong>Routines that convert a QuickDraw region into a Quartz path</p><div class="codesample"><table><tr><td scope="row"><pre>OSStatus MyConvertRegionToPath (RgnHandle region, CGPathRef* outPath)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    RegionToRectsUPP proc = NewRegionToRectsUPP (MyRegionToRectsCallback);<span></span></pre></td></tr><tr><td scope="row"><pre>    CGPathRef path = CGPathCreateMutable();<span></span></pre></td></tr><tr><td scope="row"><pre>    OSStatus err = noErr;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    err = QDRegionToRects (<span></span></pre></td></tr><tr><td scope="row"><pre>        region, kQDParseRegionFromTopLeft, proc, (void*)path);<span>// 1</span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if (err == noErr) {<span></span></pre></td></tr><tr><td scope="row"><pre>        *outPath = path;<span>// 2</span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    else {<span></span></pre></td></tr><tr><td scope="row"><pre>        CGPathRelease (path);<span></span></pre></td></tr><tr><td scope="row"><pre>        *outPath = NULL;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    DisposeRegionToRectsUPP (proc);<span></span></pre></td></tr><tr><td scope="row"><pre>    return err;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>OSStatus MyRegionToRectsCallback (<span></span></pre></td></tr><tr><td scope="row"><pre>    UInt16 message, RgnHandle region, const Rect *rect, void *data)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    if (message == kQDRegionToRectsMsgParse)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        Rect qd = *rect;<span></span></pre></td></tr><tr><td scope="row"><pre>        CGRect cg = CGRectMake (<span></span></pre></td></tr><tr><td scope="row"><pre>            qd.left, qd.top, qd.right - qd.left, qd.bottom - qd.top);<span>// 3</span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        CGPathAddRect (<span></span></pre></td></tr><tr><td scope="row"><pre>            (CGMutablePathRef)data, NULL, cg);<span>// 4</span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    return noErr;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>Here’s what the code does:</p><ol class="ol"><li class="li"><p>Converts the region into a path.</p></li><li class="li"><p>Passes the converted path back to the caller.</p></li><li class="li"><p>Converts the QuickDraw rectangle into a Quartz rectangle, using the upper-left point as the origin.</p></li><li class="li"><p>Adds the Quartz rectangle to the path being constructed.</p></li></ol><a name="//apple_ref/doc/uid/TP40001098-CH220-CJBHAEBG" title="Anti-aliasing"></a><h2>Anti-aliasing</h2><p>Anti-aliasing is used in 2D graphics to smooth and soften the jagged (or aliased) edges you sometimes see when graphical objects such as text, line art, and images are drawn in a bitmap context. Anti-aliased objects are more accurately represented, more appealing to the eye, and more realistic.</p><p>Quartz provides a clear advantage over QuickDraw when it comes to anti-aliasing because Quartz uses anti-aliasing to draw shapes as well as text. Quartz also provides several levels of additional text anti-aliasing or text smoothing for LCD displays. QuickDraw supports anti-aliasing for text only, and its algorithm is limited to 16 shades of gray, with glyphs always positioned on pixel boundaries.</p><p>Quartz anti-aliasing maintains consistent high-quality rendering at any resolution by finding the best representation for a particular device. In graphics contexts that support anti-aliasing, by default everything drawn is anti-aliased. Images are drawn with anti-aliasing along their borders, causing them to appear to blend smoothly into the adjacent background.</p><p>Compared with QuickDraw, Quartz text anti-aliasing is more sophisticated. Quartz anti-aliasing uses a coverage model to compute the degree to which nearby pixels in device space are covered or contained by the drawing primitive. The coverage data determines the opacity of partially covered pixels. Anti-aliasing uses 8-bit opacity, which provides 256 different opacity levels. The opacity depth could increase in the future, as device capabilities and algorithms improve.</p><p>You can turn anti-aliasing off for a particular bitmap graphics context by calling the Quartz function <code><a href="../../../../GraphicsImaging/Reference/CGContext/Reference/reference.html#//apple_ref/c/func/CGContextSetShouldAntialias" target="_top">CGContextSetShouldAntialias</a></code>. The anti-aliasing setting is part of the graphics state.</p><p>Beginning in Mac OS X v10.4, you can also control whether or not to allow anti-aliasing for a particular bit-oriented graphics context by using the function <code><a href="../../../../GraphicsImaging/Reference/CGContext/Reference/reference.html#//apple_ref/c/func/CGContextSetAllowsAntialiasing" target="_top">CGContextSetAllowsAntialiasing</a></code>. Pass <code>true</code> to this function to allow anti-aliasing, and <code>false</code> not to allow it. This setting is not part of the graphics state. Quartz performs anti-aliasing for a bit-oriented graphics context if you allow anti-aliasing (by passing <code>true</code> to <code><a href="../../../../GraphicsImaging/Reference/CGContext/Reference/reference.html#//apple_ref/c/func/CGContextSetAllowsAntialiasing" target="_top">CGContextSetAllowsAntialiasing</a></code>) and you set the anti-aliasing setting graphics state parameter to <code>true</code> (by calling <code><a href="../../../../GraphicsImaging/Reference/CGContext/Reference/reference.html#//apple_ref/c/func/CGContextSetShouldAntialias" target="_top">CGContextSetShouldAntialias</a></code>). </p><a name="//apple_ref/doc/uid/TP40001098-CH220-CJBCFBID" title="Clipping"></a><h2>Clipping</h2><p>Quartz uses clipping to limit drawing in a graphics context. Quartz functions that clip (<code><a href="../../../../GraphicsImaging/Reference/CGContext/Reference/reference.html#//apple_ref/c/func/CGContextClip" target="_top">CGContextClip</a></code>, <code><a href="../../../../GraphicsImaging/Reference/CGContext/Reference/reference.html#//apple_ref/c/func/CGContextEOClip" target="_top">CGContextEOClip</a></code>) intersect the clip with the current clip, “trimming” the clipping area in a cookie-cutter-like manner. The primary differences between clipping in Quartz and QuickDraw are as follows:</p><ul class="ul"><li class="li"><p>When your application creates a graphics context or obtains a context that’s created elsewhere, the clipping area in the context is already configured for a specific use. The default clipping area in a new graphics context is typically the entire page or window content area.</p></li><li class="li"><p>You cannot directly access the clipping area. Instead, Quartz provides clipping functions that modify the clipping area for you. You can save and later restore the current clipping area, along with the entire graphics state, by using the functions <code><a href="../../../../GraphicsImaging/Reference/CGContext/Reference/reference.html#//apple_ref/c/func/CGContextSaveGState" target="_top">CGContextSaveGState</a></code> and <code><!--a target="_top" -->CGContextRestoreGState<!--/a--></code>.</p></li><li class="li"><p>When you call one of the Quartz clipping functions, the new clipping area is the intersection of the current clipping area with (1) the area inside a filled path or (2) a grayscale image or image mask. </p><div class="notebox"><a name="//apple_ref/doc/uid/TP40001098-CH220-DontLinkElementID_46" title="Note"></a><p><strong>Note:</strong>&nbsp; Modifying the clipping area is always an intersection operation. This is fundamentally different from corresponding QuickDraw operations, which typically replace the clipping region with a new one.</p></div></li><li class="li"><p>Because of how intersection works, clipping functions can’t extend the clipping area beyond its current bounds.</p></li></ul><a name="//apple_ref/doc/uid/TP40001098-CH220-DontLinkElementID_19" title="Quartz Clipping Functions"></a><h3>Quartz Clipping Functions</h3><p>Quartz has these functions available for clipping:</p><ul class="spaceabove"><li class="li"><p><code><a href="../../../../GraphicsImaging/Reference/CGContext/Reference/reference.html#//apple_ref/c/func/CGContextClip" target="_top">CGContextClip</a></code> intersects the current clipping area with the filled area of the current path, using the non zero winding rule.</p></li><li class="li"><p><code><a href="../../../../GraphicsImaging/Reference/CGContext/Reference/reference.html#//apple_ref/c/func/CGContextEOClip" target="_top">CGContextEOClip</a></code> intersects the current clipping area with the filled area of the current path, using the even-odd rule. Often, you’ll find that <code>CGContextEOClip</code> is more convenient to use than the function <code>CGContextClip</code>. For QuickDraw-style intersections, even-odd rules match better.</p></li><li class="li"><p><code><a href="../../../../GraphicsImaging/Reference/CGContext/Reference/reference.html#//apple_ref/c/func/CGContextClipToMask" target="_top">CGContextClipToMask</a></code> , available starting in Mac OS X v10.4, intersects the clipping area in a graphics context with a mask. The mask can be an image mask or a grayscale image. For more information, see <span class="content_text"><a href="../../../../GraphicsImaging/Conceptual/drawingwithquartz2d/dq_images/dq_images.html#//apple_ref/doc/uid/TP30001066-CH212-CJBHDDBE" target="_top">Masking an Image by Clipping the Context</a></span> in <em><a href="../../../../GraphicsImaging/Conceptual/drawingwithquartz2d/index.html#//apple_ref/doc/uid/TP30001066" target="_top">Quartz 2D Programming Guide</a></em>. </p></li></ul><p>The <em><a href="../../../../GraphicsImaging/Conceptual/drawingwithquartz2d/index.html#//apple_ref/doc/uid/TP30001066" target="_top">Quartz 2D Programming Guide</a></em> describes how clipping works in more detail and discusses the difference between the winding and even-odd rules for determining the inside of a shape.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40001098-CH220-DontLinkElementID_47" title="Tip"></a><p><strong>Tip:</strong>&nbsp; If drawing doesn’t show up as you expect, use the function <code><a href="../../../../GraphicsImaging/Reference/CGContext/Reference/reference.html#//apple_ref/c/func/CGContextGetClipBoundingBox" target="_top">CGContextGetClipBoundingBox</a></code> for debugging. By looking at the bounding box returned by this function, you can determine whether the coordinates are wrong or whether your drawing is not near what you clipped out.</p></div><a name="//apple_ref/doc/uid/TP40001098-CH220-CJBGDDBG" title="A Basic Clipping Example"></a><h3>A Basic Clipping Example</h3><p>This example is a continuation of <span class="content_text"><a href="tq_other.html#//apple_ref/doc/uid/TP40001098-CH220-CJBCGDFD">“Drawing the Union and Symmetric Difference of Two Shapes.”</a></span> Quartz does not provide functions that compute the difference or intersection of two paths, but this example demonstrates how to use clipping to achieve a similar effect. That is, to draw the intersection and difference of two shapes in a single path (see <span class="content_text"><a href="tq_other.html#//apple_ref/doc/uid/TP40001098-CH220-BCIICIIE">Figure 2-8</a></span>). </p><p>In <span class="content_text">Figure 2-10</span>, the intersection of two shapes is drawn by clipping with each shape separately and then filling the shapes. For simplicity, this example uses rectangular paths. Typically you would use this approach with more complex paths. Their difference (shape 1 - shape 2) is drawn by clipping with both shapes using the even-odd rule, and then drawing the first shape.</p><br/><div><a name="//apple_ref/doc/uid/TP40001098-CH220-CJBFBBEC" title="Figure 2-10Drawing the intersection (C) and difference (D) of two shapes"></a><p><strong>Figure 2-10&nbsp;&nbsp;</strong>Drawing the intersection (C) and difference (D) of two shapes</p><img src = "../art/sect_diff.gif" alt = "Drawing the intersection (C) and difference (D) of two shapes" width="385" height="130"></div><br/><p><span class="content_text">Listing 2-15</span> shows how to draw the filled areas in black.</p><a name="//apple_ref/doc/uid/TP40001098-CH220-CJBBECGH" title="Listing 2-15Code that uses clipping to draw the intersection and difference of two shapes"></a><p class="codesample"><strong>Listing 2-15&nbsp;&nbsp;</strong>Code that uses clipping to draw the intersection and difference of two shapes</p><div class="codesample"><table><tr><td scope="row"><pre>// intersection<span></span></pre></td></tr><tr><td scope="row"><pre>CGContextSaveGState (ctx);<span>// 1</span></pre></td></tr><tr><td scope="row"><pre>CGContextAddPath (ctx, shape1);<span>// 2</span></pre></td></tr><tr><td scope="row"><pre>CGContextClip (ctx);<span></span></pre></td></tr><tr><td scope="row"><pre>CGContextAddPath (ctx, shape2);<span></span></pre></td></tr><tr><td scope="row"><pre>CGContextClip (ctx);<span></span></pre></td></tr><tr><td scope="row"><pre>CGContextAddPath (ctx, shapes);<span>// 3</span></pre></td></tr><tr><td scope="row"><pre>CGContextFillPath (ctx);<span></span></pre></td></tr><tr><td scope="row"><pre>CGContextRestoreGState (ctx);<span>// 4</span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>CGContextTranslateCTM (ctx, width * 3, 0);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>// difference<span></span></pre></td></tr><tr><td scope="row"><pre>CGContextSaveGState (ctx);<span></span></pre></td></tr><tr><td scope="row"><pre>CGContextAddPath (ctx, shapes);<span>// 5</span></pre></td></tr><tr><td scope="row"><pre>CGContextEOClip (ctx);<span></span></pre></td></tr><tr><td scope="row"><pre>CGContextAddPath (ctx, shape1);<span>// 6</span></pre></td></tr><tr><td scope="row"><pre>CGContextFillPath (ctx);<span></span></pre></td></tr><tr><td scope="row"><pre>CGContextRestoreGState (ctx);<span></span></pre></td></tr></table></div><p>Here’s what the code does:</p><ol class="ol"><li class="li"><p>Saves the graphics state. This is done because step 2 modifies the clipping area, a part of the graphics state. </p></li><li class="li"><p>Intersects the clipping area with each shape individually. This has the effect of removing the area not common to both shapes from the clipping area. As with drawing operations, clipping consumes the current path.</p></li><li class="li"><p>Fills the shapes using the clip defined in the step 2.</p></li><li class="li"><p>Restores the clipping area to its previous state, saved in step 1.</p></li><li class="li"><p>Intersects the clipping area with both shapes using the even-odd rule. This has the effect of removing the area common to both shapes from the clipping area.</p></li><li class="li"><p>Constructs and fills a path consisting of the first shape, using the clip defined in step 5.</p></li></ol><a name="//apple_ref/doc/uid/TP40001098-CH220-CJBICDJJ" title="Alternatives to QuickDraw Drawing Functions"></a><h2>Alternatives to QuickDraw Drawing Functions</h2><p>QuickDraw region functions do not have exact replacements in Quartz, but there are many alternatives in Quartz that work just as well. A good approach is to find an alternative and study how it’s used in code examples such as the CarbonSketch sample application that’s available from the ADC Reference Library. <span class="content_text"><a href="tq_other.html#//apple_ref/doc/uid/TP40001098-CH220-CJBIIEFF">Table 2-1</a></span> lists alternatives to some of the QuickDraw region functions. </p><p>See also <span class="content_text"><a href="tq_other.html#//apple_ref/doc/uid/TP40001098-CH220-CJBFDFGA">“Constructing and Drawing Shapes,”</a></span> <span class="content_text"><a href="tq_other.html#//apple_ref/doc/uid/TP40001098-CH220-CJBEFGBD">“Converting an Arbitrary QuickDraw Region to a Quartz Path,”</a></span> and <span class="content_text"><a href="tq_other.html#//apple_ref/doc/uid/TP40001098-CH220-CJBCFBID">“Clipping.”</a></span></p><a name="//apple_ref/doc/uid/TP40001098-CH220-CJBIIEFF" title="Table 2-1Alternatives to region functions"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table 2-1&nbsp;&nbsp;</strong>Alternatives to region functions</caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>QuickDraw function</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Alternatives</p></th></tr><tr><td  scope="row"><p><code><a href="../../../Reference/QuickDraw_Ref/DeprecationAppendix/AppendixADeprecatedAPI.html#//apple_ref/c/func/ClipRect" target="_top">ClipRect</a></code> replaces the clipping region with a region that’s a rectangle.</p></td><td ><p><code><a href="../../../../GraphicsImaging/Reference/CGContext/Reference/reference.html#//apple_ref/c/func/CGContextClipToRect" target="_top">CGContextClipToRect</a></code> intersects the current clipping area with a rectangle.</p></td></tr><tr><td  scope="row"><p><code><a href="../../../Reference/QuickDraw_Ref/Reference/reference.html#//apple_ref/c/func/CopyRgn" target="_top">CopyRgn</a></code> makes a copy of a region.</p></td><td ><p><code><a href="../../../../GraphicsImaging/Reference/CGPath/Reference/reference.html#//apple_ref/c/func/CGPathCreateCopy" target="_top">CGPathCreateCopy</a></code> and <code><a href="../../../../GraphicsImaging/Reference/CGPath/Reference/reference.html#//apple_ref/c/func/CGPathCreateMutableCopy" target="_top">CGPathCreateMutableCopy</a></code> make a copy of a path.</p></td></tr><tr><td  scope="row"><p><code><a href="../../../Reference/QuickDraw_Ref/Reference/reference.html#//apple_ref/c/func/DiffRgn" target="_top">DiffRgn</a></code> finds the difference of two regions.</p></td><td ><p>There’s no analogue for this function in Quartz. <code>HIShapeDifference</code> finds the difference of two shapes. </p></td></tr><tr><td  scope="row"><p><code><a href="../../../Reference/QuickDraw_Ref/Reference/reference.html#//apple_ref/c/func/DisposeRgn" target="_top">DisposeRgn</a></code> frees the memory allocated for a region.</p></td><td ><p><code><a href="../../../../GraphicsImaging/Reference/CGPath/Reference/reference.html#//apple_ref/c/func/CGPathRelease" target="_top">CGPathRelease</a></code> decrements the retain count of a path.</p></td></tr><tr><td  scope="row"><p><code><a href="../../../Reference/QuickDraw_Ref/Reference/reference.html#//apple_ref/c/func/EmptyRgn" target="_top">EmptyRgn</a></code> determines whether a region is empty.</p></td><td ><p><code><a href="../../../../GraphicsImaging/Reference/CGPath/Reference/reference.html#//apple_ref/c/func/CGPathIsEmpty" target="_top">CGPathIsEmpty</a></code> determines whether a path is empty.</p></td></tr><tr><td  scope="row"><p><code><a href="../../../Reference/QuickDraw_Ref/DeprecationAppendix/AppendixADeprecatedAPI.html#//apple_ref/c/func/EraseRgn" target="_top">EraseRgn</a></code> fills a region using the current background pattern.</p></td><td ><p>To erase the area within a path, you simply fill it with opaque color. In a bitmap context, you can use <code><a href="../../../../GraphicsImaging/Reference/CGContext/Reference/reference.html#//apple_ref/c/func/CGContextClearRect" target="_top">CGContextClearRect</a></code> to create a transparent background for new drawing.</p></td></tr><tr><td  scope="row"><p><code><a href="../../../Reference/QuickDraw_Ref/DeprecationAppendix/AppendixADeprecatedAPI.html#//apple_ref/c/func/FillOval" target="_top">FillOval</a></code> and <code><a href="../../../Reference/QuickDraw_Ref/DeprecationAppendix/AppendixADeprecatedAPI.html#//apple_ref/c/func/PaintOval" target="_top">PaintOval</a></code> fill an oval using a pattern. <code><a href="../../../Reference/QuickDraw_Ref/DeprecationAppendix/AppendixADeprecatedAPI.html#//apple_ref/c/func/FrameOval" target="_top">FrameOval</a></code> draws an outline inside an oval.</p></td><td ><p><code><!--a target="_top" -->CGContextAddEllipseInRect<!--/a--></code> adds an ellipse (oval) to the current path.  <code><a href="../../../../GraphicsImaging/Reference/CGContext/Reference/reference.html#//apple_ref/c/func/CGContextFillEllipseInRect" target="_top">CGContextFillEllipseInRect</a></code> fills an ellipse that fits inside the specified rectangle. <code><a href="../../../../GraphicsImaging/Reference/CGContext/Reference/reference.html#//apple_ref/c/func/CGContextStrokeEllipseInRect" target="_top">CGContextStrokeEllipseInRect</a></code> strokes an ellipse that fits inside the specified rectangle. </p></td></tr><tr><td  scope="row"><p><code><a href="../../../Reference/QuickDraw_Ref/DeprecationAppendix/AppendixADeprecatedAPI.html#//apple_ref/c/func/FillRgn" target="_top">FillRgn</a></code> and <code><a href="../../../Reference/QuickDraw_Ref/DeprecationAppendix/AppendixADeprecatedAPI.html#//apple_ref/c/func/PaintRgn" target="_top">PaintRgn</a></code> fill a region using a pattern.</p></td><td ><p><code><a href="../../../../GraphicsImaging/Reference/CGContext/Reference/reference.html#//apple_ref/c/func/CGContextFillPath" target="_top">CGContextFillPath</a></code> and <code><a href="../../../../GraphicsImaging/Reference/CGContext/Reference/reference.html#//apple_ref/c/func/CGContextEOFillPath" target="_top">CGContextEOFillPath</a></code> paint the interior of a path with the current fill color. You also can fill a path using a custom pattern—see <span class="content_text"><a href="../../../../GraphicsImaging/Conceptual/drawingwithquartz2d/dq_patterns/dq_patterns.html#//apple_ref/doc/uid/TP30001066-CH206" target="_top">Patterns</a></span> in <em><a href="../../../../GraphicsImaging/Conceptual/drawingwithquartz2d/index.html#//apple_ref/doc/uid/TP30001066" target="_top">Quartz 2D Programming Guide</a></em>.</p></td></tr><tr><td  scope="row"><p><code><a href="../../../Reference/QuickDraw_Ref/DeprecationAppendix/AppendixADeprecatedAPI.html#//apple_ref/c/func/FrameRgn" target="_top">FrameRgn</a></code> strokes along the inside of a region’s boundary.</p></td><td ><p><code><a href="../../../../GraphicsImaging/Reference/CGContext/Reference/reference.html#//apple_ref/c/func/CGContextStrokePath" target="_top">CGContextStrokePath</a></code> strokes along the center of a path. <code><a href="../../../../GraphicsImaging/Reference/CGContext/Reference/reference.html#//apple_ref/c/func/CGContextStrokeLineSegments" target="_top">CGContextStrokeLineSegments</a></code> adds an array of line segments to the current path, and strokes the path. </p></td></tr><tr><td  scope="row"><p><code><a href="../../../Reference/QuickDraw_Ref/Reference/reference.html#//apple_ref/c/func/GetClip" target="_top">GetClip</a></code> obtains the current clip region.</p></td><td ><p>The clipping area in a graphics context is not accessible. <code><a href="../../../../GraphicsImaging/Reference/CGContext/Reference/reference.html#//apple_ref/c/func/CGContextGetClipBoundingBox" target="_top">CGContextGetClipBoundingBox</a></code> finds the smallest rectangle completely enclosing all points in the current clipping area, including any control points. </p></td></tr><tr><td  scope="row"><p><code><a href="../../../Reference/QuickDraw_Ref/Reference/reference.html#//apple_ref/c/func/MapRgn" target="_top">MapRgn</a></code> changes the size of a region.</p></td><td ><p>You can apply a scaling transform in a context before using a path. CGPath functions also allow you to apply a transform during path construction. </p></td></tr><tr><td  scope="row"><p><code><a href="../../../Reference/QuickDraw_Ref/Reference/reference.html#//apple_ref/c/func/NewRgn" target="_top">NewRgn</a></code> creates an empty region.</p></td><td ><p><code><a href="../../../../GraphicsImaging/Reference/CGPath/Reference/reference.html#//apple_ref/c/func/CGPathCreateMutable" target="_top">CGPathCreateMutable</a></code> creates an empty path. </p></td></tr><tr><td  scope="row"><p><code><a href="../../../Reference/QuickDraw_Ref/Reference/reference.html#//apple_ref/c/func/OffsetRgn" target="_top">OffsetRgn</a></code> changes the position of a region in its coordinate space.</p></td><td ><p>CGPath functions allow you to translate a path’s coordinates during path construction. <code><a href="../../../../GraphicsImaging/Reference/CGContext/Reference/reference.html#//apple_ref/c/func/CGContextTranslateCTM" target="_top">CGContextTranslateCTM</a></code> changes the origin in a context, which affects the current path. </p></td></tr><tr><td  scope="row"><p><code><a href="../../../Reference/QuickDraw_Ref/DeprecationAppendix/AppendixADeprecatedAPI.html#//apple_ref/c/func/OpenRgn" target="_top">OpenRgn</a></code> begins a region definition. <code><a href="../../../Reference/QuickDraw_Ref/DeprecationAppendix/AppendixADeprecatedAPI.html#//apple_ref/c/func/CloseRgn" target="_top">CloseRgn</a></code> ends the definition and saves the result.</p></td><td ><p>Analogues for these functions aren’t needed in Quartz, because path construction operations are separate from path drawing operations.</p></td></tr><tr><td  scope="row"><p><code><a href="../../../Reference/QuickDraw_Ref/Reference/reference.html#//apple_ref/c/func/PtInRgn" target="_top">PtInRgn</a></code> determines whether a region contains a specified pixel.</p></td><td ><p><code><a href="../../../../GraphicsImaging/Reference/CGPath/Reference/reference.html#//apple_ref/c/func/CGPathContainsPoint" target="_top">CGPathContainsPoint</a></code> determines whether a path contains a specified point in user space. </p></td></tr><tr><td  scope="row"><p><code><a href="../../../Reference/QuickDraw_Ref/Reference/reference.html#//apple_ref/c/func/RectRgn" target="_top">RectRgn</a></code> and <code><a href="../../../Reference/QuickDraw_Ref/Reference/reference.html#//apple_ref/c/func/SetRectRgn" target="_top">SetRectRgn</a></code> change the shape of a region into a rectangle.</p></td><td ><p><code><a href="../../../../GraphicsImaging/Reference/CGPath/Reference/reference.html#//apple_ref/c/func/CGPathAddRect" target="_top">CGPathAddRect</a></code> adds a rectangle to a path. <code><a href="../../../../GraphicsImaging/Reference/CGContext/Reference/reference.html#//apple_ref/c/func/CGContextAddRect" target="_top">CGContextAddRect</a></code> adds a rectangle to the current path in a context. </p></td></tr><tr><td  scope="row"><p><code><a href="../../../Reference/QuickDraw_Ref/Reference/reference.html#//apple_ref/c/func/RectInRgn" target="_top">RectInRgn</a></code> determines whether a rectangle intersects a region.</p></td><td ><p>There’s no analogue for this function in Quartz. Instead, consider the function <code><!--a target="_top" -->HIShapeIntersectRect<!--/a--></code>, which determines whether a rectangle intersects a shape.</p></td></tr><tr><td  scope="row"><p><code><a href="../../../Reference/QuickDraw_Ref/Reference/reference.html#//apple_ref/c/func/SectRgn" target="_top">SectRgn</a></code> finds the intersection of two regions.</p></td><td ><p>There’s no analogue for this function in Quartz. Instead, consider the function <code><a href="../../../Reference/HIShape_Reference/Reference/reference.html#//apple_ref/c/func/HIShapeIntersect" target="_top">HIShapeIntersect</a></code>, which finds the intersection of two shapes.</p></td></tr><tr><td  scope="row"><p><code><a href="../../../Reference/QuickDraw_Ref/Reference/reference.html#//apple_ref/c/func/SetClip" target="_top">SetClip</a></code> replaces the current clip region with another region.</p></td><td ><p><code><a href="../../../../GraphicsImaging/Reference/CGContext/Reference/reference.html#//apple_ref/c/func/CGContextClip" target="_top">CGContextClip</a></code> and <code><a href="../../../../GraphicsImaging/Reference/CGContext/Reference/reference.html#//apple_ref/c/func/CGContextEOClip" target="_top">CGContextEOClip</a></code> intersect the current clipping area with the area inside the current path.</p></td></tr><tr><td  scope="row"><p><code><a href="../../../Reference/QuickDraw_Ref/Reference/reference.html#//apple_ref/c/func/SetEmptyRgn" target="_top">SetEmptyRgn</a></code> sets an existing region to be empty.</p></td><td ><p><code><a href="../../../../GraphicsImaging/Reference/CGContext/Reference/reference.html#//apple_ref/c/func/CGContextBeginPath" target="_top">CGContextBeginPath</a></code> replaces the current path in a context with an empty path. (All drawing and clipping operations also consume the current path.) </p></td></tr><tr><td  scope="row"><p><code><a href="../../../Reference/QuickDraw_Ref/Reference/reference.html#//apple_ref/c/func/UnionRgn" target="_top">UnionRgn</a></code> finds the union of two regions.</p></td><td ><p>There’s no analogue for this function in Quartz. Instead, consider the function <code><a href="../../../Reference/HIShape_Reference/Reference/reference.html#//apple_ref/c/func/HIShapeUnion" target="_top">HIShapeUnion</a></code>, which finds the union of two shapes.</p></td></tr></table></div><a name="//apple_ref/doc/uid/TP40001098-CH220-DontLinkElementID_20" title="Relevant Resources"></a><h2>Relevant Resources</h2><p>In <em><a href="../../../../GraphicsImaging/Conceptual/drawingwithquartz2d/index.html#//apple_ref/doc/uid/TP30001066" target="_top">Quartz 2D Programming Guide</a></em>, see:</p><ul class="ul"><li class="li"><p><span class="content_text"><a href="../../../../GraphicsImaging/Conceptual/drawingwithquartz2d/dq_layers/dq_layers.html#//apple_ref/doc/uid/TP30001066-CH219" target="_top">CGLayer Drawing</a></span></p></li><li class="li"><p><span class="content_text"><a href="../../../../GraphicsImaging/Conceptual/drawingwithquartz2d/dq_context/dq_context.html#//apple_ref/doc/uid/TP30001066-CH203-CJBDCHAC" target="_top">Creating a Window Graphics Context</a></span></p></li><li class="li"><p><span class="content_text"><a href="../../../../GraphicsImaging/Conceptual/drawingwithquartz2d/dq_images/dq_images.html#//apple_ref/doc/uid/TP30001066-CH212-CJBHDDBE" target="_top">Masking an Image by Clipping the Context</a></span></p></li><li class="li"><p><span class="content_text"><a href="../../../../GraphicsImaging/Conceptual/drawingwithquartz2d/dq_context/dq_context.html#//apple_ref/doc/uid/TP30001066-CH203-CJBJDEFF" target="_top">Obtaining a Graphics Context for Printing</a></span></p></li><li class="li"><p><span class="content_text"><a href="../../../../GraphicsImaging/Conceptual/drawingwithquartz2d/dq_patterns/dq_patterns.html#//apple_ref/doc/uid/TP30001066-CH206" target="_top">Patterns</a></span></p></li><li class="li"><p><span class="content_text"><a href="../../../../GraphicsImaging/Conceptual/drawingwithquartz2d/dq_paths/dq_paths.html#//apple_ref/doc/uid/TP30001066-CH211" target="_top">Paths</a></span></p></li><li class="li"><p><span class="content_text"><a href="../../../../GraphicsImaging/Conceptual/drawingwithquartz2d/dq_paths/dq_paths.html#//apple_ref/doc/uid/TP30001066-CH211-BCIGICEF" target="_top">Setting Blend Modes</a></span></p></li><li class="li"><p><span class="content_text"><a href="../../../../GraphicsImaging/Conceptual/drawingwithquartz2d/dq_affine/dq_affine.html#//apple_ref/doc/uid/TP30001066-CH204" target="_top">Transforms</a></span></p></li></ul><p>See these reference documents:</p><ul class="ul"><li class="li"><p><em><a href="../../../../GraphicsImaging/Reference/CGAffineTransform/index.html#//apple_ref/doc/uid/TP30000946" target="_top">CGAffineTransform Reference</a></em></p></li><li class="li"><p><em><a href="../../../../GraphicsImaging/Reference/CGContext/index.html#//apple_ref/doc/uid/TP30000950" target="_top">CGContext Reference</a></em></p></li><li class="li"><p><em><a href="../../../../GraphicsImaging/Reference/CGGeometry/index.html#//apple_ref/doc/uid/TP30000955" target="_top">CGGeometry Reference</a></em></p></li><li class="li"><p><em><a href="../../../../GraphicsImaging/Reference/CGImage/index.html#//apple_ref/doc/uid/TP30000956" target="_top">CGImage Reference</a></em></p></li><li class="li"><p><em><a href="../../../../GraphicsImaging/Reference/CGLayer/index.html#//apple_ref/doc/uid/TP40001406" target="_top">CGLayer Reference</a></em></p></li><li class="li"><p><em><a href="../../../../GraphicsImaging/Reference/CGPath/index.html#//apple_ref/doc/uid/TP30000959" target="_top">CGPath Reference</a></em></p></li><li class="li"><p><em><a href="../../../Reference/HIViewReference/index.html#//apple_ref/doc/uid/TP30000785" target="_top">HIView Reference</a></em></p></li><li class="li"><p><em><a href="../../../Reference/HIShape_Reference/index.html#//apple_ref/doc/uid/TP40001170" target="_top">HIShape Reference</a></em></p></li></ul><p>For those interested in image processing, see <em><a href="../../../../GraphicsImaging/Conceptual/CoreImaging/index.html#//apple_ref/doc/uid/TP30001185" target="_top">Core Image Programming Guide</a></em>.</p>

        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../tq_strategies/tq_strategies.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../tq_color/tq_color.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2004, 2006 Apple Computer, Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2006-09-05<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Carbon/Conceptual/QuickDrawToQuartz2D/tq_other/tq_other.html%3Fid%3DTP40001098-5.2&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Carbon/Conceptual/QuickDrawToQuartz2D/tq_other/tq_other.html%3Fid%3DTP40001098-5.2&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Carbon/Conceptual/QuickDrawToQuartz2D/tq_other/tq_other.html%3Fid%3DTP40001098-5.2&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>