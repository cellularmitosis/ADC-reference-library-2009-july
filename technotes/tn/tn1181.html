<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"			"http://www.w3.org/TR/REC-html40/loose.dtd"><HTML><!-- Template 01-05-01 --><HEAD><LINK REL="stylesheet" HREF="../../adcstyle.css" TYPE="text/css"><LINK REL="stylesheet" HREF="../../style.css" TYPE="text/css">   <title>Technical Note TN1181: Sherlock's Find by Content Text Extractor Plug-ins</title>       <meta name="keywords" content="Sherlock Text Extractor Plug-ins">    <meta name="Description" content="Technical Note TN1181: A description of the Find by ContentText Extractors Plug-ins new for Mac OS 9."><meta name="categories" content="System Releases and Platforms and Tools"><meta name="week-posted" content="Dec 27, 1999 - Jan 7, 2000"><LINK REL="stylesheet" HREF="../../css/adcstyle.css" TYPE="text/css"><script language="JavaScript" type="text/javascript" src="../../js/adc.js"></script></HEAD><BODY BGCOLOR="#FFFFFF"><a name="//apple_ref/doc/uid/DTS10003020" title="Sherlock's Find by Content Text Extractor Plug-ins"></a><A NAME="top"></A><!-- begin_header_information --><!--#include virtual="/adcnavbar" --><p><a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../technicalnotes/index.html">Technical Notes</a> &gt; <a href="../../technicalnotes/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../technicalnotes/LegacyTechnologies/idxAppleApplications-date.html">Apple Applications</a> &gt; </p><div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/AppleApplications/idxSherlock-date.html" target="_blank">Apple Applications > Sherlock</a></li>
	</ul>
</div>




</div></div></div><!-- end_header_information --><!-- bottom_of_header_marker_comment --><!-- top_of_titles_marker_comment --><CENTER><table width="600" cellpadding="0" cellspacing="0" border="0">
<tr><td align="left" scope="row">
<h1>
<div id="pagehead">Technical Note TN1181</div>
<div id="pageheadsub">Sherlock's Find by Content Text Extractor Plug-ins</div>
</h1>
</td></tr></table></CENTER><!-- bottom_of_titles_marker_comment --><CENTER><TABLE BORDER=0 CELLSPACING=1 WIDTH=600><TR><td align="left">   <!-- begin_header_box --><table width="600" cellpadding="0" cellspacing="0" border="0">     <tr><td width=300 valign="top" align=left scope="row">    <table border="0" width="300" cellpadding="0" cellspacing="0">			<tr><td width=300 align=left> <img src="images/tnmenutop.gif" alt="" align="bottom" width=300 height=7></td>  </tr>  <tr bgcolor="#e6e6e6">   <td background="images/tnmenubody.gif" width=300 align=left> <span id="menutitle">CONTENTS   <br>  <br> </span>   </td>  </tr>  <tr bgcolor="#e6e6e6">   <td background="images/tnmenubody.gif" width=300 align=left> <!-- begin_toc -->         <P id = "menutext">         <A HREF = "#overview">Overview</A><BR><BR>         <A HREF = "#definition">Text Extractor Plug-ins Defined</A><BR><BR>         <A HREF = "#MIMEregistration">Registering the MIME Types a Plug-incan Understand</A><BR><BR>         <A HREF = "#structures">Structures Used By Plug-ins</A><BR><BR>         <A HREF = "#pluginroutines">Routines a Text Extractor MustDefine</A><BR><BR>         <A HREF = "#exampleplugin">An Example Plug-in</A><BR><BR>         <A HREF = "#examplecalls">Calling a Text Extractor Plug-in from anApplication</A><BR><BR>         <A HREF = "#listings">Index of Code Listings</A><BR><BR>         <A HREF = "#Summary">Summary</A><BR><BR>        <A HREF = "#References">References</A><BR><BR><A HREF = "#Downloads">Downloadables</A></p> <!-- end_toc --></td>  </tr>  <tr>   <td width=300 align=left scope="row"> <img src="images/tnmenubottom.gif" alt="" width=300 height=16>   </td>  </tr>    </table></td>  <td width=300 valign="top" align=left>            <!-- begin_intro_text --><p id = "introtext">This Technote         describes the API for creating Find By Content Text         Extractor Plug-ins.  Text Extractor Plug-ins are used by         Find by Content to extract the textual information stored in         a document when it is creating indexes and summarizing files.         By doing so, it is         possible for users to avoid indexing peripheral data such as         formatting commands, HTML tags, and other data that does not         relate to the information         stored in the document.   By creating Text Extractor Plug-ins         for their document types, developers make it possible for         users to conduct meaningful searches for information stored         in documents created by their applications.</P>         <p id = "introtext">Text Extractor Plug-ins can be created for use with         Mac OS 8.6 and later.  Mac OS 8.6 was         shipped with two Text Extractor Plug-ins:  the "HTML         Text Extractor" and the "PDF Text Extractor."  The "HTML         Text Extractor" strips the HTML tags from HTML files and         returns the text stored therein; the "PDF Text         Extractor" returns the textual information from Adobe&reg;&#146;s         Portable Document Format (PDF) files.  In Mac OS 8.5, indexing         HTML files meant that both the text stored in the document         and the HTML tags were incorporated into indexes.  Furthermore,PDF files         were excluded from the indexing process.  In Mac OS 8.6, meaningful         textual information extracted from these files is incorporated         into index files used by Find By Content.</P>         <p id = "introtext">This Technote provides information necessary for creating         and installing Text Extractor Plug-ins.  In addition, an annotated         example Text Extractor Plug-in is provided.  Developers         can easily modify this example to create their own         plug-in for use with their own file formats.</P>     <!-- end_intro_text --><!-- begin_date --><h3>&nbsp;Updated: [Jan 18 2000]</h3><!-- end_date --></TD> </TR>    </TABLE> <!-- end_header_box --><BR><BR><hr width=500 align=center><BR><BR><!-- begin_content --><A NAME="overview"></A>         <BR> <H2>Overview</H2>         <P>Text Extractors improve the accuracy of indexing and         summarizing files.  As an example, consider the         HTML file shown in Listing 1.</P><A NAME="HTMLListing"></A>         <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>&lt;!--This HTML file contains both HTML tags and ASCII text.  Forindexing purposes, it would be more useful to ignore the tags and onlyincorporate the document's text into the index.--&gt;&nbsp;&lt;HTML&gt;&lt;BODY&gt;This is a sample document.&lt;/BODY&gt;&lt;/HTML&gt;</pre></TD></TR></TABLE></CENTER><P align = center><B>Listing 1</B>.  A sample HTML file.</p><P>Without knowing the HTML format, every word above would getindexed,so searching for "body" in Find by Content would find the abovedocument,but when a user opened the file in her web browser, she would notsee "body".Similarly, summarizing a HTML document would show HTML Tags inthe summary.The HTML Text Extractor knows the format of an HTML file so itwill skip theHTML Tags and return just the text that a user would see viewingthe document.For the above example, "This is a sample document." would be theonly textthat is indexed. </P><p><A HREF = "#top">Back to top</a></p><BR><A NAME="definition"></A>         <BR> <H2>Text Extractor Plug-ins Defined</H2>         <P>Text Extractor Plug-ins are Code Fragments that have the following         characteristics:</P>         <UL><LI>File Type: <CODE>'fbce'</CODE></li><LI>Creator Type: <CODE>'fndf'</CODE></li><LI>Code Fragment Name: "IATextExtractor"</li>            <LI>System Location: "Find by Content Plug-ins" folder of the            "Find" folder of the "Extensions" folder.  The folder type            <CODE>kFindByContentPluginsFolderType</CODE>  (<CODE>'fbcp'</CODE>)            can be passed to the function <CODE>FindFolder</CODE> to locate the            folder.</li>            <LI>Exported Functions - A Text Extractor Plug-in mustimplement and            export all of the following functions:                <UL>                <LI><A HREF = "#initroutine"><CODE>IAPluginInit</CODE></A> - When                a text extractor plug in is opened, the exported function                IAPluginInit is called.</li>                <LI><A HREF = "#termroutine"><CODE>IAPluginTerm</CODE></A> -When a session with a text extractor                plug-in is terminated, the function IAPluginTerm is called.At this                time the plug-in can perform any needed cleanup.</li>                <LI><A HREF = "#versionroutine"><CODE>IAGetExtractorVersion</CODE></A> - Returns theversion of the                Text Extractor Interface that plug-in corresponds to.</li>                <LI><A HREF = "#countdocsroutine"><CODE>IACountSupportedDocTypes</CODE></A> -Returns the number of                document types the plug-in knows how to handle.  This callreturns                the maximum valid index for the call<CODE>IAGetIndSupportedDocType</CODE>.</li>                <LI><A HREF = "#getdocsroutine"><CODE>IAGetIndSupportedDocType</CODE></A> - Returnsthe <I>nth</I> document                type the plug-in supports (first item is 1 not 0).Documents are                identified by  Multipurpose Internet Mail Extension (MIME)type and                subtype for example an HTML document would have a MIME type of                "text/html".</li>                <LI><A HREF = "#opendocsroutine"><CODE>IAOpenDocument</CODE></A> - Creates areference to the text of                a document,  the IADocRef type is on opaque type that itdefined by                the plug-in to reference the document. The IADocAccessorPtrcontains                a reference to a document and pointers to functions used toaccess                the document.  The document accessor pointer will be validfor all                calls that use the returned IADocRef until IACloseDocument is                called.</li>                <LI><A HREF = "#closedocsroutine"><CODE>IACloseDocument</CODE></A> - Perform anyneeded cleanup for                the plug-in defined IADocRef object.</li><LI><A HREF = "#getnexttextroutine"><CODE>IAGetNextTextRun</CODE></A> - Given a opendocument reference,                get the next run of text associated with the item.  Fillsthe bufferwith the next run of text.  On input ioSize is the size ofthe buffer,on output ioSize is the number of bytes written to thebuffer.  Ifthe encoding or languages of a document changeserrIAEndOfTextRunshould be returned.  Note:  a result of errIAEndOfTextRundoes notnecessarily mean that the routine will return an empty buffer.</li><LI><A HREF = "#getruninforoutine"><CODE>IAGetTextRunInfo</CODE></A> - Gets theencoding andlanguage of the text that was returned in the last call toIAGetNextTextRun.</li></UL></li>         </UL>         <P>A Text Extractor Plug-in's resource file may contain one or more         <CODE>'mimp'</CODE> resources that advertise the kinds of filesthe plug-in         is able to process.  The format of these resources is defined in the         <A HREF = "#MIMEregistration">Registering the MIME Types a Plug-incan Understand</A>         section below.</P><p><A HREF = "#top">Back to top</a></p><BR><ANAME="MIMEregistration"></A>         <BR> <H2>Registering the MIME Types a Plug-in can Understand</H2>         <P>Clients of Text Extractors need to map documents to a MIMEtype.  To         help clients determine the document types a plug-in understands,         a plug-in can include one or more <CODE>'mimp'</CODE> resources         in its resource file.  Definitions for defining your own<CODE>'mimp'</CODE>         can be found in the file "IAExtractor.r".  As shown in Listing 2,<CODE>'mimp'</CODE>         resources contain information about file Finder types and fileextensions         that map to a MIME type.</P><A NAME="resourceListing"></A><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>/* An example 'mimp' resources for Portable Document Format (PDF) documents. */&nbsp;#include "IAExtractor.r"resource 'mimp' (128) {    kIACurrentMIMEMappingVersion,    'PDF ',                      /* file type */    'CARO',                      /* file creator */    ".pdf",                      /* file extension */    "application/pdf",           /* MIME type   */    "Portable Document Format"   /* description */};</pre></TD></TR></TABLE></CENTER><p align="center"><B>Listing 2</B>.  A sample <CODE>'mimp'</CODE> resource forPDF files.</p>          <P>When creating indexes, Find By Content uses calls to InternetConfig          to discover the file's MIME type.  Once a file's MIME type has been          discovered, it then uses the a Text Extractor Plug-in capable ofextracting          text from the file (based on the MIME types the extractoradvertises it          can decode in its <CODE>'mimp'</CODE> resource).</P>          <P>MIME types reported by Text Extractor Plug-ins must be of theformat          type  "/"  subtype otherwise the extractor will be ignored.  Also, an          extractor's initialization function should verify (and correct, if          necessary) that any entries in Internet Config's file mapping          database referencing the extractor's type and creator specify the          same mime type as the Text Extractor Plug-in.</P><p><A HREF = "#top">Back to top</a></p><BR><A NAME="structures"></A>         <BR> <H2>Structures Used By Plug-ins</H2>         <P>Find By Content provides a number of routines and callbacks         that can be used by Text Extractor Plug-ins.  These callbacks         provide access to memory allocation and file input.  The following         sections describe the structures used by Find By Content to         provide these callbacks and the callbacks themselves.</P>         <P>Application developers wanting to call Text Extractor Plug-ins         from their own code will want to create and initialize thesestructures         themselves.  Examples of how to do this can be found later in the         <A HREF = "#examplecalls">Calling a Text Extractor Plug-in from anApplication</A>         section below.</P>        <A NAME="initstruct"></A>        <H3>The IAPluginInitBlock Structure</H3>        <P>The <CODE>IAPluginInitBlock</CODE> record provides call backroutines that remain constant the entire time a Text Extractor Plug-in isopen.  A pointer to this structure is passed as a parameter to theplug-in's <CODE>IAPluginInit</CODE> routine; and, it is safe for a plug-into save a pointer to this structure and make callbacks through it any timebefore the <CODE>IAPluginTerm</CODE> routine is called. Listing 3 shows thecontents of the <CODE>IAPluginInitBlock</CODE> structure and prototypes forthe callbacks made available by this structure. This structure and macrosfor making callbacks (shown as routine prototypes for illustrative purposesin Listing 3) are defined in the file "IAExtractor.h". </P>                <A NAME="initblockListing"></A><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>/* IAPluginInitBlock structure definition */typedef struct IAPluginInitBlock* IAPluginInitBlockPtr;struct IAPluginInitBlock {        IAAllocUPP  Alloc;        IAFreeUPP   Free;        IAIdleUPP   Idle;};typedef struct IAPluginInitBlock IAPluginInitBlock;    /* Routine Prototypes */void* CallIAAllocProc(IAAllocUPP Alloc, UInt32 inSize);void CallIAFreeProc(IAFreeUPP Free, void* object);UInt8 CallIAIdleProc(IAIdleUPP Idle);</pre></TD></TR></TABLE></CENTER>          <P align=center><B>Listing 3</B>.  Declaration of the<CODE>IAPluginInitBlock</CODE> structure and prototypes that can be usedfor calling the routines referenced in the structure.</p>          <P><CODE>IAPluginInitBlock</CODE> provides callbacks forallocating memory and an <code>idle</code> callback that can be calledduring lengthy operations.  Plug-ins should use the memory allocationroutines provided in this structureinstead of direct calls to the Memory Manager. Callbacks provided by thisstructure are described below.</P>                <P><B><CODE>CallIAAllocProc</CODE></B></P>                  <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>void* CallIAAllocProc(        IAAllocUPP Alloc,        UInt32 inSize);</pre></TD></TR></TABLE></CENTER><BR><BR>                    <P><CODE>Alloc</CODE> - the value stored in the Allocfield in the <CODE>IAPluginInitBlock</CODE> structure.</P>                    <P><CODE>inSize</CODE> - The number of bytes toallocate.</P>                    <P>result - a pointer to a block of storage or                    <CODE>NULL</CODE> if the request cannot be allocated.</P>                    <P><CODE>CallIAAllocProc</CODE> is a callback procedureprovided                in the <A HREF = "#initstruct"><CODE>IAPluginInitBlock</CODE></A>                structure that can be called by plug-ins to allocatememory.</P><P><CODE>CallIAAllocProc</CODE> can be used for allocating memory.Plug-ins should use this callback for all memory requests.  If successful,the callback returns a pointer to a block containing the requested numberof bytes.  If an error occurs or there is not enough memory to complete therequest, then the callback returns <CODE>NULL</CODE>.</P><P><B><CODE>CallIAFreeProc</CODE></B></P><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>void CallIAFreeProc(        IAFreeUPP Free,        void* object);</pre></TD></TR></TABLE></CENTER><BR><BR>                    <P><CODE>Free</CODE> - the value stored in the Freefield in the <CODE>IAPluginInitBlock</CODE> structure.</P>                    <P><CODE>object</CODE> - a pointer to a block of memoryallocated through the <CODE>CallIAAllocProc</CODE> callback.</P>                               <P><CODE>CallIAFreeProc</CODE> is a callback procedure provided                in the <A HREF = "#initstruct"><CODE>IAPluginInitBlock</CODE></A>                structure that can be called by plug-ins to release memory                allocated by the <CODE>CallIAAllocProc</CODE> routine.</P><P><CODE>CallIAFreeProc</CODE> can be used for deallocating memoryallocated by calls to the <CODE>CallIAAllocProc</CODE> callback.</P><P><B><CODE>CallIAIdleProc</CODE></B></P><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>UInt8 CallIAIdleProc(        IAIdleUPP Idle);</pre></TD></TR></TABLE></CENTER><BR><BR><P><CODE>Idle</CODE> - the value stored in the <code>idle</code> field in the<CODE>IAPluginInitBlock</CODE> structure</P>                    <P><CODE>result</CODE> - non-zero if the currentoperation should                    be canceled, zero to continue.</P>                <P><CODE>CallIAIdleProc</CODE> is a callback procedure providedin the <A HREF = "#initstruct"><CODE>IAPluginInitBlock</CODE></A>structure that can be called by plug-ins while they are processinglengthy tasks.</P><P><CODE>CallIAIdleProc</CODE> should be called by a plug-in duringlengthy tasks.  By calling this routine, plug-ins canallow other tasks time to run.  If this callbackreturns any value other than zero, then the plug-in shouldstop processing immediately and return a <CODE>errIACanceled</CODE>result.  If the <code>idle</code> callback returns zero, then the plug-inshould continue processing and, perhaps, call the <CODE>idle</CODE>procedure again if necessary.</P><P>Applications developers wanting to call Text Extractor Plug-ins frominside of their own applications will have to initialize this structureand define the necessary callbacks themselves.  An example showing how toset up a <CODE>IAPluginInitBlock</CODE> structure can be found in the<A HREF = "#iBlockSetup">Setting up the <CODE>IAPluginInitBlock</CODE>structure</A> section later in this document.</P><p><A HREF = "#top">Back to top</a></p><BR><A NAME="iostruct"></A><H3>The <CODE>IADocAccessorRecord</CODE> Structure</H3><P>The <CODE>IADocAccessorRecord</CODE> provides callbacks for accessinginformation in files.  Plug-ins should be aware that although the contentsof the <CODE>IAPluginInitBlock</CODE> will remain constant during the timewhilea plug-in is open (between calls to <CODE>IAPluginInit</CODE> and<CODE>IAPluginTerm</CODE>), it is possible that the plug-in will be passedone or more <CODE>IADocAccessorRecord</CODE> structures that refer todifferent files. However, it is safe to assume that the<CODE>IADocAccessorRecord</CODE> structure passed to a plug-in's<CODE>IAOpenDocument</CODE> routine will remain the same until theplug-in's <CODE>IACloseDocument</CODE> routine is called. Listing 4 showsthe definition or the <CODE>IADocAccessorRecord</CODE> and macros (shown asroutine prototypes for illustrative purposes) that can be used to call backthrough this structure.</P>            <A NAME="docAccListing"></A><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>    /* IADocAccessorRecord structure definition. */typedef struct IADocAccessorRecord*     IADocAccessorPtr;struct IADocAccessorRecord {            /* docAccessor is an opaque type used by Find By Content               to track the file.  It is not possible for plug-ins to               access this information. */        IADocAccessorRef                docAccessor;        IADocAccessorOpenUPP            OpenDoc;        IADocAccessorCloseUPP           CloseDoc;        IADocAccessorReadUPP            ReadDoc;        IASetDocAccessorReadPositionUPP SetReadPosition;        IAGetDocAccessorReadPositionUPP GetReadPosition;        IAGetDocAccessorEOFUPP          GetEOF;};typedef struct IADocAccessorRecord IADocAccessorRecord;    /* Routine Prototypes. */OSStatus CallIADocumentAccessorOpen(IADocAccessorRef inAccessor);OSStatus CallIADocumentAccessorClose(IADocAccessorRef inAccessor);OSStatus CallIADocumentAccessorRead(IADocAccessorRef inAccessor,        void* buffer, UInt32* ioSize);OSStatus CallIASetDocumentAccessorReadPosition(IADocAccessorRef inAccessor,        SInt32 inMode, SInt32 inOffset);OSStatus CallIAGetDocumentAccessorReadPosition(IADocAccessorRef inAccessor,        SInt32* outPostion);OSStatus CallIAGetDocumentAccessorEOF(IADocAccessorRef inAccessor, SInt32*outEOF);/* macros corresponding to the routine prototypes above */#define CallIADocumentAccessorOpen(accessor) \InvokeIADocAccessorOpenUPP((accessor)-&gt;docAccessor, \(accessor)-&gt;OpenDoc)#define CallIADocumentAccessorClose(accessor) \    InvokeIADocAccessorCloseUPP((accessor)-&gt;docAccessor,\    (accessor)-&gt;CloseDoc)#define CallIADocumentAccessorRead(accessor, buffer, size) \    InvokeIADocAccessorReadUPP((accessor)-&gt;docAccessor, (buffer),\    (size), (accessor)-&gt;ReadDoc)#define CallIASetDocumentAccessorReadPosition(accessor, mode, offset) \    InvokeIASetDocAccessorReadPositionUPP((accessor)-&gt;docAccessor,\    (mode), (offset), (accessor)-&gt;SetReadPosition)#define CallIAGetDocumentAccessorReadPosition(accessor,\    outPosition) \    InvokeIAGetDocAccessorReadPositionUPP((accessor)-&gt;docAccessor,\    (outPosition), (accessor)-&gt;GetReadPosition)#define CallIAGetDocumentAccessorEOF(accessor, outEOF) \    InvokeIAGetDocAccessorEOFUPP((accessor)-&gt;docAccessor, \    (outEOF), accessor)-&gt;GetEOF)</pre></TD></TR></TABLE></CENTER>          <P align=center><B>Listing 4</B>.  Declaration of the<CODE>IADocAccessorRecord</CODE> structure and prototypes that can be usedfor calling the routines referenced in the structure.</p><P>The <CODE>IADocAccessorRecord</CODE> defined in Listing 4 providesplug-ins with all the necessary resources for accessing files.  Plug-insshould notmake calls to the File Manager directly.  Instead, they should performall file input operations necessary for accessing a file throughthese callbacks.  Fields and callbacks defined in this structureare discussed below.</P><A NAME="CallIADocumentAccessorOpenListing"></A><P><B><CODE>CallIADocumentAccessorOpen</CODE></B></P><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>OSStatus CallIADocumentAccessorOpen(        IADocAccessorRef inAccessor);</pre></TD></TR></TABLE></CENTER><BR><BR>                    <P><CODE>inAccessor</CODE> - a pointer to the<CODE>IADocAccessorRecord</CODE>                    passed to the <CODE>IAOpenDocument</CODE> routine.</P>                    <P>result - <CODE>errIANoErr</CODE> if the operationwas successful,                    some other error code if the operation failed.</P>                <P><CODE>CallIADocumentAccessorOpen</CODE> is a callback procedure providedin the <A HREF = "#iostruct"><CODE>IADocAccessorRecord</CODE></A>structure that can be called by plug-ins to open a file for input.</P><P><CODE>CallIADocumentAccessorOpen</CODE> opens the documentfor reading.  Plug-ins should call this routine to openthe document for reading before making any of the inputcalls described below.</P>           <A NAME="CallIADocumentAccessorCloseListing"></A>                <P><B><CODE>CallIADocumentAccessorClose</CODE></B></P><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>OSStatus CallIADocumentAccessorClose(        IADocAccessorRef inAccessor);</pre></TD></TR></TABLE></CENTER><BR><BR>                    <P><CODE>inAccessor</CODE> - a pointer to the<CODE>IADocAccessorRecord</CODE>                    passed to the <CODE>IAOpenDocument</CODE> routine.<CODE>inAccessor</CODE> must be                    in the open state when this routine is called.</P>                    <P>result - <CODE>errIANoErr</CODE> if the operationwas successful,                    some other error code if the operation failed.</P>               <P><CODE>CallIADocumentAccessorClose</CODE> is a callback procedure providedin the <A HREF = "#iostruct"><CODE>IADocAccessorRecord</CODE></A>structure that can be called by plug-ins to close a file thatwas opened by a call to <CODE>CallIADocumentAccessorOpen</CODE>.</P><P><CODE>CallIADocumentAccessorClose</CODE> should be called toclose a file opened by a call to <CODE>CallIADocumentAccessorOpen</CODE>.</P><A NAME="CallIADocumentAccessorReadListing"></A><P><B><CODE>CallIADocumentAccessorRead</CODE></B></P><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>OSStatus CallIADocumentAccessorRead(        IADocAccessorRef inAccessor,        void* buffer,        UInt32* ioSize);</pre></TD></TR></TABLE></CENTER><BR><BR><P><CODE>inAccessor</CODE> - a pointer to the <CODE>IADocAccessorRecord</CODE>passed to the <CODE>IAOpenDocument</CODE> routine.  <CODE>inAccessor</CODE>must be in the open state when this routine is called.</P><P><CODE>buffer</CODE> - a pointer to a buffer where the data should bestored.</P><P><CODE>ioSize</CODE> - a pointer to a 32-bit integer containing the number ofbytes to be read.  When the routine returns, this value will have been updatedto the actual number of bytes read.</P><P>result - <CODE>errIANoErr</CODE> if the operation was successful,some other error code if the operation failed.</P><P><CODE>CallIADocumentAccessorRead</CODE> is a callback procedure providedin the <A HREF = "#iostruct"><CODE>IADocAccessorRecord</CODE></A>structure that can be called by plug-ins to read data from a file.</P><P><CODE>CallIADocumentAccessorRead</CODE> reads <CODE>*ioSize</CODE> bytesfrom the file starting at the current read file position.  On return,<CODE>*ioSize</CODE> will reflect the actual number of bytes read andthe routine's result will indicate the success of the call.  Ifthis callback returns an <CODE>eofErr</CODE> error, be sure to checkthe value stored in <CODE>*ioSize</CODE> as it is possible that somebytes may have been read into the buffer before the end of thefile was encountered.  Calls to <CODE>CallIADocumentAccessorRead</CODE>advance the read position for the file past the bytes that havebeen read - the next call to <CODE>CallIADocumentAccessorRead</CODE>begins where the last one left off.</P>           <A NAME="CallIASetDocumentAccessorReadPositionListing"></A><P><B><CODE>CallIASetDocumentAccessorReadPosition</CODE></B></P><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>OSStatus CallIASetDocumentAccessorReadPosition(        IADocAccessorRef inAccessor,        SInt32 inMode,        SInt32 inOffset);</pre></TD></TR></TABLE></CENTER><BR><BR><P><CODE>inAccessor</CODE> - a pointer to the <CODE>IADocAccessorRecord</CODE>passed to the <CODE>IAOpenDocument</CODE> routine.  <CODE>inAccessor</CODE>must be in the open state when this routine is called.</P><P><CODE>inMode</CODE> - contains one of the following positioningconstants:</P><UL><LI><CODE>kIAFromStartMode</CODE> - <CODE>inOffset</CODE> contains a valueto be interpreted as an offset from the start of the file.</li><LI><CODE>kIAFromCurrMode</CODE> - <CODE>inOffset</CODE> contains a valueto be interpreted as an offset the current read position.</li><LI><CODE>kIAFromEndMode</CODE> - <CODE>inOffset</CODE> contains a valueto be interpreted as an offset from the end of the file.</li></UL><P><CODE>inOffset</CODE> - contains a 32-bit signed integer used to offsetthe current read position.</P><P>result - <CODE>errIANoErr</CODE> if the operation was successful,some other error code if the operation failed.</P>                <P><CODE>CallIASetDocumentAccessorReadPosition</CODE> is a callbackprocedure provided in the <A HREF = "#iostruct"><CODE>IADocAccessorRecord</CODE></A>structure that can be called by plug-ins to set the positionwhere the next read will take place when<CODE>CallIADocumentAccessorRead</CODE> is called.</P><P><CODE>CallIASetDocumentAccessorReadPosition</CODE> can be usedto set the position where the next call to<CODE>CallIADocumentAccessorRead</CODE>will begin reading bytes from thefile.  When a file is first opened, its read position is set to thebeginning of the file.</P><A NAME="CallIAGetDocumentAccessorReadPositionListing"></A><P><B><CODE>CallIAGetDocumentAccessorReadPosition</CODE></B></P><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>OSStatus CallIAGetDocumentAccessorReadPosition(        IADocAccessorRef inAccessor,        SInt32* outPostion);</pre></TD></TR></TABLE></CENTER><BR><BR><P><CODE>inAccessor</CODE> - a pointer to the <CODE>IADocAccessorRecord</CODE>passed to the <CODE>IAOpenDocument</CODE> routine.  <CODE>inAccessor</CODE>must be in the open state when this routine is called.</P><P><CODE>outPostion</CODE> - a pointer to a 32-bit value that is set tothe current read position's offset from the beginning of the file.</P><P>result - <CODE>errIANoErr</CODE> if the operation was successful,some other error code if the operation failed.</P>          <P><CODE>CallIAGetDocumentAccessorReadPosition</CODE> is a callbackprocedure provided in the <A HREF = "#iostruct"><CODE>IADocAccessorRecord</CODE></A>structure that can be called by plug-ins to determine the position wherethe next read will take place when <CODE>CallIADocumentAccessorRead</CODE>is called.</P><P><CODE>CallIAGetDocumentAccessorReadPosition</CODE> returns thelocation where the next read operation will take place in<CODE>*outPostion</CODE>.  The value returned is an offset fromthe beginning of the file.</P><A NAME="CallIAGetDocumentAccessorEOFListing"></A><P><B><CODE>CallIAGetDocumentAccessorEOF</CODE></B></P><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>OSStatus CallIAGetDocumentAccessorEOF(        IADocAccessorRef inAccessor,        SInt32* outEOF);</pre></TD></TR></TABLE></CENTER><BR><BR><P><CODE>inAccessor</CODE> - a pointer to the <CODE>IADocAccessorRecord</CODE>passed to the <CODE>IAOpenDocument</CODE> routine.  <CODE>inAccessor</CODE>must be in the open state when this routine is called.</P><P><CODE>outEOF</CODE> - a pointer to a 32-bit value that is set tothe number of bytes in the file.</P><P>result - <CODE>errIANoErr</CODE> if the operation was successful,some other error code if the operation failed.</P><P><CODE>CallIAGetDocumentAccessorReadPosition</CODE> is a callbackprocedure provided in the <A HREF = "#iostruct"><CODE>IADocAccessorRecord</CODE></A>structure that can be called by plug-ins to determine length of the inputfile.</P><P><CODE>CallIAGetDocumentAccessorEOF</CODE> can be used to discoverthe length of a file.  On return, <CODE>*outEOF</CODE> is set to the totalnumber of bytes in the file.</P>        <P>Applications developers wanting to call Text Extractor Plug-ins from        inside of their own applications will have to initialize this structure        and define the necessary callbacks themselves.  An example showing how        to set up a <CODE>IADocAccessorRecord</CODE> structure can be found in        the <A HREF = "#docAccSetup">Setting up the<CODE>IADocAccessorRecord</CODE> structure</A> section later in thisdocument.  </P><p><A HREF = "#top">Back to top</a></p><BR><ANAME="pluginroutines"></A>         <BR> <H2>Routines a Text Extractor Must Define</H2>         <P>This section describes the routines that must be exported by         all Text Extractor Plug-ins.  This section provides a detailed         description of each routine along with some discussion any important         issues related to each routine.</P>        <A NAME="initroutine"></A>        <H3><CODE>IAPluginInit</CODE></H3><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>OSStatus IAPluginInit(        IAPluginInitBlockPtr initBlock,        IAPluginRef *outPluginRef);</pre></TD></TR></TABLE></CENTER><BR><BR><P><CODE>initBlock</CODE> - contains a pointer to a<A HREF = "#initstruct"><CODE>IAPluginInitBlock</CODE></A> structure.</P><P><CODE>outPluginRef</CODE> - is a pointer to a 32-bit value that willbe passed to other plug-in routines while the plug-in is open.  Aplug-in may set this value in its <CODE>IAPluginInit</CODE> routineand it will remain unchanged until <A HREF = "#termroutine"><CODE>IAPluginTerm</CODE></A> is called.</P><P>result - <CODE>errIANoErr</CODE> if the operation was successful,some other error code if the operation failed.</P><P><CODE>IAPluginInit</CODE> is a routine that must be providedin the plug-in's code fragment.</P><P>After the plug-in's code fragment has been prepared for execution,the plug-in's <CODE>IAPluginInit</CODE> routine is called.  This routineprovides an opportunity for a plug-in to perform any necessary initializationoperations it may require.</P><P>The callbacks in the<A HREF = "#initstruct"><CODE>IAPluginInitBlock</CODE></A> pointed to by the<CODE>initBlock</CODE> parameter remain valid while the plug-in is open (until<A HREF = "#termroutine"><CODE>IAPluginTerm</CODE></A> is called)and may be called from any of the plug-in's other routines.  The valuestored in <CODE>*outPluginRef</CODE> is dedicated for the plug-in's use andmay be used to store persistent state information that is to remain intactbetween calls to the plug-in (this value is not saved after the plug-inhas been closed).</P><P>For an example illustrating how this routine could be implementedrefer to <A HREF = "#IAPluginInitExample">Listing 6</A>.</P><p><A HREF = "#top">Back to top</a></p><BR>        <A NAME="termroutine"></A>        <H3><CODE>IAPluginTerm</CODE></H3><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>OSStatus IAPluginTerm(IAPluginRef inPluginRef);</pre></TD></TR></TABLE></CENTER><BR><BR><P><CODE>inPluginRef</CODE> - a 32-bit value dedicated for the plug-in'suse. This value will be the same as the value the <CODE>*outPluginRef</CODE>parameter was set to in the <A HREF = "#initroutine"><CODE>IAPluginInit</CODE></A>call.</P><P>result - <CODE>errIANoErr</CODE> if the operation was successful,some other error code if the operation failed.</P><P><CODE>IAPluginTerm</CODE> is a routine that must be providedin the plug-in's code fragment.</P><P>Before a plug-in's Code Fragment Manager connection is closed, theplug-in's <CODE>IAPluginTerm</CODE> routine is called.  This routineprovides opportunity for the plug-in to perform any necessarycleanup operations required such as deallocating storage, closingresource files, et cetera.  After this routine has been called, therewill be no other calls made to the plug-in until the next time itis opened by a call to <A HREF = "#initroutine"><CODE>IAPluginInit</CODE></A>.</P><P>For an example illustrating how this routine could be implementedrefer to <A HREF = "#IAPluginTermExample">Listing 7</A>.</P><p><A HREF = "#top">Back to top</a></p><BR>        <A NAME="versionroutine"></A>        <H3><CODE>IAGetExtractorVersion</CODE></H3> <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>OSStatus IAGetExtractorVersion(        IAPluginRef inPluginRef,        UInt32 outPluginVersion);</pre></TD></TR></TABLE></CENTER><BR><BR><P><CODE>inPluginRef</CODE> - a 32-bit value dedicated for the plug-in'suse. This value will be the same as the value the <CODE>*outPluginRef</CODE>parameter was set to in the <A HREF = "#initroutine"><CODE>IAPluginInit</CODE></A>call.</P><P><CODE>outPluginVersion</CODE> - a pointer to a 32-bit value.  Yourroutine should set this value to <CODE>kIAExtractorCurrentVersion</CODE>.</P><P>result - <CODE>errIANoErr</CODE> if the operation was successful,some other error code if the operation failed.</P><P><CODE>IAGetExtractorVersion</CODE> is a routine that must be providedin the plug-in's code fragment.</P><P>In this routine, a plug-in should set the value<CODE>*outPluginVersion</CODE>to the version of the Text Extractor Plug-in interface it was compiled against.The constant <CODE>kIAExtractorCurrentVersion</CODE>, defined in"IAExtractor.h",contains the current version of the Text Extractor Plug-in interface. </P><P>For an example illustrating how this routine could be implementedrefer to <A HREF = "#IAGetExtractorVersionExample">Listing 8</A>.</P><p><A HREF = "#top">Back to top</a></p><BR>        <A NAME="countdocsroutine"></A>        <H3><CODE>IACountSupportedDocTypes</CODE></H3><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>OSStatus IACountSupportedDocTypes(        IAPluginRef inPluginRef,        UInt32* outCount);</pre></TD></TR></TABLE></CENTER><BR><BR><P><CODE>inPluginRef</CODE> - a 32-bit value dedicated for the plug-in'suse. This value will be the same as the value the<CODE>*outPluginRef</CODE> parameter was set to in the <A HREF = "#initroutine"><CODE>IAPluginInit</CODE></A>call.</P><P><CODE>outCount</CODE> - a pointer to a 32-bit integer.  The plug-in shouldset this integer to the number of document types that it knows how tohandle.</P><P>result - <CODE>errIANoErr</CODE> if the operation was successful,some other error code if the operation failed.</P><P><CODE>IACountSupportedDocTypes</CODE> is a routine that must be providedin the plug-in's code fragment.</P><P>This routine should set <CODE>*outCount</CODE> to the number of documenttypes the plug-in is able to handle.  The value stored in<CODE>*outCount</CODE> is interpreted as the maximum valid index that canbe provided as an index in<A HREF = "#getdocsroutine"><CODE>IAGetIndSupportedDocType</CODE></A> calls.</P><P>For an example illustrating how this routine could be implementedrefer to <A HREF = "#IACountSupportedDocTypesExample">Listing 9</A>.</P><p><A HREF = "#top">Back to top</a></p><BR>        <A NAME="getdocsroutine"></A>        <H3><CODE>IAGetIndSupportedDocType</CODE></H3><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>OSStatus IAGetIndSupportedDocType(        IAPluginRef inPluginRef,        UInt32 inIndex,        char** outMIMEType);</pre></TD></TR></TABLE></CENTER><BR><BR><P><CODE>inPluginRef</CODE> - a 32-bit value dedicated for the plug-in'suse. This value will be the same as the value the <CODE>*outPluginRef</CODE>parameter was set to in the <A HREF = "#initroutine"><CODE>IAPluginInit</CODE></A>call.</P><P><CODE>inIndex</CODE> - a 32-bit integer value indicating the indexof the document type to return.  Index values range between 1 andthe maximum index value returned by <A HREF = "#countdocsroutine"><CODE>IACountSupportedDocTypes</CODE></A>.</P><P><CODE>*outMIMEType</CODE> - a pointer value of type <CODE>char*</CODE>.A plug-in should set this value to point to a stringcontaining the MIME type string.  The storage for this stringbelongs to the plug-in - if it was allocated by the plug-in,then the plug-in must deallocate it.</P><P>result - <CODE>errIANoErr</CODE> if the operation was successful,some other error code if the operation failed.</P><P><CODE>IAGetIndSupportedDocType</CODE> is a routine that must be providedin the plug-in's code fragment.</P>        <P>The routine <CODE>IAGetIndSupportedDocType</CODE> sets        <CODE>*outMIMEType</CODE> to point to a string containing        the <I>nth</I> MIME type the plug-in is able to understand.  Index        values that may be provided in the <CODE>inIndex</CODE> parameter        range from 1 (not zero) through the maximum value as reported        by the <A HREF = "#countdocsroutine"><CODE>IACountSupportedDocTypes</CODE></A>        call.</P>        <P>For an example illustrating how this routine could be implemented        refer to <A HREF = "#IAGetIndSupportedDocTypeExample">Listing 10</A>.</P><p><A HREF = "#top">Back to top</a></p><BR>        <A NAME="opendocsroutine"></A>        <H3><CODE>IAOpenDocument</CODE></H3><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>OSStatus IAOpenDocument(        IAPluginRef inPluginRef,        IADocAccessorPtr inAccessor,        IADocRef* outDoc);</pre></TD></TR></TABLE></CENTER><BR><BR><P><CODE>inPluginRef</CODE> - a 32-bit value dedicated for the plug-in'suse. This value will be the same as the value the <CODE>*outPluginRef</CODE>parameter was set to in the <A HREF = "#initroutine"><CODE>IAPluginInit</CODE></A>call.</P><P><CODE>inAccessor</CODE> - a pointer to a <A HREF = "#initstruct"><CODE>IAPluginInitBlock</CODE></A>containing callbacks necessary for reading information from a file.            </P><P><CODE>outDoc</CODE> - a pointer to a 32-bit value availablefor the plug-in to use for storing information specific to the document.Normally plug-ins will store a pointer to necessary statevariables specific to the document in this parameter.</P><P>result - <CODE>errIANoErr</CODE> if the operation was successful,some other error code if the operation failed.</P><P><CODE>IAOpenDocument</CODE> is a routine that must be providedin the plug-in's code fragment.</P><P><CODE>IAOpenDocument</CODE> is called before a plug-in is used to extracttext from a new document.  This routine provides opportunity for theplug-in to perform any initialization operations required beforeit begins reading text from a file.  Any state variables or databuffers required for processing the file should be stored in ablock of memory and a pointer to that block should be stored in<CODE>*outDoc</CODE>.  This value will be passed to the routines<A HREF = "#getnexttextroutine"><CODE>IAGetNextTextRun</CODE></A>,and <A HREF = "#getruninforoutine"><CODE>IAGetTextRunInfo</CODE></A> whilethe document is open, and then to <A HREF = "#closedocsroutine"><CODE>IACloseDocument</CODE></A>once all the required text has been extracted from the document.Both the <A HREF = "#initstruct"><CODE>IAPluginInitBlock</CODE></A>pointed to by the <CODE>inAccessor</CODE> parameter and the value stored in<CODE>*outDoc</CODE> will remain valid until<A HREF = "#closedocsroutine"><CODE>IACloseDocument</CODE></A> is called.  </P>        <P>For an example illustrating how this routine could be implemented        refer to <A HREF = "#IAOpenDocumentExample">Listing 11</A>.</P><p><A HREF = "#top">Back to top</a></p><BR>        <A NAME="closedocsroutine"></A>        <H3><CODE>IACloseDocument</CODE></H3><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>OSStatus IACloseDocument(        IADocRef inDoc);</pre></TD></TR></TABLE></CENTER><BR><BR><P><CODE>inDoc</CODE> - The document reference value createdby the plug-in the <A HREF = "#opendocsroutine"><CODE>IAOpenDocument</CODE></A>call containing state variables or data buffers required for processing thefile.</P><P>result - <CODE>errIANoErr</CODE> if the operation was successful,some other error code if the operation failed.</P><P><CODE>IACloseDocument</CODE> is a routine that must be providedin the plug-in's code fragment.</P><P><CODE>IACloseDocument</CODE> is called after all textual informationrequiredhas been extracted from the document.  In this call, the plug-in shoulddispose of any state variables or buffers that were created specificallyfor the file referenced by the <CODE>inDoc</CODE> parameter.</P>        <P>For an example illustrating how this routine could be implemented        refer to <A HREF = "#IACloseDocumentExample">Listing 12</A>.</P><p><A HREF = "#top">Back to top</a></p><BR>        <A NAME="getnexttextroutine"></A>        <H3><CODE>IAGetNextTextRun</CODE></H3>    <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>OSStatus IAGetNextTextRun(        IADocRef inDoc,        void* buffer,        UInt32* ioSize);</pre></TD></TR></TABLE></CENTER><BR><BR><P><CODE>inDoc</CODE> - The document reference value createdby the plug-in the <A HREF = "#opendocsroutine"><CODE>IAOpenDocument</CODE></A>call containing state variables or data buffers required for processing thefile.</P><P><CODE>buffer</CODE> - a pointer to a block of memory.</P><P><CODE>ioSize</CODE> - a pointer to a 32-bit integer value.  when theroutine is called, this value will equal the number of bytes availablein the memory area pointed to by <CODE>buffer</CODE> parameter.  Aftercopying some text to this memory buffer, the plug-in should set thisvalue to the actual number of bytes copied.</P><P>result - <CODE>errIANoErr</CODE> if the operation was successful,some other error code if the operation failed.  </P><P><CODE>IAGetNextTextRun</CODE> is a routine that must be providedin the plug-in's code fragment.</P><P>The <CODE>IAGetNextTextRun</CODE> routine should copy text from the documentinto the memory buffer pointed to by the <CODE>buffer</CODE> parameteruntil that buffer is full, or the plug-in runs out of text.  If thelanguage encoding changes from one language to another while textis being decoded, the plug-in mark that location in the text streamby returning the result code <CODE>errIAEndOfTextRun</CODE>.</P><P>When the plug-in reaches the end of the text in the file, it shouldreturn a result code of <CODE>noErr</CODE> and it should set<CODE>*ioSize</CODE>to zero indicating there is no more text to be read from the file.</P>        <P>For an example illustrating how this routine could be implemented        refer to <A HREF = "#IAGetNextTextRunExample">Listing 13</A>.</P><p><A HREF = "#top">Back to top</a></p><BR>        <A NAME="getruninforoutine"></A>        <H3><CODE>IAGetTextRunInfo</CODE></H3>  <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>OSStatus IAGetTextRunInfo(        IADocRef inDoc,        char** outEncoding,        char** outLanguage);</pre></TD></TR></TABLE></CENTER><BR><BR><P><CODE>inDoc</CODE> - The document reference value createdby the plug-in the <A HREF = "#opendocsroutine"><CODE>IAOpenDocument</CODE></A>call containing state variables or data buffers required for processing thefile.</P><P><CODE>outEncoding</CODE> - a pointer to a variable to typechar*.  This is an optional parameter, and may be set to <CODE>NULL</CODE>if the caller is not interested in this value.  The plug-in shouldstore a pointer to a string in the variable pointed to by thisparameter that contains the Internet name for the currentcharacter encoding for text being extracted from the file.</P>           <P><CODE>outLanguage</CODE> - a pointer to a variable to typechar*.  This is an optional parameter, and may be set to <CODE>NULL</CODE>if the caller is not interested in this value.  The plug-in shouldstore a pointer to a string in the variable pointed to by thisparameter that contains the language name for text being extractedfrom the file. The language corresponds to the internet standarddefined in ISO-639.</P><P>result - <CODE>errIANoErr</CODE> if the operation was successful,some other error code if the operation failed.</P><P><CODE>IAGetTextRunInfo</CODE> is a routine that must be providedin the plug-in's code fragment.</P><P><CODE>IAGetTextRunInfo</CODE> returns information about the characterencoding and the language of the text for the last buffer returned by<A HREF = "#getnexttextroutine"><CODE>IAGetNextTextRun</CODE></A>.</P><P>Both parameters are optional and may or may not be presentdepending on the caller's requirements.  If a parameter is notrequired, then it will be set to <CODE>NULL</CODE>.</P><P>If the plug-in allocates a pointer to a string and storesthat pointer either in <CODE>*outEncoding</CODE> or in<CODE>*outLanguage</CODE>, then it is the plug-in's responsibility todeallocate that storage.</P><P>If either value is not known, the plug-in may store the value<CODE>NULL</CODE> in either <CODE>*outEncoding</CODE> or in<CODE>*outLanguage</CODE>.This value instructs the caller that the current character encoding orlanguage is not known by the plug-in.</P>        <P>A pointer to a string containing the Internet name for the        character encoding is returned in the <CODE>*outEncoding</CODE>parameter.        Encoding is the internet name for an encoding (i.e., "iso-8859-1",        "x-mac-roman", "euc-jp", ...).</P>        <P>For an example illustrating how this routine could be implemented        refer to <A HREF = "#IAGetTextRunInfoExample">Listing 14</A>.</P><p><A HREF = "#top">Back to top</a></p><BR><A NAME="exampleplugin"></A>         <BR> <H2>An Example Plug-in</H2>         <P>The following annotated example illustrates how to create         a Text Extractor Plug-in for the "text/plain" MIME type.  As the         function of this plug-in is to pass text from the file         to the caller, its implementation is very simple.  Developers         can easily modify this example to extract text from their own         file formats.</P><A NAME="listing5"></A><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>/* File: PlainTextExtractor.c    Text Extractor plug-in example/shell.  */        /* The file IAExtractor.h contains defines and structures           necessary for creating a Text Extractor Plug-in. */#include "IAExtractor.h"        /* This constant is used in the example as a data value           stored in the reference value maintained by the caller           for the plug-in.  It's not necessary to create a plug-in,           but it's useful for illustration. */enum {    kPlainTextExtractorRefType = 'text'};        /* This macro is used or verifying the reference value           remains unchanged in the example. */#define VerifyType(x) ((UInt32)(x)==(UInt32)kPlainTextExtractorRefType)</pre></TD></TR></TABLE></CENTER>          <P align=center><B>Listing 5</B>.  File header &amp; imports for TextExtractor Plug-ins.</p>          <P>The only important aspect of the above is the header file          being included.  Here, the file "IAExtractor.h" containing the          necessary constant and structure definitions is included.</P>        <A NAME="IAPluginInitExample"></A>       <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>/* IAPluginInit example implementation.*/OSStatus <A HREF = "#initroutine">IAPluginInit</a>(        IAPluginInitBlockPtr initBlock,        IAPluginRef* outPluginRef) {        /* validate parameters. */    if (outPluginRef == NULL) return errIAParamErr;        /* initialize the reference value. Plug-ins that           require memory allocation should cache initBlock           info here. */    *outPluginRef = (IAPluginRef)kPlainTextExtractorRefType;        /* Return with no error. */    return errIANoErr;}</pre></TD></TR></TABLE></CENTER>          <P align=center><B>Listing 6</B>.  <A HREF = "#initroutine"><CODE>IAPluginInit</CODE></a> example.</p>          <P>The <A HREF = "#initroutine"><CODE>IAPluginInit</CODE></a> isthe first call          made to the plug-in.  During this call, the plug-in should set          up any variables or tables required.  Also, if the plug-in willrequire          any of the callbacks found in the <A HREF = "#initstruct"><CODE>IAPluginInitBlock</CODE></A>          pointed to by the <CODE>initBlock</CODE> parameter later duringits execution,          then it should save a copy of this pointer.</P>          <p id=p1>          <A HREF = "#top">Back to top</a>          </p>        <A NAME="IAPluginTermExample"></A><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>/* IAPluginTerm example implementation.*/OSStatus <A HREF = "#termroutine">IAPluginTerm</a>(IAPluginRef inPluginRef) {        /* validate parameters */    if (!VerifyType(inPluginRef))        return errIAParamErr;        /* do other tear-down operations here... */    ....        /* Return with no error. */    return errIANoErr;}</pre></TD></TR></TABLE></CENTER>          <P align=center><B>Listing 7</B>.  <A HREF = "#termroutine"><CODE>IAPluginTerm</CODE></a> example.</p>          <P>Normally, the <A HREF = "#termroutine"><CODE>IAPluginTerm</CODE></a> routine will          be used to deallocate any storage allocated by the plug-in, close any          resource files, and other cleanup tasks that need to beperformed.</P>          <p id=p1>          <A HREF = "#top">Back to top</a>          </p>        <A NAME="IAGetExtractorVersionExample"></A><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>/* IAGetExtractorVersion example implementation.*/OSStatus <A HREF = "#versionroutine">IAGetExtractorVersion</a>(        IAPluginRef inPluginRef,        UInt32* outPluginVersion) {        /* validate parameters */    if (!VerifyType(inPluginRef) || !outPluginVersion )        return errIAParamErr;        /* set return value to the interface version           this code was compiled with. */    *outPluginVersion = kIAExtractorCurrentVersion;        /* Return with no error. */    return errIANoErr;}</pre></TD></TR></TABLE></CENTER>          <P align=center><B>Listing 8</B>.  <A HREF = "#versionroutine"><CODE>IAGetExtractorVersion</CODE></a> example.</p>          <P>The value <CODE>kIAExtractorCurrentVersion</CODE> will alwayscontain the current          version for the declarations included in the file<CODE>"IAExtractor.h"</CODE>.  For          the current implementation this value is set to<CODE>kIAExtractorVersion1</CODE>. </P>          <p id=p1>          <A HREF = "#top">Back to top</a>          </p>        <A NAME="IACountSupportedDocTypesExample"></A><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>/* IACountSupportedDocTypes example implementation.*/OSStatus <A HREF = "#countdocsroutine">IACountSupportedDocTypes</a>(        IAPluginRef inPluginRef,        UInt32* outCount) {        /* validate parameters*/    if (!VerifyType(inPluginRef) || ! outCount)        return errIAParamErr;        /* count is max value to be passed to           IAGetIndSupportedDocType as index */    *outCount = 1;        /* Return with no error. */    return errIANoErr;}</pre></TD></TR></TABLE></CENTER>          <P align=center><b>Listing 9</B>.  <A HREF = "#countdocsroutine"><CODE>IACountSupportedDocTypes</CODE></a> example.</p>          <P>In this example, we only support one document type - plaintext documents.  </P>          <p id=p1>          <A HREF = "#top">Back to top</a>          </p>        <A NAME="IAGetIndSupportedDocTypeExample"></A><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>/* IAGetIndSupportedDocType example implementation.*/OSStatus <A HREF = "#getdocsroutine">IAGetIndSupportedDocType</a>(        IAPluginRef inPluginRef,        UInt32 inIndex,        char **outMIMEType) {        /* set up local variables */    static char* supportedDocType = "text/plain";        /* validate parameters */    if (!VerifyType(inPluginRef) || !outMIMEType || inIndex != 1)        return errIAParamErr;        /* set return value */    *outMIMEType = supportedDocType;        /* return successfully */    return errIANoErr;}</pre></TD></TR></TABLE></CENTER>          <P align=center><B>Listing 10</B>.  <A HREF = "#getdocsroutine"><CODE>IAGetIndSupportedDocType</CODE></a> example.</p>          <P>In the above declaration of <A HREF = "#getdocsroutine"><CODE>IAGetIndSupportedDocType</CODE></a>          the MIME type string is stored as a static variable among theplug-in's globals.</P>          <p id=p1>          <A HREF = "#top">Back to top</a>          </p>        <A NAME="IAOpenDocumentExample"></A><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>/* IAOpenDocument example implementation.*/OSStatus <A HREF = "#opendocsroutine">IAOpenDocument</a>(        IAPluginRef inPluginRef,        IADocAccessorPtr inDocAccessor,        IADocRef* outDoc) {        /* local variables */    OSStatus err;        /* verify parameters */    if (!VerifyType(inPluginRef) || !inDocAccessor || !outDoc)        return errIAParamErr;        /* call our opening routine */    err = <A HREF = "#CallIADocumentAccessorOpenListing">CallIADocumentAccessorOpen</a>(inDocAccessor);    if (err != errIANoErr)        return err;        /* IADocRef is defined by plug-in, in our case we are just           reading directly from the accessor so we are defining the           opaque type IADocRef to be an IADocAccessorPtr. */    *outDoc = (IADocRef)inDocAccessor;        /* return successfully */    return errIANoErr;}</pre></TD></TR></TABLE></CENTER>          <P align=center><B>Listing 11</B>.  <A HREF = "#opendocsroutine"><CODE>IAOpenDocument</CODE></a> example.</p>          <P>In the <A HREF = "#opendocsroutine"><CODE>IAOpenDocument</CODE></a> call shown above,the          plug-in calls back through the <A HREF = "#initstruct"><CODE>IAPluginInitBlock</CODE></A>          record pointed to by the <CODE>inDocAccessor</CODE> parameter andbefore          caching a copy of <CODE>inDocAccessor</CODE> in the documentreference          parameter (<CODE>*outDoc</CODE>).  This value is used to refer tothe document          in the next few listings.</P>          <p id=p1>          <A HREF = "#top">Back to top</a>          </p>        <A NAME="IACloseDocumentExample"></A><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>/* IACloseDocument example implementation.*/OSStatus <A HREF = "#closedocsroutine">IACloseDocument</a>(IADocRef inDoc) {        /* local variables */    IADocAccessorPtr    docAccessor;    OSStatus            err;        /* verify parameters */    if (inDoc == NULL)        return errIAParamErr;        /* Cast IADocRef to what we defined it to be in           IAOpenDocument in this case a IADocAccessorPtr */    docAccessor = (IADocAccessorPtr)inDoc;        /* use the callback to close the file */    err = <A HREF = "#CallIADocumentAccessorCloseListing">CallIADocumentAccessorClose</a>(docAccessor);        /* return status of last close */    return err;}</pre></TD></TR></TABLE></CENTER>          <P align=center><B>Listing 12</B>.  <A HREF = "#closedocsroutine"><CODE>IACloseDocument</CODE></a> example.</p>          <P>In the <A HREF = "#closedocsroutine"><CODE>IACloseDocument</CODE></a> call shown above,the          plug-in calls back through the <A HREF = "#initstruct"><CODE>IAPluginInitBlock</CODE></A>          structure to close the file.  The pointer to the <A HREF = "#initstruct"><CODE>IAPluginInitBlock</CODE></A>          structure is coerced from the <CODE>inDoc</CODE> parameter wherea copy was saved during the          <A HREF = "#opendocsroutine"><CODE>IAOpenDocument</CODE></a> callshown in          <A HREF = "#IAOpenDocumentExample">Listing 11</A>.</P>          <p id=p1>          <A HREF = "#top">Back to top</a>          </p>        <A NAME="IAGetNextTextRunExample"></A><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>/* IAGetNextTextRun example implementation. */OSStatus <A HREF = "#getnexttextroutine">IAGetNextTextRun</a>(        IADocRef inDoc,        void* buffer,        UInt32* size) {        /* local variables */    IADocAccessorPtr    docAccessor;    OSStatus            err;        /* verify parameters */    if (!inDoc)        return errIAParamErr;        /* Cast IADocRef to what we defined it to be           in IAOpenDocument (in this case a IADocAccessorPtr). */    docAccessor = (IADocAccessorPtr)inDoc;        /* callback to read from the file. */    err = <A HREF = "#CallIADocumentAccessorReadListing">CallIADocumentAccessorRead</a>(docAccessor, buffer, size);        /* return result o read operation */    return err;}</pre></TD></TR></TABLE></CENTER>          <P align=center><B>Listing 13</B>.  <A HREF = "#getnexttextroutine"><CODE>IAGetNextTextRun</CODE></a> example.</p>          <P>In the <A HREF = "#closedocsroutine"><CODE>IACloseDocument</CODE></a> call shown above,the          plug-in calls back through the <A HREF = "#initstruct"><CODE>IAPluginInitBlock</CODE></A>          structure to read data bytes from the file.  The pointer to the<A HREF = "#initstruct"><CODE>IAPluginInitBlock</CODE></A>          structure is coerced from the <CODE>inDoc</CODE> parameter wherea copy was saved during the          <A HREF = "#opendocsroutine"><CODE>IAOpenDocument</CODE></a> callshown in          <A HREF = "#IAOpenDocumentExample">Listing 11</A>.</P>          <p id=p1>          <A HREF = "#top">Back to top</a>          </p>        <A NAME="IAGetTextRunInfoExample"></A><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>/* IAGetTextRunInfo example implementation.  */OSStatus <A HREF = "#getruninforoutine">IAGetTextRunInfo</a>(        IADocRef inDoc,        char** outEncoding,        char** outLanguage) {        /* we don't know the encoding or language of the file so           set to NULL. */    if (outEncoding != NULL) *outEncoding = NULL;    if (outLanguage != NULL) *outLanguage = NULL;        /* local variables */    return errIANoErr;}</pre></TD></TR></TABLE></CENTER>          <P align=center><B>Listing 14</B>.  <A HREF = "#getruninforoutine">IAGetTextRunInfo</a> example.</p>          <P>In this example, we return <CODE>NULL</CODE>, indicating that both          the text encoding and the language are unknown.</P>          <p id=p1>          <A HREF = "#top">Back to top</a>          </p><A NAME="examplecalls"></A>         <BR> <BR> <H2>Calling a Text Extractor Plug-in from anApplication</H2>         <P>Following is an example of how a client may use a Text Extractor         Plug-in to extract the text of a document.  Applications may use these         routines or some variant of them to call Text Extractor Plug-insto extract         text from virtually any document type.</P>        <P>The steps below show how to set up the plug-in's code fragment,        set up the callback structures, and finally how to call the plug-in        to perform the text extraction.  This example does not show how to        find or determine the correct plug-in for a particular document.</P>        <A NAME="callsetup"></A>        <H3>Setting up a Text Extractor Plug-in</H3>         <P>First, we begin by setting up the plug-in's code fragment for         execution and storing pointers to the routines we want to call         in a structure we will use to access the plug-in.  Listing 15         contains the routines and declarations used to perform this task.</P><A NAME="listing15"></A><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>    /* The following typedefs correspond to the routines    exported by Text Extractor Plug-ins.  In this example,    we use these for calling the plug-in from our code. */typedef OSStatus (*PluginInitCallPtr)(    <A HREF = "#initblockListing">IAPluginInitBlockPtr</A> initBlock,    IAPluginRef* outPluginRef);typedef OSStatus (*PluginTermCallPtr)(        IAPluginRef inPluginRef);typedef OSStatus (*GetExtractorVersionCallPtr)(    IAPluginRef inPluginRef,    UInt32* outPluginVersion);typedef OSStatus (*CountSupportedDocTypesCallPtr)(    IAPluginRef inPluginRef,    UInt32* outCount);typedef OSStatus (*GetIndSupportedDocTypeCallPtr)(    IAPluginRef inPluginRef,    UInt32 inIndex,    char** outMIMEType);typedef OSStatus (*OpenDocumentCallPtr)(    IAPluginRef inPluginRef,    <A HREF = "#docAccListing">IADocAccessorPtr</A> inDoc,    IADocRef* outDoc);typedef OSStatus (*CloseDocumentCallPtr)(IADocRef inDoc);typedef OSStatus (*GetTextRunInfoCallPtr)(IADocRef inDoc,    char** outEncoding,    char** outLanguage);typedef OSStatus (*GetNextTextRunCallPtr)(    IADocRef inDoc,    void* buffer,    UInt32* size);<A NAME="ExtractorRecPtrListing"></A>    /* ExtractorRec is used for storing information about the    plug-in's code fragment itself.  it contains pointers    to the fragment's routines, and the fragment's CFM    connection id number. */typedef struct {    CFragConnectionID connID;    PluginInitCallPtr PluginInit;    PluginTermCallPtr PluginTerm;    GetExtractorVersionCallPtr GetExtractorVersion;    CountSupportedDocTypesCallPtr CountSupportedDocTypes;    GetIndSupportedDocTypeCallPtr GetIndSupportedDocType;    OpenDocumentCallPtr OpenDocument;    CloseDocumentCallPtr CloseDocument;    GetNextTextRunCallPtr  GetNextTextRun;    GetTextRunInfoCallPtr GetTextRunInfo;} ExtractorRec, *ExtractorRecPtr;<A NAME="OpenExtractorListing"></A>    /* OpenExtractor loads the code fragment belonging    to the Text Extractor Plug-in referred to by the file    system specification record referred to by its spec    parameter.  If successful, it returns a pointer to    a structure containing pointers to the plug-in's    routines.  */static OSStatus OpenExtractor(<a href="http://developer.apple.com/documentation/mac/Files/Files-115.html">FSSpec</A> *spec, <A HREF = "#ExtractorRecPtrListing">ExtractorRecPtr</A> *extractor) {    ExtractorRecPtr extr;    Str63 fragName;    Ptr mainAddr;    Str255 errName;    Boolean fragmentExists; /* tracks contents of fragConnID */    CFragConnectionID fragConnID;    CFragSymbolClass symbolClass;    OSStatus err;        /* set up locals to a known state */    extr = NULL;    fragmentExists = false;        /* allocate the storage for saving information about        the plug-in. */    extr = (<A HREF = "#ExtractorRecPtrListing">ExtractorRecPtr</A>) <a href="http://developer.apple.com/documentation/mac/Memory/Memory-75.html">NewPtrClear</A>(sizeof(ExtractorRec));    if (extr == NULL) { err = memFullErr; goto bail; }        /* set up the plug-in's code fragment for use. */    err = <a href="http://developer.apple.com/documentation/mac/PPCSoftware/PPCSoftware-52.html">GetDiskFragment</A>(spec, 0, kCFragGoesToEOF,        fragName, kPrivateCFragCopy,        &amp;fragConnID, &amp;mainAddr, errName);    if (err != noErr) goto bail;    fragmentExists = true;    extr-&gt;connID = fragConnID;        /* save pointers to the routines we want to call.  */    err = <a href="http://developer.apple.com/documentation/mac/PPCSoftware/PPCSoftware-58.html">FindSymbol</A>(fragConnID, "\pIAPluginInit",        (Ptr*) &amp;extr-&gt;PluginInit, &symbolClass);    if (err != noErr) goto bail;    err = <a href="http://developer.apple.com/documentation/mac/PPCSoftware/PPCSoftware-58.html">FindSymbol</A>(fragConnID, "\pIAPluginTerm",        (Ptr*) &amp;extr-&gt;PluginTerm, &symbolClass);    if (err != noErr) goto bail;    err = <a href="http://developer.apple.com/documentation/mac/PPCSoftware/PPCSoftware-58.html">FindSymbol</A>(fragConnID, "\pIAGetExtractorVersion",        (Ptr*) &amp;extr-&gt;GetExtractorVersion, &symbolClass);    if (err != noErr) goto bail;    err = <a href="http://developer.apple.com/documentation/mac/PPCSoftware/PPCSoftware-58.html">FindSymbol</A>(fragConnID, "\pIACountSupportedDocTypes",        (Ptr*) &amp;extr-&gt;CountSupportedDocTypes, &symbolClass);    if (err != noErr) goto bail;    err = <a href="http://developer.apple.com/documentation/mac/PPCSoftware/PPCSoftware-58.html">FindSymbol</A>(fragConnID, "\pIAGetIndSupportedDocType",        (Ptr*) &amp;extr-&gt;GetIndSupportedDocType, &symbolClass);    if (err != noErr) goto bail;    err = <a href="http://developer.apple.com/documentation/mac/PPCSoftware/PPCSoftware-58.html">FindSymbol</A>(fragConnID, "\pIAOpenDocument",        (Ptr*) &amp;extr-&gt;OpenDocument, &symbolClass);    if (err != noErr) goto bail;    err = <a href="http://developer.apple.com/documentation/mac/PPCSoftware/PPCSoftware-58.html">FindSymbol</A>(fragConnID, "\pIACloseDocument",        (Ptr*) &amp;extr-&gt;CloseDocument, &symbolClass);    if (err != noErr) goto bail;    err = <a href="http://developer.apple.com/documentation/mac/PPCSoftware/PPCSoftware-58.html">FindSymbol</A>(fragConnID, "\pIAGetNextTextRun",        (Ptr*) &amp;extr-&gt;GetNextTextRun, &symbolClass);    if (err != noErr) goto bail;    err = <a href="http://developer.apple.com/documentation/mac/PPCSoftware/PPCSoftware-58.html">FindSymbol</A>(fragConnID, "\pIAGetTextRunInfo",        (Ptr*) &amp;extr-&gt;GetTextRunInfo, &symbolClass);    if (err != noErr) goto bail;           /* return successfully */    *extractor = extr;    return noErr;bail:    if (fragmentExists) <a href="http://developer.apple.com/documentation/mac/PPCSoftware/PPCSoftware-56.html">CloseConnection</A>(&amp;fragConnID);    if (extr != NULL) <a href="http://developer.apple.com/documentation/mac/Memory/Memory-79.html">DisposePtr</A>((Ptr) extr);    return err;}<A NAME="CloseExtractorListing"></A>    /* CloseExtractor unloads the plug-in's code fragment and    releases storage allocated when it was opened. */static void CloseExtractor(<A HREF = "#ExtractorRecPtrListing">ExtractorRecPtr</A> extr) {        /* close the code fragment manager connection to        the plug-in's file. */    <a href="http://developer.apple.com/documentation/mac/PPCSoftware/PPCSoftware-56.html">CloseConnection</A>(&amp;extr-&gt;connID);        /* release the memory we were using to track the        plug-in's code fragment. */    <a href="http://developer.apple.com/documentation/mac/Memory/Memory-79.html">DisposePtr</A>((Ptr) extr);}</pre></TD></TR></TABLE></CENTER>               <BR><P align=center><B>Listing 15</B>.  Routines for setting up a Text Extractor Plug-in's code fragment for execution.</p>        <P>The prototypes provided in Listing 15 allow us to call back tothe plug-in.        Pointers to these routines are stored in the <A HREF = "#ExtractorRecPtrListing"><CODE>ExtractorRec</CODE></A>        structure.        </P><p><A HREF = "#top">Back to top</a></p><BR>        <A NAME="iBlockSetup"></A>        <H3>Setting up the <CODE>IAPluginInitBlock</CODE>structure</H3>        <P>Routines for setting up a <A HREF = "#initblockListing"><CODE>IAPluginInitBlock</CODE></A>        structure are provided in Listing 16.  Here, callbacks used by theplug-in        are referenced in the structure saving routine descriptors referring to        them in the structure. </P>        <A NAME="NewIAPluginInitBlockListing"></A>              <A NAME="listing16"></A><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>    /* routines exported in the IAPluginInitBlock record.    Here we have defined our own set of routines that    call through to the Mac OS memory manager. */static void* MyIAAlloc(UInt32 inSize) {    return (void*) <a href="http://developer.apple.com/documentation/mac/Memory/Memory-75.html">NewPtr</A>(inSize);}static void MyIAFreeProc(void* object) {    <a href="http://developer.apple.com/documentation/mac/Memory/Memory-79.html">DisposePtr</A>((Ptr) object);}static UInt8 MyIAIdleProc(void) {    return 0;}<A NAME="NewIAPluginInitBlockListing"></A>    /* NewIAPluginInitBlock allocates a new init block    record containing memory allocation routines    and idle routines that can be called    by a plug-in.   If an error occurs, the function    returns NULL.  */static OSStatus NewIAPluginInitBlock(<A HREF = "#initblockListing">IAPluginInitBlockPtr</A> *iapBlock) {    <A HREF = "#initblockListing">IAPluginInitBlockPtr</A> iBlock;    OSStatus err;    iBlock = NULL;    iBlock = (<A HREF = "#initblockListing">IAPluginInitBlockPtr</A>) <a href="http://developer.apple.com/documentation/mac/Memory/Memory-75.html">NewPtrClear</A>(sizeof(IAPluginInitBlock));    if (iBlock == NULL) { err = memFullErr; goto bail; }    iBlock-&gt;Alloc = NewIAAllocProc(MyIAAlloc);    if (iBlock-&gt;Alloc == NULL) { err = memFullErr; goto bail; }    iBlock-&gt;Free = NewIAFreeProc(MyIAFreeProc);    if (iBlock-&gt;Free == NULL) { err = memFullErr; goto bail; }    iBlock-&gt;Idle = NewIAIdleProc(MyIAIdleProc);    if (iBlock-&gt;Idle == NULL) { err = memFullErr; goto bail; }    *iapBlock = iBlock;    return noErr;bail:    if (iBlock != NULL) {        if (iBlock-&gt;Alloc != NULL)            <a href="http://developer.apple.com/documentation/mac/PPCSoftware/PPCSoftware-33.html">DisposeRoutineDescriptor</A>((UniversalProcPtr) iBlock-&gt;Alloc);        if (iBlock-&gt;Free != NULL)            <a href="http://developer.apple.com/documentation/mac/PPCSoftware/PPCSoftware-33.html">DisposeRoutineDescriptor</A>((UniversalProcPtr) iBlock-&gt;Free);        if (iBlock-&gt;Idle != NULL)            <a href="http://developer.apple.com/documentation/mac/PPCSoftware/PPCSoftware-33.html">DisposeRoutineDescriptor</A>((UniversalProcPtr) iBlock-&gt;Idle);        <a href="http://developer.apple.com/documentation/mac/Memory/Memory-79.html">DisposePtr</A>((Ptr) iBlock);    }    return err;}<A NAME="DisposeIAPluginInitBlockListing"></A>    /* DisposeIAPluginInitBlock releases the memory occupied    by the init block record allocated in NewIAPluginInitBlock.   */static void DisposeIAPluginInitBlock(IAPluginInitBlockPtr iBlock) {    <a href="http://developer.apple.com/documentation/mac/PPCSoftware/PPCSoftware-33.html">DisposeRoutineDescriptor</A>((UniversalProcPtr) iBlock-&gt;Alloc);    <a href="http://developer.apple.com/documentation/mac/PPCSoftware/PPCSoftware-33.html">DisposeRoutineDescriptor</A>((UniversalProcPtr) iBlock-&gt;Free);    <a href="http://developer.apple.com/documentation/mac/PPCSoftware/PPCSoftware-33.html">DisposeRoutineDescriptor</A>((UniversalProcPtr) iBlock-&gt;Idle);    <a href="http://developer.apple.com/documentation/mac/Memory/Memory-79.html">DisposePtr</A>((Ptr) iBlock);}</pre></TD></TR></TABLE></CENTER><P align=center><B>Listing 16</B>.  Routines for allocating and initializing an        <A HREF = "#initblockListing"><CODE>IAPluginInitBlock</CODE></A>structure.</p>        <P>The routines provided in Listing 16 allocate and deallocate the        <A HREF = "#initblockListing"><CODE>IAPluginInitBlock</CODE></A>        structure to use routines that call the Memory Manager.</P>        <p><A HREF = "#top">Back to top</a></p><BR>        <A NAME="docAccSetup"></A><H3>Setting up the <CODE>IADocAccessorRecord</CODE>structure</H3>        <P>The routines and declarations provided in Listing 17 illustrate how        to set up the file access callbacks for a plug-in.  Here, we allocate        the callback structure and another structure for keeping track off the        file itself.</P>        <A NAME="NewIADocAccessorRecListing"></A><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre><A NAME="MyDocRefPtrListing"></A>    /* MyDocumentReference contains information used by    the caller to track the input source being used    by the plug-in.  In this example, we are using a    Mac OS file.  A pointer to this structure will be    passed back to our file io routines. */typedef struct {    <a href="http://developer.apple.com/documentation/mac/Files/Files-115.html">FSSpec</A> spec;  /* a copy of the file specification record */    Boolean docOpen; /* true when document is open */    short refnum; /* file reference number */} MyDocumentReference, *MyDocRefPtr;    /* in this example, we will fill the fields of the    IADocAccessorRecord with routine descriptors referring    to routines that call through to the Mac OS file system.    These routines are defined below.  */static OSStatus MyIADocAccessorOpenProc(            IADocAccessorRef inAccessor) {    <A HREF = "#MyDocRefPtrListing">MyDocRefPtr</A> refptr;    OSErr err;    refptr = (<A HREF = "#MyDocRefPtrListing">MyDocRefPtr</A>) inAccessor;    err = <a href="http://developer.apple.com/documentation/mac/Files/Files-188.html">FSpOpenDF</A>(&amp;refptr-&gt;spec, fsRdPerm, &amp;refptr-&gt;refnum);    if (err == noErr)        refptr-&gt;docOpen = true;    return (OSStatus) err;}static OSStatus MyIADocAccessorCloseProc(            IADocAccessorRef inAccessor) {    <A HREF = "#MyDocRefPtrListing">MyDocRefPtr</A> refptr;    refptr = (<A HREF = "#MyDocRefPtrListing">MyDocRefPtr</A>) inAccessor;    if ( ! refptr-&gt;docOpen)        return errIAParamErr;    <a href="http://developer.apple.com/documentation/mac/Files/Files-129.html">FSClose</A>(refptr-&gt;refnum);    refptr-&gt;docOpen = false;    return errIANoErr;}static OSStatus MyIADocAccessorReadProc(            IADocAccessorRef inAccessor,            void* buffer, UInt32* ioSize) {    <A HREF = "#MyDocRefPtrListing">MyDocRefPtr</A> refptr;    OSErr err;    refptr = (<A HREF = "#MyDocRefPtrListing">MyDocRefPtr</A>) inAccessor;    if ( ! refptr-&gt;docOpen)        return errIAParamErr;        /* read the data */    err = <a href="http://developer.apple.com/documentation/mac/Files/Files-127.html">FSRead</A>(refptr-&gt;refnum, (long *) ioSize, buffer);        /* special case for end of file errors */    if (err == eofErr &amp;&amp; *ioSize != 0) err = noErr;    return (OSStatus) err;}static OSStatus MyIASetDocAccessorReadPositionProc(               IADocAccessorRef inAccessor,               SInt32 inMode, SInt32 inOffset) {    <A HREF = "#MyDocRefPtrListing">MyDocRefPtr</A> refptr;    OSErr err;    refptr = (<A HREF = "#MyDocRefPtrListing">MyDocRefPtr</A>) inAccessor;    if ( ! refptr-&gt;docOpen)        return errIAParamErr;    switch (inMode) {        case kIAFromStartMode:            err = <a href="http://developer.apple.com/documentation/mac/Files/Files-132.html">SetFPos</A>(refptr-&gt;refnum, fsFromStart, inOffset);            break;        case kIAFromCurrMode:            err = <a href="http://developer.apple.com/documentation/mac/Files/Files-132.html">SetFPos</A>(refptr-&gt;refnum, fsFromMark, inOffset);            break;        case kIAFromEndMode:            err = <a href="http://developer.apple.com/documentation/mac/Files/Files-132.html">SetFPos</A>(refptr-&gt;refnum, fsFromLEOF, inOffset);            break;        default:            err = errIAParamErr;            break;    }    return (OSStatus) err;}static OSStatus MyIAGetDocAccessorReadPositionProc(            IADocAccessorRef inAccessor,            SInt32* outPostion) {    <A HREF = "#MyDocRefPtrListing">MyDocRefPtr</A> refptr;    OSErr err;    refptr = (<A HREF = "#MyDocRefPtrListing">MyDocRefPtr</A>) inAccessor;    if ( ! refptr-&gt;docOpen)        return errIAParamErr;    err = <a href="http://developer.apple.com/documentation/mac/Files/Files-131.html">GetFPos</A>(refptr-&gt;refnum, outPostion);    return (OSStatus) err;}static OSStatus MyIAGetDocAccessorEOFProc(            IADocAccessorRef inAccessor, SInt32* outEOF) {    <A HREF = "#MyDocRefPtrListing">MyDocRefPtr</A> refptr;    OSErr err;    refptr = (<A HREF = "#MyDocRefPtrListing">MyDocRefPtr</A>) inAccessor;    if ( ! refptr-&gt;docOpen)        return errIAParamErr;    err = <a href="http://developer.apple.com/documentation/mac/Files/Files-134.html">GetEOF</A>(refptr-&gt;refnum, outEOF);    return (OSStatus) err;}<A NAME="NewIADocAccessorRecListing"></A>    /* NewIADocAccessorRec initializes a IADocAccessorRecord    with routine descriptors referring to routines that    call through to the Mac OS file system.  It stores    a record containing information about the file    in the docAccessor field of the IADocAccessorRecord    record.  If an error occurs, th function returns NULL.  */static OSStatus NewIADocAccessorRec(            <a href="http://developer.apple.com/documentation/mac/Files/Files-115.html">FSSpec</A> *targetFile,            <A HREF = "#docAccListing">IADocAccessorPtr</A> *docAccRec) {    <A HREF = "#docAccListing">IADocAccessorPtr</A> docAcc;    <A HREF = "#MyDocRefPtrListing">MyDocRefPtr</A> refptr;    OSStatus err;    refptr = NULL;    refptr = (<A HREF = "#MyDocRefPtrListing">MyDocRefPtr</A>) NewPtrClear(sizeof(MyDocumentReference));    if (refptr == NULL) goto bail;    refptr-&gt;spec = *targetFile;    refptr-&gt;docOpen = false;    refptr-&gt;refnum = 0;    docAcc = (<A HREF = "#docAccListing">IADocAccessorPtr</A>) <a href="http://developer.apple.com/documentation/mac/Memory/Memory-75.html">NewPtrClear</A>(sizeof(IADocAccessorRecord));    if (docAcc == NULL) { err = memFullErr; goto bail; }    docAcc-&gt;docAccessor = (IADocAccessorRef) refptr;    docAcc-&gt;OpenDoc = NewIADocAccessorOpenProc(MyIADocAccessorOpenProc);    if (docAcc-&gt;OpenDoc == NULL) { err = memFullErr; goto bail; }    docAcc-&gt;CloseDoc = NewIADocAccessorCloseProc(MyIADocAccessorCloseProc);    if (docAcc-&gt;CloseDoc == NULL) { err = memFullErr; goto bail; }    docAcc-&gt;ReadDoc = NewIADocAccessorReadProc(MyIADocAccessorReadProc);    if (docAcc-&gt;ReadDoc == NULL) { err = memFullErr; goto bail; }    docAcc-&gt;SetReadPosition = NewIASetDocAccessorReadPositionProc(        MyIASetDocAccessorReadPositionProc);    if (docAcc-&gt;SetReadPosition == NULL) { err = memFullErr; goto bail; }    docAcc-&gt;GetReadPosition = NewIAGetDocAccessorReadPositionProc(        MyIAGetDocAccessorReadPositionProc);    if (docAcc-&gt;GetReadPosition == NULL) { err = memFullErr; goto bail; }    docAcc-&gt;GetEOF = NewIAGetDocAccessorEOFProc(        MyIAGetDocAccessorEOFProc);    if (docAcc-&gt;GetEOF == NULL) { err = memFullErr; goto bail; }    *docAccRec = docAcc;    return noErr;bail:    if (refptr != NULL) <a href="http://developer.apple.com/documentation/mac/Memory/Memory-79.html">DisposePtr</A>((Ptr) refptr);    if (docAcc != NULL) {        if (docAcc-&gt;OpenDoc != NULL)            <a href="http://developer.apple.com/documentation/mac/PPCSoftware/PPCSoftware-33.html">DisposeRoutineDescriptor</A>((UniversalProcPtr) docAcc-&gt;OpenDoc);        if (docAcc-&gt;CloseDoc != NULL)            <a href="http://developer.apple.com/documentation/mac/PPCSoftware/PPCSoftware-33.html">DisposeRoutineDescriptor</A>((UniversalProcPtr) docAcc-&gt;CloseDoc);        if (docAcc-&gt;ReadDoc != NULL)            <a href="http://developer.apple.com/documentation/mac/PPCSoftware/PPCSoftware-33.html">DisposeRoutineDescriptor</A>((UniversalProcPtr) docAcc-&gt;ReadDoc);        if (docAcc-&gt;SetReadPosition != NULL)            <a href="http://developer.apple.com/documentation/mac/PPCSoftware/PPCSoftware-33.html">DisposeRoutineDescriptor</A>((UniversalProcPtr) docAcc-&gt;SetReadPosition);        if (docAcc-&gt;GetReadPosition != NULL)            <a href="http://developer.apple.com/documentation/mac/PPCSoftware/PPCSoftware-33.html">DisposeRoutineDescriptor</A>((UniversalProcPtr) docAcc-&gt;GetReadPosition);        if (docAcc-&gt;GetEOF != NULL)            <a href="http://developer.apple.com/documentation/mac/PPCSoftware/PPCSoftware-33.html">DisposeRoutineDescriptor</A>((UniversalProcPtr) docAcc-&gt;GetEOF);        <a href="http://developer.apple.com/documentation/mac/Memory/Memory-79.html">DisposePtr</A>((Ptr)docAcc);    }    return err;}    /* DisposeIADocAccessorRec releases a IADocAccessorRecord    allocated by NewIADocAccessorRec.  All o the sub    fields are deallocated, and, if the file is open,    it is closed before the structure is deallocated. */static void DisposeIADocAccessorRec(IADocAccessorPtr docAcc) {    <A HREF = "#MyDocRefPtrListing">MyDocRefPtr</A> refptr;        /* destroy the document reference */    refptr = (<A HREF = "#MyDocRefPtrListing">MyDocRefPtr</A>) docAcc-&gt;docAccessor;        /* make sure the file is closed - incase we're aborting */    if (refptr-&gt;docOpen) <a href="http://developer.apple.com/documentation/mac/Files/Files-129.html">FSClose</A>(refptr-&gt;refnum);    <a href="http://developer.apple.com/documentation/mac/Memory/Memory-79.html">DisposePtr</A>((Ptr) refptr);        /* release the accessor structure */    <a href="http://developer.apple.com/documentation/mac/PPCSoftware/PPCSoftware-33.html">DisposeRoutineDescriptor</A>((UniversalProcPtr) docAcc-&gt;OpenDoc);    <a href="http://developer.apple.com/documentation/mac/PPCSoftware/PPCSoftware-33.html">DisposeRoutineDescriptor</A>((UniversalProcPtr) docAcc-&gt;CloseDoc);    <a href="http://developer.apple.com/documentation/mac/PPCSoftware/PPCSoftware-33.html">DisposeRoutineDescriptor</A>((UniversalProcPtr) docAcc-&gt;ReadDoc);    <a href="http://developer.apple.com/documentation/mac/PPCSoftware/PPCSoftware-33.html">DisposeRoutineDescriptor</A>((UniversalProcPtr) docAcc-&gt;SetReadPosition);    <a href="http://developer.apple.com/documentation/mac/PPCSoftware/PPCSoftware-33.html">DisposeRoutineDescriptor</A>((UniversalProcPtr) docAcc-&gt;GetReadPosition);    <a href="http://developer.apple.com/documentation/mac/PPCSoftware/PPCSoftware-33.html">DisposeRoutineDescriptor</A>((UniversalProcPtr) docAcc-&gt;GetEOF);    <a href="http://developer.apple.com/documentation/mac/Memory/Memory-79.html">DisposePtr</A>((Ptr) docAcc);}</pre></TD></TR></TABLE></CENTER>        <BR><P align=center><B>Listing 17</B>.  Routines for allocating and initializing a        <A HREF = "#docAccListing"><CODE>IADocAccessorRecord</CODE></A>.</p>        <P>In Listing 17, we use File Manager calls to access the file.For tracking information        used by the File Manager, we store a pointer to a private structurecontaining that        information in the <CODE>docAccessor</CODE> field of the <A HREF = "#docAccListing"><CODE>IADocAccessorRecord</CODE></A>.</P><p><A HREF = "#top">Back to top</a></p><BR>        <A NAME="extCalls"></A>        <H3>Calling a Text Extractor Plug-in</H3>        <P>The routine provided in Listing 18 calls the Text Extractor Plug-in        to gather textual information from a file.  The text gathered from the        file is passed back to the caller through a routine the caller provides        as a parameter.</P>       <A NAME="listing18"></A><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>    /* kETBufferSize determines the size of the buffer    allocated for retrieving chunks of text. */#define kETBufferSize (1024*1)    /* TextSinkProc is a call back routine provided by the    caller.  Text will be passed to this routine as it is    extracted from the file. */typedef OSErr (*TextSinkProc)(void* text, long length, long refcon);    /* ExtractTextFromFile calls the Text Extractor Plug-in    referred to by *theExtractor to extract text from the    file referred to by *targetFile.  While extracting text,    the text will be sent to the TextSinkProc provided by    the textsink parameter. refcon is a value passed through    to the TextSinkProc in its refcon parameter.  */static OSErr ExtractTextFromFile(            <a href="http://developer.apple.com/documentation/mac/Files/Files-115.html">FSSpec</A> *targetFile,            <a href="http://developer.apple.com/documentation/mac/Files/Files-115.html">FSSpec</A> *theExtractor,            TextSinkProc textsink, long refcon) {    <A HREF = "#ExtractorRecPtrListing">ExtractorRecPtr</A> extractor;    <A HREF = "#initblockListing">IAPluginInitBlockPtr</A> initblock;    <A HREF = "#docAccListing">IADocAccessorPtr</A> accRec;    UInt32 pluginVersion;    Boolean exInited, docOpen;    IADocRef docRef;    Ptr etBuffer;    UInt32 bytecount;    OSStatus err;    IAPluginRef pluginRef;        /* set up locals to a known state */    extractor = NULL;    initblock = NULL;    accRec = NULL;    exInited = false;    docOpen = false;    etBuffer = NULL;        /* initialize the plug-in */    err = <A HREF = "#OpenExtractorListing">OpenExtractor</A>(theExtractor, &extractor);    if (err != noErr) goto bail;        /* initialize the callbacks used by the        plug-in for basic memory tasks.  */    err = <A HREF = "#NewIAPluginInitBlockListing">NewIAPluginInitBlock</A>(&initblock);    if (err != noErr) goto bail;        /* call the plug-in's initialization routine.  */    err = extractor-&gt;PluginInit(initblock, &amp;pluginRef);    if (err != noErr) goto bail;    exInited = true;        /* query the plug-in to find out if we're using        the interface we're using is in sync with the        interface it was built to use. */    err = extractor-&gt;GetExtractorVersion(pluginRef, &amp;pluginVersion);    if (err != noErr) goto bail;    if (pluginVersion != kIAExtractorVersion1)        { err = errIAParamErr; goto bail; }        /* initialize the callbacks used by the        plug-in for file input with our document.  */    err = <A HREF = "#NewIADocAccessorRecListing">NewIADocAccessorRec</A>(targetFile, &amp;accRec);    if (err != noErr) goto bail;        /* allocate a memory buffer for reading */    etBuffer = <a href="http://developer.apple.com/documentation/mac/Memory/Memory-75.html">NewPtr</A>(kETBufferSize);    if (etBuffer == NULL) { err = memFullErr; goto bail; }        /* call the plug-in and ask it to open the document        for input. */    err = extractor-&gt;OpenDocument(pluginRef,  accRec, &amp;docRef);    if (err != noErr) goto bail;    docOpen = true;        /* Here, we loop until the plug-in returns no more bytes */    while (true) {            /* attempt to fill the entire buffer with text. */        bytecount = kETBufferSize;        err = extractor-&gt;GetNextTextRun(docRef, etBuffer, &amp;bytecount);            /* if some other error occurs, such as eofErr...            we exit... */        if (err != noErr) goto bail;            /* errIAEndOfTextRun is returned when the language            encoding changes.  in this case, we do nothing,            but in some cases we may wish to do some additional            processing. */        if (err == errIAEndOfTextRun) {            /* we don't check the bytecount            here because conceivably errIAEndOfTextRun could            be returned with a zero sized buffer simply to            indicate the beginning of a new            character encoding range in cases where the            last call read all of the characters from the            last encoding run. */            /* normal termination occurs when zero bytes are            returned. */        } else if (bytecount == 0)            break;            /* at this point, we have a chunk of text from the            from the document.  Here, we pass it back to the            caller's sink. */        err = textsink(etBuffer, bytecount, refcon);        if (err != noErr) goto bail;    }        /* at this point, all of the text in the document        has been read.  Now, we close down the document        by asking the plug-in to close, disposing of the        memory buffer, and then disposing the file input        callback structure. DisposeIADocAccessorRec is        defined in <A HREF = "#DisposeIADocAccessorRecListing">Listing 17</A>. */    extractor-&gt;CloseDocument(docRef);    docOpen = false;    <a href="http://developer.apple.com/documentation/mac/Memory/Memory-79.html">DisposePtr</A>(etBuffer);    etBuffer = NULL;    <A HREF = "#DisposeIADocAccessorRecListing">DisposeIADocAccessorRec</A>(accRec);    accRec = NULL;        /* After closing the document, the plug-in        is released.  This is done by calling the plug-in's        termination procedure, releasing the memory allocation        callbacks (DisposeIAPluginInitBlock is defined in        <A HREF = "#DisposeIAPluginInitBlockListing">Listing 16</A>) and then releasing the plug-in's        code fragment (CloseExtractor is defined in        <A HREF = "#CloseExtractorListing">Listing 15</A>). */    extractor-&gt;PluginTerm(pluginRef);    exInited = false;    <A HREF = "#DisposeIAPluginInitBlockListing">DisposeIAPluginInitBlock</A>(initblock);    initblock = NULL;    <A HREF = "#CloseExtractorListing">CloseExtractor</A>(extractor);    extractor = NULL;        /* return success */    return noErr;bail:        /* error handling code.  note, ordering of the        recovery statements is important. */    if (docOpen) extractor-&gt;CloseDocument(docRef);    if (etBuffer != NULL) <a href="http://developer.apple.com/documentation/mac/Memory/Memory-79.html">DisposePtr</A>(etBuffer);    if (accRec != NULL) <A HREF = "#DisposeIADocAccessorRecListing">DisposeIADocAccessorRec</A>(accRec);    if (exInited) extractor-&gt;PluginTerm(pluginRef);    if (initblock != NULL) <A HREF = "#DisposeIAPluginInitBlockListing">DisposeIAPluginInitBlock</A>(initblock);    if (extractor != NULL) <A HREF = "#CloseExtractorListing">CloseExtractor</A>(extractor);    return err;}</pre></TD></TR></TABLE></CENTER>          <P align=center><B>Listing 18</B>.  Sample routine for that calls a TextExtractor Plug-in.</p>          <P>The routine provided in Listing 18 performs the actual textextraction by calling          the plug-in's routines directly.  In this example, no attentionis paid to the language          encoding or character encoding, but this example could easily bemodified to return          this information.  This routine uses structures and callsroutines defined in          <A HREF = "#listing15">Listing 15</A>, <A HREF = "#listing16">Listing16</A>,          and <A HREF = "#NewIADocAccessorRecListing">Listing 17</A>.</P><p><A HREF = "#top">Back to top</a></p><BR>         <A NAME="listings"></A>         <H2>Index of Code Listings</H2>         <P>The following code listings are provided in this document.Listings 5         through 14 define the content of the sample plug-in, and listings15 through         18 illustrate how to call a plug-in from an application.</P>         <UL>            <LI><A HREF = "#HTMLListing"><B>Listing 1</B></A>. A sample HTMLfile.</li>            <LI><A HREF = "#resourceListing"><B>Listing 2</B></A>. A sample            <CODE>'mimp'</CODE> resource for PDF files.</li>            <LI><A HREF = "#initblockListing"><B>Listing 3</B></A>.Declaration of            the <CODE>IAPluginInitBlock</CODE> structure and prototypesthat can            be used for calling the routines referenced in the structure.</li>            <LI><A HREF = "#docAccListing"><B>Listing 4</B></A>. Declaration of            the <CODE>IADocAccessorRecord</CODE> structure and prototypes that            can be used for calling the routines referenced in the structure.</li>            <LI><A HREF = "#listing5"><B>Listing 5</B></A>. File header &amp;imports for Text Extractor Plug-ins.</li>            <LI><A HREF = "#IAPluginInitExample"><B>Listing 6</B></A>. <A HREF = "#initroutine"><CODE>IAPluginInit</CODE></a> example.</li>            <LI><A HREF = "#IAPluginTermExample"><B>Listing 7</B></A>. <A HREF = "#termroutine"><CODE>IAPluginTerm</CODE></a> example.</li>            <LI><A HREF = "#IAGetExtractorVersionExample"><B>Listing8</B></A>. <A HREF = "#versionroutine"><CODE>IAGetExtractorVersion</CODE></a>example.</li>            <LI><A HREF = "#IACountSupportedDocTypesExample"><B>Listing9</B></A>. <A HREF = "#countdocsroutine"><CODE>IACountSupportedDocTypes</CODE></a> example.</li>            <LI><A HREF = "#IAGetIndSupportedDocTypeExample"><B>Listing10</B></A>. <A HREF = "#getdocsroutine"><CODE>IAGetIndSupportedDocType</CODE></a> example.</li>            <LI><A HREF = "#IAOpenDocumentExample"><B>Listing 11</B></A>. <A HREF = "#opendocsroutine"><CODE>IAOpenDocument</CODE></a> example.</li>            <LI><A HREF = "#IACloseDocumentExample"><B>Listing 12</B></A>. <A HREF = "#closedocsroutine"><CODE>IACloseDocument</CODE></a> example.</li>            <LI><A HREF = "#IAGetNextTextRunExample"><B>Listing 13</B></A>.<A HREF = "#getnexttextroutine"><CODE>IAGetNextTextRun</CODE></a> example.</li>            <LI><A HREF = "#IAGetTextRunInfoExample"><B>Listing 14</B></A>.<A HREF = "#getruninforoutine"><CODE>IAGetTextRunInfo</CODE></a> example.</li>            <LI><A HREF = "#listing15"><B>Listing 15</B></A>. Routines forsetting up a Text Extractor            Plug-in's code fragment for execution.</li>            <LI><A HREF = "#listing16"><B>Listing 16</B></A>. Routines forallocating and initializing an            <A HREF = "#initblockListing"><CODE>IAPluginInitBlock</CODE></A>structure.</li>            <LI><A HREF = "#NewIADocAccessorRecListing"><B>Listing17</B></A>. Routines for allocating and initializing a            <A HREF = "#docAccListing"><CODE>IADocAccessorRecord</CODE></A>.</li>            <LI><A HREF = "#listing18"><B>Listing 18</B></A>. Sample routinefor that calls a Text Extractor Plug-in.</li>         </UL><p><A HREF = "#top">Back to top</a></p><BR><BR> <BR><A NAME="references"></A><H2>References</H2>            <p>Technote <A HREF = "tn1141.html">TN1141, "Extending andControlling Sherlock."</A></p>            <p>Technote <A HREF = "tn1180.html">TN1180, "Sherlock's Find ByContent Library."</A></p>            <p><A HREF = "http://www.cis.ohio-state.edu/htbin/rfc/rfc1521.html">RFC1521,                "MIME (Multipurpose Internet MailExtensions) Part One: Mechanisms for Specifying and Describing the Formatof Internet Message Bodies."</A> N. Borenstein, N. Freed. September1993.</p><p><A HREF = "#top">Back to top</a> </p><BR><A NAME="Downloads"></A> <h2>Downloadables</h2><center><TABLE BORDER=0 CELLPADDING=3 WIDTH="600"> <TR> <td width=50 align=left>   <P ALIGN=center><img src="images/acrobatsmall.gif" align=middle alt="Acrobat" width=22 height=23></P></TD><td align="left">   <p>Acrobat version of this Note (124K).</P></TD><td width=60 align=left>   <p><A HREF="pdf/tn1181.pdf">Download</A></P></TD>  </TR> </table></center><BR><BR><BR><P><A HREF="#top">Back to top</A></P></TD></TR></TABLE></CENTER><!-- end_content --><!-- begin_footer_information -->	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/technotes/tn/tn1181.html%3Fid%3DDTS10003020-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/technotes/tn/tn1181.html%3Fid%3DDTS10003020-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/technotes/tn/tn1181.html%3Fid%3DDTS10003020-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>
<!--#include virtual="/includes/footer"--><!-- end_footer_information --></BODY></HTML>