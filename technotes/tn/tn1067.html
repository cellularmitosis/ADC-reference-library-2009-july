<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"			"http://www.w3.org/TR/REC-html40/loose.dtd"><HTML><!-- Template 03-24-01 --><HEAD><LINK REL="stylesheet" HREF="../../adcstyle.css" TYPE="text/css"><LINK REL="stylesheet" HREF="../../style.css" TYPE="text/css"><title>Technical Note TN1067: Traditional Device Drivers: Sync or Swim</title>    <meta name="keywords" content="Mac OS 8 traditonal device drivers deadlock asynchronous calling">    <meta name="Description" content="Technical Note TN1067: This Technical Note  discusses oneof the dangers of writing a traditional Mac OS device driver,namely, the possibility of deadlock when calling anotherdevice driver synchronously from a device driver. It demonstratesseveral ways this deadlock can occur, and then goes on todescribe how to avoid the possibility of deadlock.">                                       <meta name="categories" content="Devices"><meta name="week-posted" content="Aug 26, 1996 - Sep 6, 1996"><LINK REL="stylesheet" HREF="../../css/adcstyle.css" TYPE="text/css"><script language="JavaScript" type="text/javascript" src="../../js/adc.js"></script></HEAD><BODY BGCOLOR="#FFFFFF"><a name="//apple_ref/doc/uid/DTS10002908" title="Traditional Device Drivers: Sync or Swim"></a><A NAME="top"></A><!-- begin_header_information --><!--#include virtual="/adcnavbar" --><p><a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../technicalnotes/index.html">Technical Notes</a> &gt; <a href="../../technicalnotes/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../technicalnotes/LegacyTechnologies/idxHardwareDrivers-date.html">Hardware & Drivers</a> &gt; </p><div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="../../referencelibrary/HardwareDrivers/index.html" target="_blank">Reference Library > Hardware & Drivers</a></li>
	</ul>
</div>




</div></div></div><!-- end_header_information --><!-- bottom_of_header_marker_comment --><!-- top_of_titles_marker_comment --><CENTER><table width="600" cellpadding="0" cellspacing="0" border="0">
<tr><td align="left" scope="row">
<h1>
<div id="pagehead">Technical Note TN1067</div>
<div id="pageheadsub">Traditional Device Drivers: Sync or Swim</div>
</h1>
</td></tr></table></CENTER><!-- bottom_of_titles_marker_comment --><CENTER><TABLE BORDER=0 CELLSPACING=1 WIDTH=600><TR><td align="left"> <!-- begin_header_box --> <table width="600" cellpadding="0" cellspacing="0" border="0">	<tr>		<td width=300 valign="top" align=left scope="row">			<table border="0" width="300" cellpadding="0" cellspacing="0">			<tr>                        <td width=300 align=left> <img src="images/tnmenutop.gif" alt="" align="bottom" width=300 height=7></td>				</tr>				<tr bgcolor="#e6e6e6">					<td background="images/tnmenubody.gif" width=300 align=left>						<span id="menutitle">							CONTENTS                             <br>                            <br>						</span>					</td>				</tr>				<tr bgcolor="#e6e6e6">					<td background="images/tnmenubody.gif" width=300 align=left><!-- begin_toc --><p id="menutext"><a href="#Section1">Two Rules That Govern Device Drivers</a><br><br><a href="#Section2">Proof by Example</a><br><br><a href="#Section3">Avoiding Deadlock</a><br><br><a href="#Section4">Exceptions That Prove the Rule</a><br><br><A HREF = "#Summary">Summary</a><br><br><A HREF = "#Changes">Change History</a><br><br><A HREF="#Downloads">Downloadables</A></p>                  <!-- end_toc --> 								</td>				</tr>				<tr>					<td width=300 align=left scope="row">						<img src="images/tnmenubottom.gif" alt="" width=300 height=16>					</td>				</tr>			</table>		</td>		<td width=300 valign="top" align=left>			<!-- begin_intro_text -->            <P id = "introtext">As with any software system, the Mac OS works fine just as long as everybodyplays by the rules. For general Toolbox operations, these rules are fairly easyto understand. However, traditional Mac OS device drivers (DRVRs), by theirvery nature, are complicated programs, and the rules that govern their behaviorare harder to understand.</p><P id = "introtext">This Technote discusses one of the dangers of writing a traditional Mac OSdevice driver, namely, the possibility of <b>deadlock</b> when calling anotherdevice driver synchronously from a device driver. It demonstrates several waysthis deadlock can occur, and then goes on to describe how to avoid thepossibility of deadlock.</p><P id = "introtext">The Note is intended for developers writing traditional Mac OS device drivers,especially drivers which call other device drivers, and for those with a morbidcuriosity about the internals of the traditional Mac OS.</p><!-- end_intro_text --><!-- begin_date --><h3>&nbsp;Updated: [Sep 01 1996]</h3><!-- end_date -->                </TD>             </TR>          </TABLE>          <!-- end_header_box --> <BR><BR><hr width=500 align=center>          <BR><BR> <!-- begin_content --><a name="Section1"></a><H2>Two Rules That Govern Device Drivers</H2><p>There are two important rules about writing traditional Macintosh devicedrivers.</p><H3>Rule #1</H3><P><i>If your device driver can be called asynchronously and you call anotherdevice driver, you must call it asynchronously.</i></p><P>If you don't follow <b>Rule #1</b>, you run the risk of deadlocking thesystem, with catastrophic results for the user.</p><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR> According to Andrew S. Tanenbaum, in <i>Modern Operating Systems</i>, "Aset of processes is deadlocked if each process in the set is waiting for anevent that only another process in the set can cause." For example, if I can'tfinish this Technote until I have a reliable version of your disk driver, andyou can't make your disk driver reliable until you have read the finishedTechnote, we are deadlocked. Humans are good at avoiding and recovering fromdeadlocks, but computers are not.</P></TD></TR></TABLE></CENTER><BR> <H3>Rule #2</H3><P><i>If your device driver can be called asynchronously, always operate as if youare being called asynchronously</i>.</p><P>In other words, you should not test to see whether this operation issynchronous or asynchronous, and do different things in each case.</p><P>If you don't follow <b>Rule #2</b>, the system might trick you into doingillegal things at interrupt time, such as breaking <b>Rule #1</b>.</p><a name="Section2"></a><H2>Proof by Example</H2><P>This section describes two examples of how breaking the rules will cause thesystem to deadlock. Both examples rely on the following scenario: </p><P><i>You have written a block device driver that fetches disk blocks over thenetwork using the "classic" AppleTalk device drivers. When you use the Finderto copy files to the disk image, the system will sometimes deadlock in aroutine called </i>vSyncWait<i>. This is much more common when running OpenTransport than when running classic networking.</i></p><P>I chose this example because recently I've helped a number of Macintoshdevelopers who are writing such drivers. These people broke the rules andeverything seemed to work fine. Unfortunately, Open Transport significantlychanged the way AppleTalk is implemented, and the authors suddenly discoveredthe penalty of breaking the rules: unpredictable system deadlocks.</p><P>When the Finder copies a file, it makes a sequence of chained <code>ioCompletion</code>routines (see "Asynchronous Routines on the Macintosh," <i>develop</i> 13) thatreads chunks of data from the source volume and writes them to the destinationvolume. The Finder actually makes File Manager calls but, in cases like this,the File Manager effectively passes these calls straight through to theappropriate block device driver.</p><p>The next two sections show how your block device driver can deadlock the systemby not following these rules.</p><H3>An Example of Breaking Rule #1</H3><p>Imagine that your device driver breaks <b>Rule #1</b>, i.e., it calls anotherdevice driver synchronously. The following is a step-by-step description of howthis leads to system deadlock: </p><ol><li>The Finder calls <code>PBReadAsync</code> to read a chunk of the file from the localhard disk. This invokes the File Manager, which invokes the device driver,which invokes the SCSI Manager, which invokes the SCSI hardware.<BR><BR></li><li>The SCSI operation completes. The SCSI hardware interrupts the CPU toinform it of this. The interrupt service routine calls the <code>ioCompletion</code> for theSCSI device driver, which calls the <code>ioCompletion</code> routine for the File Manager,which calls the <code>ioCompletion</code> for the Finder. Because of the nature of theinterrupt service routine, interrupts are still disabled at this point.<BR><BR></li><li>The Finder's <code>ioCompletion</code> routine calls <code>PBWriteAsync</code> to write the data tothe volume mounted on you block device driver. This invokes the File Manager,which invokes your device driver.<BR><BR></li><li>Your device driver calls the AppleTalk device driver synchronously. This isRequest A. Unfortunately, the AppleTalk device driver is busy fielding anotherrequest (Request B) from a completely independent process, and queues yourrequest waiting for Request B to complete. Your code sits inside the DeviceManager's <code>vSyncWait</code> loop, waiting for the Request B to complete.<BR><BR></li><li>The prior networking operation (Request B) completes. The networkinghardware attempts to interrupt the CPU to let it know that Request B hascompleted. Unfortunately the CPU is sitting inside <code>vSyncWait</code> with interruptsdisabled -- they were disabled by the SCSI hardware when it interrupted the CPUin step 2 -- and doesn't notice the interrupt from the networking hardware. Thesystem is deadlocked.<BR><BR></li></ol><p>The basic problem here is that traditional Mac OS device drivers are singlethreaded, i.e., they can only handle a single request at a time. If you make asecond request and the driver is busy and you don't give the driver the abilityto complete the request, you deadlock.</p><H3>An Example of Breaking Rule #2</H3><p>Imagine that your device driver breaks <b>Rule #2</b>, i.e., it tests whetherit's being called synchronously or asynchronously, and behaves differently ineach case. The following is a step-by-step description of how this leads tosystem deadlock:</p> <ol><li>The Finder calls <code>PBWriteAsync</code> to write a chunk of data to your block devicedriver (Request A). You recognize this request is asynchronous (by testing<code>ioTrap</code> in the ParamBlock), send it to AppleTalk asynchronously, and then returnto the Finder.<BR><BR></li><li>Another process calls <code>PBWriteSync</code> to write some data to your driver(Request B). Because your driver is currently busy, this request gets queued inyour driver's queue.<BR><BR></li><li>The AppleTalk driver calls your <code>ioCompletion</code> routine to signify that yourrequest is done. In response to this you call <code>jIODone</code>. <code>jIODone</code> completesRequest A (and calls the Finder's ioCompletion routine) and then checks yourdriver's queue for any more pending requests. It notices that Request B ispending, and it calls your device driver's Prime to start that Request B.Remember that you are still running at interrupt time.<BR><BR></li><li>Your device driver is called to start Request B. It tests <code>ioTrap</code>, noticesthat the Request B is synchronous, and so calls AppleTalk synchronously. Atthis point your driver is calling a device driver synchronously at interrupttime, and you can deadlock the system as described in the previous section.<BR><BR></li></ol><p>The basic problem here is that the ioTrap word in a <code>ParamBlock</code> only denoteswhether the request was made synchronously, not whether the request is beingexecuted at non-interrupt time.</p><a name="Section3"></a><H2>Avoiding Deadlock</H2><p>The only good way to avoid the problems described in the previous section is toissue any device driver calls you make inside your device driver<i>asynchronously</i>.</p><p>A traditional Mac OS device driver (<b>DRVR A</b>) that calls another driver(<b>DRVR</b> <b>B</b>) should operate in the following fashion: </p><ol><li> Accept a request (<b>Request A</b>).<BR><BR></li><li> Ignore whether the request is synchronous or asynchronous.<BR><BR></li><li> Asynchronously issue the sub-request (<b>Request B1</b>) to DRVR B.<BR><BR></li><li> Return to the caller.<BR><BR></li></ol><p>The sub-request should have an <code>ioCompletion</code> routine. The code for thatioCompletion routine should do the following:</p> <ol><li> If this is the last operation we need to do to fulfil <b>Request A</b>,jump to <code>jIODone</code>.<BR><BR></li><li> Otherwise, asynchronously issue another sub-request (<b>Request Bn</b>) toDRVR B with the same <code>ioCompletion</code> routine, and then return to the caller.<BR><BR></li></ol><p>Structuring your device driver in this fashion turns your device driver into astate machine. If, for example, you have to issue two sub-requests for eachrequest you receive, your device driver ends up with two states: Request B1,and Request B2. Your completion routine would go: </p><ol><li>Copy the data from the completed sub-request into the main request's resultbuffer.<BR><BR></li><li>If the state is Request B2, complete the initial request by jumping tojIODone.<BR><BR></li><li>Otherwise, increment the state, issue the next request asynchronously, andreturn to the caller.<BR><BR></li></ol><P>This structure works regardless of whether your driver (DRVR A) is called synchronously orasynchronously, and regardless of whether the driver you are calling (DRVR B)is synchronous or asynchronous.</p><P>Figures 1, 2, 3 and 4 illustrate these four cases.</p><P align=center><img src="images/tn1067_003.gif" alt="" width=510 height=229><BR><b>Figure 1</b>. A driver called synchronously, calling a synchronous driver. </p><P align=center><img src="images/tn1067_004.gif" alt="" width=507 height=230><br><b>Figure 2</b>. A driver called asynchronously, calling a synchronousdriver.</p><P align=center><img src="images/tn1067_005.gif" alt="" width=364 height=431><br><b>Figure 3</b>. A driver called synchronously, calling an asynchronous driver.</p><p align=center><img src="images/tn1067_006.gif" alt="" width=359 height=410><br><b>Figure 4</b>. A driver called asynchronously, calling an asynchronousdriver</p><p>You might think to simplify your life by detecting whether you are being calledsynchronously or asynchronously, and changing your operation in each case.While it sounds like a neat idea in theory, it is a very bad idea in practice,for two reasons: </p><ol><li>You have to handle the asynchronous case properly anyway, and if you handlethe asynchronous case properly, the synchronous case just works. There's nopoint in writing twice as much code when half as much would do.<BR><BR></li><li>You will break <b>Rule #2</b> and leave yourself open to deadlocks.<BR><BR></li></ol><a name="Section4"></a><H2>Exceptions That Prove the Rule</H2><p>The expression "The Exception Proves the Rule" actually means that theexception <i>tests</i> the rule. For <b>Rules #1 </b>and<b> #2</b>, there aretwo significant exceptions that we must explore in order to understand thistopic fully.</p><H3>Drivers That Aren't Called Asynchronously: Exception #1</H3><P>Many people use traditional Mac OS device drivers for things that don't fit themodel. The obvious example here are desk accessories, but older programs oftenuse device drivers as a shared library mechanism. Drivers used in this way arenot really part of the I/O system, and generally aren't called asynchronously.This is the reason for the "If you can be called asynchronously" clause in therules.</p><p>Note that using device drivers as a shared library mechanism is now stronglydiscouraged. The Macintosh has a number of real shared library mechanisms thatshould meet your needs.</p><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR> If you use a DRVR as a pseudo-shared library, you should have your clientissue immediate calls to your driver (e.g., <code>PBControlImmed</code>). These calls aresent through to your driver directly, and are not queued in any way.</P></TD></TR></TABLE></CENTER><BR>      <H3>Classic SCSI Manager: Exception #2</H3><P>One case that seems to contradict <b>Rule #1</b> is the relationship betweenthe File Manager and "classic" SCSI device drivers. The "classic" epithetrefers to SCSI device drivers that were written prior to SCSI Manager 4.3.These drivers were necessarily synchronous because the SCSI Manager did notsupport asynchronous operations.</p><P>So how is it possible to call the File Manager, which in turn calls the devicedriver, which calls the SCSI Manager, at interrupt time, even though the SCSIManager is necessarily synchronous?</p><p>The answer is simple: the File Manager contains specific code to support this.When you issue an asynchronous request, the File Manager checks whether theSCSI hardware is already in use. If it is, the File Manager defers theoperation of the command until the SCSI hardware is free again. This getsaround the potential deadlock, but it contradicts the spirit of <b>Rule #1</b>.</p><p>Note that the File Manager is only able to defer the request because therequest is asynchronous. If you called to File Manager synchronously, you woulddeadlock.</p><a name="Summary"></a><H2>Summary</H2><p>Most Macintosh programmers want to play by the rules. Unfortunately, in thecase of traditional Mac OS device drivers, the rules are poorly documented andsometimes hard to understand. This Technote explains two important rules fortraditional Mac OS device drivers. If you follow them, you will make the systemas a whole more reliable.</p><A NAME="References"></a><H2>References</h2><p><a href="http://developer.apple.com/dev/techsupport/develop/"><i>develop 13</i></a>, Asynchronous Routines on the Macintosh,  by Jim Luther</p><p><i>Modern Operating Systems</i>, by Andrew S. Tanenbaum, Prentice-Hall,1992, ISBN 0-13-588187-0</p>         <P><A NAME=Downloads></A></P>                  <H2>Downloadables</H2>                  <TABLE BORDER=0 CELLPADDING=3 WIDTH="500">            <TR>               <td width=50 align=left>                  <P ALIGN=center><img src="images/acrobatsmall.gif" height=23 align=middle alt="Acrobat" width=22></P>               </TD>               <td align="left">                  <P>Acrobat version of this Note (256K).</P>               </TD>               <td width=60 align=left>                  <P><A HREF="pdf/tn1067.pdf">Download</A></P>               </TD>            </TR></TABLE><P><A HREF="#top">Back to top</A></P></TD></TR></table></center><!-- begin_footer_information -->	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/technotes/tn/tn1067.html%3Fid%3DDTS10002908-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/technotes/tn/tn1067.html%3Fid%3DDTS10002908-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/technotes/tn/tn1067.html%3Fid%3DDTS10002908-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>
<!--#include virtual="/includes/footer"--><!-- end_footer_information --><hr width=500 align=center></BODY></HTML>