<!-- Generated by Harlequin WebMaker 2.2.3 (30-Apr-1996)
Macintosh Common Lisp Version 3.0kp2p2 [AppGen 3.0b1kp2p2] -->
<HTML> <HEAD>
<TITLE>Recipes--Documents (MacApp PG)</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING99></A>


<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->


<!-- Main Body -->

<CENTER>
<P>
<A HREF="MacAppProgGuide-98.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="MacAppProgGuide-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="MacAppProgGuide-158.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="MacAppProgGuide-100.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="MacAppProgGuide-2.html"><B>Programmer's Guide to MacApp</B></A> / <A HREF="MacAppProgGuide-78.html"><B>Part 2 - Working With MacApp</B></A><BR><DD><A HREF="MacAppProgGuide-97.html"><B>Chapter 16 - Working With Documents</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING99-0></A>
<H1><A NAME=MARKER-2-33></A>Recipes--Documents</H1>
 The recipes and sample code in this section start with a general outline on how to work with documents, then demonstrate how to revert to the previous version of a document, how to use a designator to save a document's current selection, and how to save a document's display state.<P>
<A NAME=HEADING99-2></A>
<H2><A NAME=MARKER-2-34></A>Working With Documents--A General Outline</H2>
 This outline describes the steps most MacApp applications take to work with documents. Your application uses document objects to store data; for most documents, that data is stored on disk. (Some applications may work with special documents that store data in an arbitrary location, such as a database.)<P>
 You define one or more document classes, based on the classes provided by MacApp, and override methods to read and write your specific data. Your application creates and initializes document objects based on the classes you define, and uses them to save your data to disk and read it back from disk. When a document is closed, you free any storage allocated by the document.<P>
 Working with documents usually includes the following steps:<P>
<OL>
<LI>Declare a subclass of <CODE>TFileBasedDocument</CODE> or (less commonly) <CODE>TDocument</CODE>, or of one of MacApp's subclasses of these two classes: <CODE>TEditionDocument</CODE> or <CODE>TMailableDocument</CODE>. Name your class <CODE>T<I>YourDocument</I></CODE>.
<LI>Override your application's <CODE>DoMakeDocument</CODE> method:<P>
<UL>
<LI>Your application can set the command number passed to <CODE>DoMakeDocument</CODE> by overriding the <CODE>TApplication::KindOfDocument</CODE> method, then create different kinds of documents based on the command number.
<LI>After creating a document object in the <CODE>DoMakeDocument</CODE> method, call the object's <CODE>I<I>YourDocument</I></CODE> method. (See <A HREF=MacAppProgGuide-111.html#MARKER-9-34>"Recipe--Defining a Subclass of TApplication," beginning on page 289</A>.)<P>
</UL>
<LI>Add initialization to your document class:<P>
<UL>
<LI>Supply a constructor method to put the fields of the document in a safe or default state, and a destructor method to free any memory allocated by your document class.
<LI>In the <CODE>I<I>YourDocument</I></CODE> method, call the initialization method of the parent class. (For example, if your class descends from <CODE>TFileBasedDocument</CODE>, you call <CODE>IFileBasedDocument</CODE>.) Follow that with any additional initialization required for the fields declared for your object.
<LI>If you wish, override the <CODE>DoInitialState</CODE> method to modify the document's initial state. <P>
</UL>
<LI>Override the <CODE>DoMakeViews</CODE> method in your document class to create the document's views.
<LI>Add code to your document class to save the document's data:<P>
<UL>
<LI>If you need to change the filename or other file information just before the document is saved, override the <CODE>AboutToSave</CODE> method.
<LI>If you need to modify the way MacApp handles saving your document when there is not enough space on the disk to create a copy, you can change the value of the <CODE>fHowToSave</CODE> field of the document's file handler (see <A HREF=MacAppProgGuide-60.html#MARKER-9-110>"Saving a Document in Place," beginning on page 180</A>).
<LI>If you <I>don't</I> want MacApp to save document print information with the file, set the value of the <CODE>fSavePrintInfo</CODE> field to <CODE>FALSE</CODE> in your initialization method, <I>after</I> calling <CODE>IFileBasedDocument</CODE> <A HREF=MacAppProgGuide-98.html#MARKER-9-31>(page 403)</A>. The default is for MacApp to save the document's print information automatically.
<LI>Override the <CODE>DoNeedDiskSpace</CODE> method in your document class to calculate the number of bytes needed to write your document data.
<LI>Override the <CODE>DoWrite</CODE> method in your document class to write the document's data to disk.<P>
</UL>
<LI>To open an existing document, override the following methods:<P>
<UL>
<LI>Override the <CODE>DoRead</CODE> method in your document class to read the document's data from. If you use streams to read data, remember to read the data in the exact order you wrote it.<P>
</UL>
<LI>To close a document, do one of the following:<P>
<UL>
<LI>If you want a document to remain open until its last window is closed, set the value of the <CODE>fClosesDocument</CODE> field of the document's window objects to <CODE>FALSE</CODE>. 
<LI>If you use methods other than the <CODE>DoIt</CODE>, <CODE>UndoIt</CODE>, and <CODE>RedoIt</CODE> methods of command objects to change a document's data, maintain the <CODE>fChangeCount</CODE> value in those methods. This allows MacApp to know whether the document needs to be saved when it is closed.
<LI>Supply a destructor method, <CODE>~T<I>YourDocument</I></CODE>, to free any storage allocated by your document object.
<LI>When a constructor method is called, you can't count on the class hierarchy still being intact. If your document class has to do any special cleanup that may involve calling inherited class methods, override the <CODE>Free</CODE> method (which is called before the constructor) and perform the cleanup there.<P>
</UL>
<LI>To perform special operations when closing a document:<P>
<UL>
<LI>For the simplest cases, override the <CODE>Close</CODE> method in your document class. Your version should normally call <CODE>Inherited</CODE> after performing its tasks.
<LI>For more complicated situations, you may need to define a special close command class that descends from the <CODE>TCloseDocCommand</CODE> class or the <CODE>TCloseFileDocCommand</CODE> class. You then override the document's <CODE>MakeCloseCommand</CODE> method and create and return a close document command object based on your command class.<P>
</UL>
<LI>If your document class handles any additional menu commands:<P>
<UL>
<LI>Override the <CODE>DoSetupMenus</CODE> method to enable the additional menu commands at the appropriate time.
<LI>Override the <CODE>DoMenuCommand</CODE> method to handle the menu commands.
<LI>If the commands are scriptable, override the <CODE>DoScriptCommand</CODE> method to respond to the Apple events that specify the commands.<P>
</UL>
<LI>To support the Revert command for your document objects, perform these steps:<P>
<UL>
<LI>Include the Revert menu item in your File menu resource definition.
<LI>Override the <CODE>FreeData</CODE> method to free any storage that you allocate for the document.
<LI>Optionally override the <CODE>DoInitialState</CODE>, <CODE>RevertDocument</CODE>, or <CODE>ShowReverted</CODE> methods.<A NAME=MARKER-2-35></A><P>
</UL>
</OL>
<A NAME=HEADING99-39></A>
<H2><A NAME=MARKER-2-36></A><A NAME=MARKER-9-37></A>Recipe--Reverting to a Previous Version of a Document</H2>
 A user can choose the Revert command from the File menu to return the current document to its most recently saved version. The Revert command is handled by the <CODE>DoMenuCommand</CODE> method of the <CODE>TDocument</CODE> class, which creates and posts a <CODE>TRevertDocCommand</CODE> object. The <CODE>IRevertDocCommand</CODE> method asks the user to confirm that they want to revert, since reverting cannot be undone.<P>
 The <CODE>DoIt</CODE> method of the <CODE>TRevertDocCommand</CODE> object calls two document methods:<P>
<UL>
<LI><B>RevertDocument.</B> In the <CODE>TDocument</CODE> class, the <CODE>RevertDocument</CODE> method<P>
<UL>
<LI>calls the document's <CODE>FreeData</CODE> method to free the current document storage
<LI>re-reads the disk version of the document to get the most recently saved version; if there is no disk version, <CODE>RevertDocument</CODE> instead calls the <CODE>DoInitialState</CODE> method of the document<P>
</UL>
<LI><B>ShowReverted.</B> In the <CODE>TDocument</CODE> class, the <CODE>ShowReverted</CODE> method just calls the <CODE>ShowReverted</CODE> method of each of the document's views, causing the views to redraw themselves.<P>
</UL>
 To allow a user to revert to a previous version of a document, you perform these steps:<P>
<OL>
<LI>Include the Revert menu item in your File menu.
<LI>Override the <CODE>FreeData</CODE> method in your document class to free any storage allocated by your document.<P>
</OL>
 You may also need to perform some of the following steps:<P>
<OL>
<LI>Override the <CODE>DoInitialState</CODE> method in your document class.
<LI>Override the <CODE>RevertDocument</CODE> method in your document class.
<LI>Override the <CODE>ShowReverted</CODE> method in your document or view class.<P>
</OL>
 The sample code shown in this recipe is taken from various MacApp sample applications.<P>
<A NAME=HEADING99-54></A>
<H3>Include the Revert Menu Item in Your File Menu</H3>
 To include the Revert item in your File menu, you can cut the Revert command definition from the File <CODE>'CMNU'</CODE> resource in MacApp's <CODE>Defaults.r</CODE> file and paste it into your own <CODE>'CMNU'</CODE> resource. Or you can include MacApp's entire File menu <CODE>'CMNU'</CODE> resource into your application by adding the following line to your resource definition file:<P>
<PRE>
include &quot;Defaults.rsrc&quot; 'CMNU' (mFile);
</PRE>
 The <CODE>TDocument::DoSetupMenus</CODE> method automatically enables the Revert menu command whenever the document's change count is not zero (indicating the document has changed).<P>
<A NAME=HEADING99-58></A>
<H3>Override FreeData in Your Document Class</H3>
 Your document class overrides the <CODE>FreeData</CODE> method to free any data storage allocated by the document. If a parent class needs to free any data, your <CODE>FreeData</CODE> method should call the inherited method as well.<P>
 For the DemoText application's <CODE>TTEDocument</CODE> class, the <CODE>FreeData</CODE> method just sets the size of the document's text handle to zero.<P>
<PRE>
void TTEDocument::FreeData() // Override.
{
   SetPermHandleSize(fDocText, 0);
}
</PRE>
<A NAME=HEADING99-62></A>
<H3>Override DoInitialState in Your Document Class</H3>
 You may need to override the <CODE>DoInitialState</CODE> method for the case in which the user reverts a document that has not yet been saved, which causes the document to revert to its original state (when first created). The <CODE>DoInitialState</CODE> method of the <CODE>TIconDocument</CODE> class contains code to set the icon bitmap to its default value:<P>
<PRE>
void TIconDocument::DoInitialState() // Override.
{
   Handle seedIcon;
   // Get the seed icon resource and set the icon bitmap to display.
   seedIcon = GetIcon(kSeedIconId);
   if (seedIcon != NULL)
      fIconBitMap-&gt;SetIconBitMap(seedIcon);
#if qDebug
   else
      ProgramBreak(&quot;Unable to get the seed icon resource.&quot;);
#endif
}
</PRE>
 If the application is built with debug information, this method displays an error message if there is a problem getting the seed icon.<P>
<A NAME=HEADING99-66></A>
<H3>Override RevertDocument in Your Document Class</H3>
 The <CODE>RevertDocument</CODE> method does nothing in the <CODE>TDocument</CODE> class. The version in the <CODE>TFileBasedDocument</CODE> class provides a general mechanism for reverting documents. Although this general mechanism should work for many types of documents, you may want to override <CODE>RevertDocument</CODE> to<P>
<UL>
<LI>add to the behavior of the <CODE>RevertDocument</CODE> method provided by <CODE>TFileBasedDocument</CODE>
<LI>change the basic behavior of the <CODE>RevertDocument</CODE> method provided by <CODE>TFileBasedDocument</CODE>
<LI>support reverting in a document class that doesn't descend from <CODE>TFileBasedDocument</CODE><P>
</UL>
 MacApp's <CODE>TEditionDocument</CODE> demonstrates the first of these three possibilities. <CODE>TEditionDocument</CODE> overrides the <CODE>RevertDocument</CODE> method to delete any new publishers belonging to the document:<P>
<PRE>
void TEditionDocument::RevertDocument()
{
   this-&gt;Abandon();
   Inherited::RevertDocument();
}
</PRE>
 The <CODE>Abandon</CODE> method iterates over the document's sections, deleting any that represent new publishers. The call to <CODE>Inherited</CODE> lets the <CODE>RevertDocument</CODE> method of <CODE>TFileBasedDocument</CODE> perform the rest of the revert operation.<P>
<A NAME=HEADING99-74></A>
<H3>Override ShowReverted in Your Document or View Class</H3>
 You may wish to modify the default behavior of the <CODE>ShowReverted</CODE> method in your document or view class. For example, DemoText's TTEDocument class overrides <CODE>ShowReverted</CODE> to install its text, then calls <CODE>Inherited</CODE> to cause its views to be redrawn in the usual way:<P>
<PRE>
void TTEDocument::ShowReverted()// Override.
{
   CRGBColor aColor;

   fTEView-&gt;StuffText(fDocText);// Put in the text.
   TESetSelect(0, 0, fTEView-&gt;fHTE);
   if (fStyles &amp;&amp; fElements)  // If possible, save style info.
      fTEView-&gt;StuffStyles(fStyles, fElements);
   else
      this-&gt;SetSpecStyle();   // Otherwise, use default.

   if (qNeedsColorQD || HasColorQD())// Restore background color.
   {
      aColor = fTextSpecs.theBackColor;
      this-&gt;ChangeBackColor(aColor);
   }
   fTEView-&gt;SetJustification(fTextSpecs.theJustification, kDontRedraw);
   Inherited::ShowReverted();
}
</PRE>
 MacApp's <CODE>TTEView</CODE> class overrides ShowReverted to recalculate information such as page breaks and line heights before the view is redrawn:<P>
<PRE>
void TTEView::ShowReverted()// Override.
{
   this-&gt;RecalcText();  // Calls Toolbox TECalc routine.
   fLastHeight = 0;
   fLastWidth = 0;
   Inherited::ShowReverted();
}
</PRE>
<A NAME=HEADING99-79></A>
<H2><A NAME=MARKER-2-38></A><A NAME=MARKER-9-34></A>Recipe--Saving the Current Selection With a Designator</H2>
 MacApp supplies a framework for saving a document's current selection in the <CODE>TDocument</CODE> and <CODE>TFileBasedDocument</CODE> classes:<P>
<UL>
<LI>The <CODE>TDocument</CODE> class supplies two fields used in saving and restoring the user selection:<P>
<UL>
<LI><CODE>Boolean fSaveUserSelection</CODE>: Determines whether the document should save the current user selection; defaults to <CODE>TRUE</CODE>.
<LI><CODE>TDesignator* fUserSelection</CODE>: Designates the current user selection; defaults to <CODE>NULL</CODE>.<P>
<CODE>TDocument</CODE> also provides accessor methods for the <CODE>fUserSelection</CODE> field, as well as two other methods used in saving and restoring the user selection:
<LI><CODE>DoPostMakeViews</CODE>: If there is a user selection, this method calls the <CODE>RevealSelection</CODE> method.
<LI><CODE>RevealSelection</CODE>: In <CODE>TDocument</CODE>, this method selects the first window in the document's window list (if it wasn't already active).<P>
</UL>
<LI>The <CODE>TFileBasedDocument</CODE> class supplies methods to read and write the current user selection:<P>
<UL>
<LI><CODE>DoReadSelection</CODE>: If <CODE>fSaveUserSelection</CODE> is <CODE>TRUE</CODE> and the file has a resource fork, <CODE>DoReadSelection</CODE> attempts to read a resource of type <CODE>kDesignatorResType</CODE> with ID <CODE>kSelectionRsrcID</CODE>. If successful, it uses the resource to set the document's <CODE>fUserSelection</CODE> field.
<LI><CODE>DoWriteSelection</CODE>: If <CODE>fSaveUserSelection</CODE> is <CODE>TRUE</CODE>, <CODE>DoWriteSelection</CODE> attempts to add the <CODE>fUserSelection</CODE> field to the file's resource fork (if it has one) as a resource of type <CODE>kDesignatorResType</CODE> with ID <CODE>kSelectionRsrcID</CODE>.<P>
</UL>
</UL>
 Since MacApp has provided this framework, the rest is relatively easy.<P>
 To save your document's current user selection with a designator, you perform these steps:<P>
<OL>
<LI>Override <CODE>SetUserSelection</CODE> in your document class.
<LI>Override <CODE>RevealSelection</CODE> in your document class.<P>
</OL>
 The sample code shown in this recipe is from the Calc application.<P>
<A NAME=HEADING99-95></A>
<H3>Override SetUserSelection in Your Document Class</H3>
 Your document class overrides <CODE>SetUserSelection</CODE> to set any selection fields of your document or view class. The Calc application uses a region designator to designate the cells currently selected by the user. The <CODE>SetUserSelection</CODE> method of <CODE>TCalcDocument</CODE> uses the region from the region designator to set the selection for the document's cells view (its main spreadsheet view).<P>
<PRE>
void TCalcDocument::SetUserSelection(TDesignator* newSelection)
{
   // Inherited sets the fUserSelection field.
   Inherited::SetUserSelection(newSelection);
   
   if (fCellsView &amp;&amp; fCellsView-&gt;fSelections)
   {
      // If the selection designator is the right type (a region
      // designator), get the region handle from the designator and
      // use it to set selected cells in main spreadsheet view.
      TDesignator * userSelection = this-&gt;GetUserSelection();
      if ((userSelection) &amp;&amp; userSelection-&gt;DescendsFrom(
                     TRegionDesignator::GetClassDescStatic()))
         fCellsView-&gt;SetSelection(((TRegionDesignator *)
            (userSelection))-&gt;fDesignation, kDontExtend,
            kHighlight, kSelect);
   }
}
</PRE>
<A NAME=HEADING99-98></A>
<H3>Override RevealSelection in Your Document Class</H3>
 The RevealSelection method in <CODE>TDocument</CODE> activates only the first window in the document's window list. That's a start, but you'll also need to make sure the selection is visible in your view. The RevealSelection method for the <CODE>TCalcDocument</CODE> class calls <CODE>Inherited</CODE> to make sure the window is selected, then sets the selection for the main spreadsheet view based on the selection designator, and finally scrolls that selection into view.<P>
<PRE>
void TCalcDocument::RevealSelection(TDesignator* aSelection)// Override.
{
   CRect qdExtent;
   VRect viewRect;

   // Select the window (make it frontmost).
   Inherited::RevealSelection(aSelection); 

   // If the selection designator is the right type (a region designator),
   // get the region handle from the designator and use it to set
   // the selected cells in our main spreadsheet view, then scroll
   // those cells into view.
   if (aSelection-&gt;DescendsFrom(TRegionDesignator::GetClassDescStatic()))
   {
      fCellsView-&gt;SetSelection(((TRegionDesignator *)
         (aSelection))-&gt;fDesignation, kDontExtend, kHighlight, kSelect);

      fCellsView-&gt;ScrollSelectionIntoView(kRedraw);
   }
   // If the designator isn't the correct type, and we're in a debug
   // version of the application, say something about it.
   else if (qDebug)
      ProgramBreak(&quot;handed an unknown designator&quot;);
}
</PRE>
<A NAME=HEADING99-101></A>
<H2><A NAME=MARKER-2-40></A>Recipe--Saving and Restoring a Document's Display State</H2>
 When opening an existing document, users may like to find the window and view the way they were left when the document was saved--that is, with the window in the same position and at the same size and displaying the view in the same scroll position. To provide this capability, you need to save the display state of the document when you save the document, then restore it when the document is opened.<P>
 To save and restore a document's display state, you perform these steps:<P>
<OL>
<LI>Define a display state information record and add a display state field to your document class.
<LI>Add a Boolean field to your document class to specify when the document is being reopened.
<LI>Write the display state record when writing the document.
<LI>Read the display state record when reading the document.
<LI>Set the document's display state from the record when reopening.<P>
</OL>
 The sample code shown in this recipe is for a hypothetical application.<P>
<A NAME=HEADING99-110></A>
<H3>Define a Display State Information Record and a Document Field</H3>
 The display state record should store any information about the document's display state that your application needs to save and restore. That information would normally include the location, size, and scroll position of the window, as well as any display information specific to your application. This recipe stores its information in a simple structure, but your specific data may require your application to define a more complicated display state structure or even a special class.<P>
<PRE>
struct DocState
{
   VPoint   theLocation;
   VPoint   theSize;
   VPoint   theScrollPosition;
   // Add fields for information specific to your document class.
};
</PRE>
 You also add a field to your document class to store the display state:<P>
<PRE>
class TYourDocument : public TFileBasedDocument
{  .
   .
   .
   DocState fDocState;
</PRE>
<A NAME=HEADING99-115></A>
<H3>Add a Boolean Field to Specify Reopening</H3>
 You add a Boolean field to your document class definition to specify whether a document is being opened:<P>
<PRE>
BooleanfReopening;
</PRE>
 You set <CODE>fReopening </CODE>to <CODE>FALSE</CODE> in the constructor method for your document class. You set it to <CODE>TRUE</CODE> after reading the display information when opening an existing document.<P>
<A NAME=HEADING99-119></A>
<H3>Write the Display State Record When Writing</H3>
 You write the display state record when writing your document's data in its <CODE>WriteTo</CODE> method:<P>
<PRE>
void TYourDocument::WriteTo(TStream* aStream) // Override.
{
   DocState localDocState;
   TScroller * theScroller = NULL;
   // Declare other variables needed for writing data (not shown).

   // Do any inherited writing, such as print information.
   Inherited::WriteTo(aStream);

   // Get document's main window location, size, and scroll position.
   TWindow* mainWindow = (TWindow*)fWindowList-&gt;First();
   if (mainWindow != NULL)
   {
      localDocState.theLocation = mainWindow-&gt;fLocation;
      localDocState.theSize = mainWindow-&gt;fSize;
      theScroller = mainWindow-&gt;GetScroller(FALSE);
      if (theScroller != NULL)
         localDocState.theScrollPosition = theScroller-&gt;fTranslation;
      // Add display state info specific to your document (not shown).

      // Write out the display info structure as a number of bytes.
      aStream-&gt;WriteBytes(&amp;localDocState, sizeof(DocState));
   }

   // Write other document data (not shown).
}
</PRE>
 This method first gathers the current display state information into a local structure, then writes the bytes of that structure to the stream, which is typically a file stream.<P>
<A NAME=HEADING99-123></A>
<H3>Read the Display State Record When Reading</H3>
 You read the display state record when reading your document's data in its <CODE>ReadFrom</CODE> method:<P>
<PRE>
void TYourDocument::ReadFrom(TStream* aStream) // Override.
{
   // Do any inherited reading.
   Inherited::ReadFrom(aStream);

   // Read in the doc state record.
   aStream-&gt;ReadBytes(&amp;fDocState, sizeof(DocState));
   // Set variable indicating we are reopening the document.
   fReopening = TRUE;

   // Read other document data (not shown).
}
</PRE>
<DL>
<DT><B>WARNING</B>
<DD>When reading a document from a stream, read information in <I>exactly</I> the same order in which you wrote it. Failure to do so will at best result in garbled data, and will generally result in program crashes.  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
<A NAME=HEADING99-127></A>
<H3>Set the Document's Display State From the Record When Reopening</H3>
 After creating views to display the document's data in its <CODE>DoMakeViews</CODE> method, you can set the display state with code like the following:<P>
<PRE>
if (fReopening)
   this-&gt;RestoreWindow(aWindow);
else
   {
      aWindow-&gt;AdaptToScreen();
      CPoint stagger(kStaggerAmount, kStaggerAmount);
      aWindow-&gt;SimpleStagger(stagger, gStaggerCount);
   }
</PRE>
 When opening a new document (<CODE>fReopening</CODE> is <CODE>FALSE</CODE>), this code staggers the window so that it won't directly overlap a previous new window. When opening an existing document (<CODE>fReopening</CODE> is <CODE>TRUE</CODE>), it calls the <CODE>RestoreWindow</CODE> method:<P>
<PRE>
void T<I>Your</I>Document::<A NAME=MARKER-2-41></A>RestoreWindow(TWindow* aWindow)
{
	// Restore the window and scroller using the settings in the
	// document's fDocState field.
	aWindow-&gt;Locate(fDocState.theLocation, FALSE);
	aWindow-&gt;Resize(fDocState.theSize, FALSE);
	aWindow-&gt;ForceOnScreen();

	TScroller* theScroller(NULL);
	theScroller = aWindow-&gt;GetScroller(FALSE);
	if (theScroller)
		theScroller-&gt;SetLocalOrigin(fDocState.theScrollPosition, FALSE);

	// Adjust the display state further based on information
	//		specific to your application (not shown).	
}<A NAME=MARKER-2-42></A><A NAME=MARKER-2-43></A>
</PRE>
</BLOCKQUOTE>
<HR>
<center>
<A HREF="MacAppProgGuide-98.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="MacAppProgGuide-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="MacAppProgGuide-158.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="MacAppProgGuide-100.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="MacAppProgGuide-3.html">&copy; Apple Computer, Inc.</A><br>25 JUL 1996</center></font><P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML>  
