/*	File:			PGPUAMclientProtocol.c	Description:	Handles the PGPlogin Authorization Process	Written by:	Vinnie Moscaritolo	Copyright:	© 1998 by Apple Computer, Inc., all rights reserved.	Change History (most recent first):	You may incorporate this sample code into your applications without	restriction, though the sample code has been provided "AS IS" and the	responsibility for its operation is 100% yours.  However, what you are	not permitted to do is to redistribute the source as "DSC Sample Code"	after having made changes. If you're going to re-distribute the source,	we require that you make it clear in the source that the code was	descended from Apple Sample Code, but that you've made changes.*///------------------------------------------------------------------------------------#pragma mark Includes//------------------------------------------------------------------------------------#include <Errors.h>#include <String.h>#include <A4Stuff.h>#include <Resources.h>#include <MixedMode.h>#include <PLStringFuncs.h>#include <TextUtils.h>#include "ClientUAM.h" #include "AFPPackets.h"#include "PGPUAMclient.h"#include "PGPUAMmsgFormat.h"#include "PGPUAMclientProtocol.h"#include "PGPUAMclientLoginDialog.h"#define PGP_MACINTOSH 1#include "pgpErrors.h"#include "pgpKeys.h"#include "pgpUtilities.h"#include "pgpFeatures.h"#include "pgpUserInterface.h"#include "pgpHash.h"#include "pgpPublicKey.h"#include "TPGPException.h" #define CAN_DO_ASYNC_OPENSESSION 0#define CAN_DO_ASYNC_SENDREQUEST 0// ---------------------------------------------------------------------------#pragma mark Local Prototypes// ---------------------------------------------------------------------------static  pascal void SndLoginCmdCompletion (void* context, OSStatus result);	#pragma mark -static pascal void SndLoginCmdCompletion (void* context, OSStatus result){	OSStatus*  err = (OSStatus*) context;	*err = result;}// ---------------------------------------------------------------------------OSStatus SndLoginCmd(	ClientUAMCallbackRec 	*callbacks,									StringPtr 	serverVersion, 									StringPtr 	uamName, 									StringPtr 	userName,									StringPtr	challengeString,									OTAddress 	*serverAddress,									UInt8	  	*replyBuffer,									UInt32	  	replyBufferSize,									UInt32	  	*actReplyBufferSize,									short 	  	*sessionRefNum,							LoginIdleProcPtr	idleProc										)// ---------------------------------------------------------------------------{	OSStatus		ErrNo 		= kUAMError;	UAMMessage		message;	UInt8			commandBuffer[256];	UInt8		    *cmdP;	OSStatus 		result = 1; 	// format login command message	cmdP = (UInt8*) FormatLoginCmd(commandBuffer, serverVersion, uamName, userName, challengeString );	// build OpenSession command.			message.commandCode	 	= kOpenSession;	message.cmdBuffer 		= commandBuffer;	message.cmdBufferSize 	= cmdP - commandBuffer;	message.replyBuffer 	= replyBuffer;	message.replyBufferSize = replyBufferSize;// send OpenSession to server.		#if CAN_DO_ASYNC_OPENSESSION	DebugStr("\psend OpenSession to server");	message.contextPtr 		= &result;	message.completion 		= SndLoginCmdCompletion;    	ErrNo = CallUniversalProc( 	callbacks->OpenSessionUPP, 								kOpenSessionProcInfo, 								serverAddress, 								nil, 								&message); 	if(ErrNo != noErr)	while(result == 1) 	{		if(idleProc) (idleProc)();	}	 	 	if (ErrNo != noErr) return  ErrNo ; 	#else	message.contextPtr 		= nil;	message.completion 		= nil;  	 	result = CallUniversalProc( callbacks->OpenSessionUPP, 								kOpenSessionProcInfo, 								serverAddress, 								nil, 								&message); #endif	*sessionRefNum 		= message.sessionRefNum;	*actReplyBufferSize = message.replyBufferSize;	if(result != noErr) result = message.result; 	  	return result;}// ---------------------------------------------------------------------------OSStatus SndLoginContinueCmd(	ClientUAMCallbackRec 	*callbacks,									short 	  	sessionRefNum,									StringPtr 	answerString, 									UInt8	  	*replyBuffer,									UInt32	  	replyBufferSize,									UInt32	  	*actReplyBufferSize,							LoginIdleProcPtr	idleProc										)// ---------------------------------------------------------------------------{	OSStatus		ErrNo 		= kUAMError;	UAMMessage		message;	UInt8			commandBuffer[200];	UInt8		    *cmdP;	OSStatus 		result = 1;	 // format login Continue command message	cmdP = (UInt8*) FormatLoginContinueCmd(commandBuffer,  answerString);		message.commandCode	 	= kSendRequest;	message.sessionRefNum	= sessionRefNum;	message.cmdBuffer 		= commandBuffer;	message.cmdBufferSize 	= cmdP - commandBuffer;	message.replyBuffer 	= replyBuffer;	message.replyBufferSize = 128;#if CAN_DO_ASYNC_SENDREQUEST	message.contextPtr 		= &result;	message.completion 		= SndLoginCmdCompletion;  	// send to server.	ErrNo = CallUniversalProc(	callbacks->SendRequestUPP, kSendRequestProcInfo,&message);					 	if(ErrNo != noErr)	while(result == 1) 	{		if(idleProc) (idleProc)();	}	 	 	if (ErrNo != noErr) return  ErrNo ;#else	message.contextPtr 		= nil;	message.completion 		= nil;  	 	result =  CallUniversalProc( callbacks->SendRequestUPP, kSendRequestProcInfo,&message); #endif 	*actReplyBufferSize = message.replyBufferSize;	if(result != noErr) result = message.result;  	return result;} 