<!-- Generated by Harlequin WebMaker 2.2.3 (30-Apr-1996)
Macintosh Common Lisp Version 3.0kp2p2 [AppGen 3.0b1kp2p2] -->
<HTML> <HEAD>
<TITLE>Overview (MacApp PG)</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING134></A>


<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->


<!-- Main Body -->

<CENTER>
<P>
<A HREF="MacAppProgGuide-133.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="MacAppProgGuide-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="MacAppProgGuide-158.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="MacAppProgGuide-135.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="MacAppProgGuide-2.html"><B>Programmer's Guide to MacApp</B></A> / <A HREF="MacAppProgGuide-78.html"><B>Part 2 - Working With MacApp</B></A><BR><DD><A HREF="MacAppProgGuide-133.html"><B>Chapter 27 - Working With Streams</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING134-0></A>
<H1>Overview</H1>
 A <I>stream</I> is a sequence of bytes that can be used to transfer data between locations. Most programmers are familiar with the use of streams for file I/O. MacApp provides stream classes that are useful for transferring data between a variety of destinations, such as files, memory, resources, and sections.<P>
<A NAME=HEADING134-2></A>
<H2><A NAME=MARKER-2-21></A>Writing a Document to a File Stream</H2>
 MacApp's mechanism for saving a file-based document is described in <A HREF=MacAppProgGuide-57.html#MARKER-9-23>Chapter 7, "Document Handling."</A> In summary, a call is made to a document's <CODE>SaveDocument</CODE> method. For a <CODE><A NAME=MARKER-2-22></A>TFileBasedDocument</CODE> object, <CODE><A NAME=MARKER-2-23></A>SaveDocument</CODE> calls the <CODE>SaveFile</CODE> method of the document's file handler. The <CODE><A NAME=MARKER-2-24></A>SaveFile</CODE> method calls another file-handler method to save the file. Eventually, the file handler calls the document's <A NAME=MARKER-2-25></A><CODE>DoWrite</CODE> method, passing a reference to the document's file. Your document class overrides <CODE>DoWrite</CODE> to write its data.<P>
<PRE>
TYourDocument::DoWrite(TFile* aFile, Boolean makingCopy)
{
   // Give parent class a chance to write its data.
   Inherited::DoWrite(aFile, makingCopy);

   // Create and init a file stream. Don't store it in a register.
   MAVolatileInit(TFileStream*, aFileStream, new TFileStream);
   aFileStream-&gt;IFileStream(aFile);

   // Write various data. Wrap the writing code in a failure handler
   // so that if a failure occurs, you can free the file stream.
   FailInfo fi;
   Try(fi)
   {  
      // Call the stream's WriteBytes method directly to write a color.
      theFileStream-&gt;WriteBytes( (void *) &amp;fColor, sizeof(CRGBColor));

      // Write a Boolean field using a method of the stream.
      theFileStream-&gt;WriteBoolean(fBooleanFlag);

      // Call a stream method that writes an entire object.
      theFileStream-&gt;WriteStreamObject(fDataObject, kStandardObject);

      // Directly call the WriteTo method of an object to let the
      // object write its data to the stream.
      fOtherDataObject-&gt;WriteTo(theFileStream);
   }
   else  // If error occurs, free the file stream.
   {
      aFileStream = (TFileStream *)FreeIfObject(aFileStream);
      fi.ReSignal();
   }
   // Done with file stream, so free it now.
   aFileStream = (TFileStream *)FreeIfObject(aFileStream);

} // TYourDocument::DoWrite
</PRE>
 Your <CODE>DoWrite</CODE> method first calls <CODE>Inherited</CODE> to allow its parent class to write any required data. It then creates and initializes a <CODE><A NAME=MARKER-2-26></A>TFileStream</CODE> object, using the MAVolatileInit macro to make sure the file stream object is not stored in a register.<P>
 The <CODE>DoWrite</CODE> method then writes out any <I>persistent data</I> (defined on <A HREF=MacAppProgGuide-27.html#MARKER-9-57>page 51</A>) for your document class. You can use any of the writing methods of the <CODE>TStream</CODE> class, knowing that the stream's destination is the document's file. The version of DoWrite shown above demonstrates some of the calls your document might require to write its data.<A NAME=MARKER-2-27></A><P>
<A NAME=HEADING134-7></A>
<H2><A NAME=MARKER-2-28></A>Reading a Document From a Stream</H2>
 <A NAME=MARKER-2-29></A>Reading a document file from a stream is similar to writing the document, but the action takes place in the <CODE>DoRead</CODE> method of your document object, shown on the following page.<P>
<PRE>
void TYourDocument::DoRead(TFile* aFile, Boolean forPrinting)
{
   // Give parent class a chance to read its data.
   Inherited::DoRead(aFile, forPrinting);
   // Create and initialize a file stream. Don't store it in a register.
   MAVolatileInit(TFileStream*, aFileStream, new TFileStream);
   aFileStream-&gt;IFileStream(aFile);
   // Initialize a Boolean to specify whether we have created an object.
   MAVolatileInit(Boolean, haveObject, FALSE);
   TObject* theObject = NULL;// Passed by reference--doesn't need
                        // the MAVolatileInit macro.
   FailInfo fi;
   Try(fi)// Use failure handling in case of error.
   {
      // Call stream's ReadBytes method directly to read color.
      theFileStream-&gt;ReadBytes( (void *) &amp;fColor, sizeof(CRGBColor));

      // Read a Boolean field using a method of the stream.
      fBooleanFlag = theFileStream-&gt;ReadBoolean();

      // Call a method to read an entire object and set field.
      haveObject = theFileStream-&gt;ReadStreamObject((TObject*&amp;)
                                             theObject);
      if (haveObject) fDataObject = (TDataObject *) theObject;

      // Directly call the ReadFrom method of an object to let the
      // object read its data from the stream. (Assumes object
      // has already been created as part of creating the document.)
      fOtherDataObject-&gt;ReadFrom(theFileStream);
   }
   else
   {
      // Free object and stream if an error occurs.
      aFileStream = (TFileStream *)FreeIfObject(aFileStream);
      if (haveObject) fDataObject = (TDataObject *)
                              FreeIfObject(theObject);
      fi.ReSignal();// Pass on the failure.
   }
   // Done with file stream, so free it now.
   aFileStream = (TFileStream *)FreeIfObject(aFileStream);
} // TYourDocument::DoRead
</PRE>
 Your document's <CODE>DoRead</CODE> method first calls <CODE>Inherited</CODE> to allow its parent class to read any required data. Then it creates and initializes a <A NAME=MARKER-2-30></A><CODE>TFileStream</CODE> object, using the MAVolatileInit macro to make sure the file stream object is not stored in a register. It also uses the macro to ensure that a Boolean variable, used in failure handling, is not stored in a register.<P>
 The <CODE>DoRead</CODE> method then reads any persistent data for the document object <I>in the same order in which the data was written</I>. The version of <CODE>DoRead</CODE> shown here demonstrates some of the calls your document might require to read its data. It makes these calls in the same order that similar calls were made by the <CODE>DoWrite</CODE> method to write the data.<A NAME=MARKER-2-31></A><P>
<DL>
<DT><B>WARNING</B>
<DD>A failure to read data in the exact order it was written will lead to trashed data at best and to program crashes at worst. This is probably the number one cause of bugs in using streams.<A NAME=MARKER-2-32></A>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
</BLOCKQUOTE>
<HR>
<center>
<A HREF="MacAppProgGuide-133.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="MacAppProgGuide-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="MacAppProgGuide-158.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="MacAppProgGuide-135.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="MacAppProgGuide-3.html">&copy; Apple Computer, Inc.</A><br>25 JUL 1996</center></font><P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML>  
