<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>MyCaptureApp - /MySGStuff.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../samplecode/LegacyTechnologies/idxQuickTime-date.html">QuickTime</a> &gt; <A HREF="javascript:location.replace('index.html');">MyCaptureApp</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/QuickTime/index.html" target="_blank">Reference Library > QuickTime</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">MyCaptureApp</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/MySGStuff.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/MyCaptureAppShell.c</option>
<option value="listing2.html">/MyCaptureAppShell.h</option>
<option value="listing3.html">/MyHeaders.c</option>
<option value="listing4.html">/MySGStuff.c</option>
<option value="listing5.html">/MySGStuff.h</option>
<option value="listing6.html">/MyUtils.c</option>
<option value="listing7.html">/MyUtils.h</option></select>
				</p>
				</form>
				<p><strong><a href="MyCaptureApp.zip">Download Sample</a></strong> (&#147;MyCaptureApp.zip&#148;, 16.1K)<BR>
<strong><a href="MyCaptureApp.dmg">Download Sample</a></strong> (&#147;MyCaptureApp.dmg&#148;, 74.0K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/*  File:    MySGStuff.c    Contains:  Sequence grabber code.  Written by:  John Wang  Copyright:  &copy; 1994 by Apple Computer, Inc., all rights reserved.  Change History (most recent first):    &lt;5&gt;    07/01/94  JW    1.0    Added workaround for AV machines that don't initialize video                      settings properly.  The fix is to call GetSetting and then SetSettings                      when no preferences is loaded for the channel.    &lt;4&gt;    04/25/94  JW    1.0b4.  Fixed minor bug in 1.0b3 where if the sound channel wasn't                      opened, then MyUpdateChannels would fail.    &lt;3&gt;    04/18/94  JW    1.0b3.  Support for multiple capture channels.    &lt;2&gt;    04/08/94  JW    1.0b2.  Support for preferences file added so that channel                      settings is preserved.    &lt;1&gt;    04/04/94  JW    1.0b1  Started and created as 1.0b1.  To Do:  */#ifdef THINK_C#define    applec#endif#include  &quot;MyHeaders&quot;/*#include  &lt;Types.h&gt;#include  &lt;Memory.h&gt;#include  &lt;QuickDraw.h&gt;#include  &lt;Palettes.h&gt;#include  &lt;QDOffscreen.h&gt;#include  &lt;Errors.h&gt;#include  &lt;Fonts.h&gt;#include  &lt;Dialogs.h&gt;#include  &lt;Windows.h&gt;#include  &lt;Menus.h&gt;#include  &lt;Events.h&gt;#include  &lt;Desk.h&gt;#include  &lt;DiskInit.h&gt;#include  &lt;OSUtils.h&gt;#include  &lt;Resources.h&gt;#include  &lt;ToolUtils.h&gt;#include  &lt;AppleEvents.h&gt;#include  &lt;EPPC.h&gt;#include  &lt;GestaltEqu.h&gt;#include  &lt;Processes.h&gt;#include  &lt;Balloons.h&gt;#include  &lt;Aliases.h&gt;#include  &lt;MixedMode.h&gt;#include  &lt;Scrap.h&gt;#include  &lt;LowMem.h&gt;#include  &lt;Movies.h&gt;#include  &lt;QuickTimeComponents.h&gt;*/#include  &quot;MyCaptureAppShell.h&quot;#include  &quot;MySGStuff.h&quot;#include  &quot;MyUtils.h&quot;/* ------------------------------------------------------------------------- *///  Contains application runtime variables.  Stored in window refCon as handle block.struct WindowInfo {  ComponentInstance    theSG;  SGChannel        channel[kMAXCHANNELS];  Boolean          recordPlayThru;  Boolean          createSeparateFiles;};typedef    struct WindowInfo WindowInfo, *WindowInfoPtr, **WindowInfoHandle;//  Contains compression settings for the video channel.  Used in SGInfo.struct CompressionInfo {  OSType    compressorType;  short    depth;  CodecQ    spatialQuality;  CodecQ    temporalQuality;  long    keyFrameRate;};typedef    struct CompressionInfo CompressionInfo;//  Contains Sequence Grabber channel information.  Stored as a global variable.struct SGInfo {  CompressionInfo    cInfo;  OSType        channelType[kMAXCHANNELS];  Handle        channelName[kMAXCHANNELS];  UserData      channelSettings[kMAXCHANNELS];};typedef    struct SGInfo SGInfo;SGInfo    gSGInfo;//  Boolean variable.  true is QuickTime 2.0 or later.  false otherwise i.e. 1.6.2.Boolean    gHasQuickTime20;/* ------------------------------------------------------------------------- *///  MyInitialize is called at init time after the toolbox is initialized.  This routine is//  called only once.long MyInitialize(){  long          err;  long          QDfeature;  short          myRefNum;  short          i;  ComponentDescription  cd, theCD;  Component        aComponent;  Boolean          done;  MenuHandle        mHandle;    //  We require QuickTime so make sure it is available.  err = Gestalt(gestaltQuickTime, &amp;QDfeature);  if ( err != noErr )    return ( err );      //  Check for QuickTime 2.0 or later.  gHasQuickTime20 = ((QDfeature &gt;&gt; 16) &amp; 0xffff) &gt;= 0x200;    //  Start the engine.  err = EnterMovies();  if ( err != noErr )    return ( err) ;    //  Find out what sequence grabber channels are available by searching all sequence  //  grabber channel components.  Get channelType[] and channelName[].  for ( i=0; i&lt;kMAXCHANNELS; i++ ) {    gSGInfo.channelType[i] = 0;    gSGInfo.channelName[i] = nil;  }  cd.componentType = SeqGrabChannelType;  cd.componentSubType = 0;  cd.componentManufacturer = 0;  cd.componentFlags = 0;  cd.componentFlagsMask = 0;  aComponent = 0;  for ( i=0, done=false; i&lt;kMAXCHANNELS &amp;&amp; !done; i++ ) {    aComponent = FindNextComponent(aComponent, &amp;cd);    if (aComponent != 0) {      gSGInfo.channelName[i] = NewHandle(4);      GetComponentInfo(aComponent, &amp;theCD, gSGInfo.channelName[i], nil, nil);      gSGInfo.channelType[i] = theCD.componentSubType;    } else      done = true;  }  //  Read preferences for compression settings and  //  channelSettings[] (if channel has been previously found).  if ( (myRefNum = readPreferencesFile()) != -1 ) {    //  File opened.    Handle      myHandle;    //  Get Compression info.    myHandle = Get1Resource('INFO', 128);    if ( myHandle != nil ) {      DetachResource(myHandle);      HLock(myHandle);      BlockMove(*myHandle, &amp;(gSGInfo.cInfo), sizeof(CompressionInfo));      HUnlock(myHandle);      DisposeHandle(myHandle);    } else {      //  If no such resource, then manually udpate the values.      gSGInfo.cInfo.compressorType = 'raw ';      gSGInfo.cInfo.depth = 16;      gSGInfo.cInfo.spatialQuality = codecLosslessQuality;      gSGInfo.cInfo.temporalQuality = 0;      gSGInfo.cInfo.keyFrameRate = 0;    }        //  Get all the saved channel settings for the channels that are available.    for ( i=0; i&lt; kMAXCHANNELS; i++ ) {      if (gSGInfo.channelType[i] != 0) {        myHandle = Get1Resource(gSGInfo.channelType[i], 128);        if ( myHandle != nil ) {          err = NewUserDataFromHandle(myHandle, &amp;(gSGInfo.channelSettings[i]));          if ( err != noErr ) {            ReportWarning(&quot;\pCould not create user data from handle: &quot;, err);            gSGInfo.channelSettings[i] = nil;          }        } else          gSGInfo.channelSettings[i] = nil;      } else        gSGInfo.channelSettings[i] = nil;    }        //  Finished.  Close the preferences file.    closePreferencesFile(myRefNum);  } else {    //  If no preferences file, then use default values.    gSGInfo.cInfo.compressorType = 'raw ';    gSGInfo.cInfo.depth = 16;    gSGInfo.cInfo.spatialQuality = codecLosslessQuality;    gSGInfo.cInfo.temporalQuality = 0;    gSGInfo.cInfo.keyFrameRate = 0;    for ( i=0; i&lt; kMAXCHANNELS; i++ )      gSGInfo.channelSettings[i] = nil;  }  //  Add the channel names to the menu.  mHandle = GetMHandle(kMENU_SETTINGSID);  for ( i=0; i&lt;kMAXCHANNELS; i++ ) {    if (gSGInfo.channelType[i] != 0) {      Str255    myStr;            BlockMove(&quot;   Disable&quot;, &amp;myStr[1], 11);      BlockMove(*(gSGInfo.channelName[i]), &amp;myStr[11], **(gSGInfo.channelName[i]) + 1);      myStr[0] = 11 + **(gSGInfo.channelName[0]);      myStr[11] = ' ';      AppendMenu(mHandle, (unsigned char *) *(gSGInfo.channelName[i]));      AppendMenu(mHandle, myStr);    }  }  return ( noErr );}void MyFinishup(){  long        err;  short        myRefNum, i;    //  Should close all windows.  But, since we know this app only supports one window, we  //  don't need to loop.  MyClose();  //  Write preferences file for all channel settings and compression settings.  if ((myRefNum = writePreferencesFile()) != -1) {    Handle      mySetting, myInfo;        //  Write the compressor settings to preferences file.    myInfo = NewHandle(sizeof(CompressionInfo));    if ( myInfo == nil ) {      ReportWarning(&quot;\pCound not create compressor settings handle.&quot;, 0);    } else {      HLock((Handle) myInfo);      BlockMove(&amp;(gSGInfo.cInfo), *myInfo, sizeof(CompressionInfo));      HUnlock((Handle) myInfo);      AddResource(myInfo, 'INFO', 128, &quot;\pCompression Settings.&quot;);    }        //  Write out channel settings.    for ( i=0; i&lt; kMAXCHANNELS; i++ ) {      if (gSGInfo.channelType[i] != 0 &amp;&amp; gSGInfo.channelSettings[i] != nil ) {        mySetting = NewHandle(4);        if ( mySetting == nil ) {          ReportWarning(&quot;\pCound not create settings handle.&quot;, 0);        } else {          PutUserDataIntoHandle(gSGInfo.channelSettings[i], mySetting);          AddResource(mySetting, gSGInfo.channelType[i], 128, &quot;\pSettings.&quot;);        }      } else        gSGInfo.channelSettings[i] = nil;    }        closePreferencesFile(myRefNum);    } else    ReportWarning(&quot;\pSorry.  Could not create preferences file.&quot;, 0);}void MyIdle(){  WindowPtr    theWindow;  theWindow = FrontWindow();    //  Only one window allowed to be opened at a time.  if ( theWindow != nil ) {  //  Yes, window open.    WindowInfoHandle  myWindowInfo;        myWindowInfo = (WindowInfoHandle) GetWRefCon(theWindow);    if ((**myWindowInfo).theSG != nil)      SGIdle((**myWindowInfo).theSG);  }}long MyYieldTime(long message){  if ( message )    //  Resume message    return ( 0 );  else    //  Suspend message    return ( 30 );}void MyAdjustMenus(){  MenuHandle      mHandle;  WindowPtr      theWindow;  WindowInfoHandle  myWindowInfo;  short         i;    theWindow = FrontWindow();    myWindowInfo = (WindowInfoHandle) GetWRefCon(theWindow);  //  Allow only one window to be opened.  if ( theWindow != nil ) {  //  Yes, window open.    //  File menu.    mHandle = GetMHandle(kMENU_FILEID);    DisableItem(mHandle, kMENU_FILENEW);    EnableItem(mHandle, kMENU_FILECLOSE);        //  Settings menu.    mHandle = GetMHandle(kMENU_SETTINGSID);    EnableItem(mHandle, 0);    for ( i=0; i&lt;kMAXCHANNELS; i++ ) {      if (gSGInfo.channelType[i] != 0) {        if ( (**myWindowInfo).channel[i] != nil ) {          EnableItem(mHandle, i*2+1);          EnableItem(mHandle, i*2+2);        } else {          DisableItem(mHandle, i*2+1);          DisableItem(mHandle, i*2+2);        }      }    }    //  Resize menu.    mHandle = GetMHandle(kMENU_RESIZEID);    EnableItem(mHandle, 0);    //  Special menu.    mHandle = GetMHandle(kMENU_SPECIALID);    EnableItem(mHandle, 0);    CheckItem(mHandle, kMENU_SPECIALPLAYTHRU, (**myWindowInfo).recordPlayThru);    if ( !gHasQuickTime20 ) {      (**myWindowInfo).createSeparateFiles = false;      DisableItem(mHandle, kMENU_SPECIALSEPARATEFILES);    } else      EnableItem(mHandle, kMENU_SPECIALSEPARATEFILES);    CheckItem(mHandle, kMENU_SPECIALSEPARATEFILES, (**myWindowInfo).createSeparateFiles);      //  Record menu.    mHandle = GetMHandle(kMENU_RECORDID);    EnableItem(mHandle, 0);  } else {  //  No window open.    //  File menu.    mHandle = GetMHandle(kMENU_FILEID);    EnableItem(mHandle, kMENU_FILENEW);    DisableItem(mHandle, kMENU_FILECLOSE);    //  Settings menu.    mHandle = GetMHandle(kMENU_SETTINGSID);    DisableItem(mHandle, 0);    for ( i=0; i&lt;kMAXCHANNELS; i++ ) {      if (gSGInfo.channelType[i] != 0) {        EnableItem(mHandle, i*2);        EnableItem(mHandle, i*2+1);      }    }    //  Resize menu.    mHandle = GetMHandle(kMENU_RESIZEID);    DisableItem(mHandle, 0);    //  Special menu.    mHandle = GetMHandle(kMENU_SPECIALID);    DisableItem(mHandle, 0);    CheckItem(mHandle, kMENU_SPECIALPLAYTHRU, false);    CheckItem(mHandle, kMENU_SPECIALSEPARATEFILES, false);    //  Record menu.    mHandle = GetMHandle(kMENU_RECORDID);    DisableItem(mHandle, 0);  }    DrawMenuBar();}/* ------------------------------------------------------------------------- */void MyNew(){  long          err;  WindowPtr        myWindow;  Rect          myBounds = {42, 4, 282, 324};  WindowInfoHandle    myWindowInfo;  short          i, videoChannel, soundChannel;    myWindow = nil;  myWindowInfo = nil;    //  Create window along with window info record.  myWindow = NewCWindow(0L, &amp;myBounds, &quot;\pCapture window&quot;, 1, documentProc, (WindowPtr) -1, true, 0L);  if (myWindow == nil) {    ReportWarning(&quot;\pCould not create new window.&quot;,0);    goto bail;  }  SetGWorld((CGrafPtr) myWindow, GetMainDevice());  myWindowInfo = (WindowInfoHandle) NewHandleClear(sizeof(WindowInfo));  if ( myWindowInfo == nil ) {    ReportWarning(&quot;\pCould not create window info handle.&quot;, 0);    goto bail;  }  MoveHHi((Handle) myWindowInfo);  HLock((Handle) myWindowInfo);  SetWRefCon(myWindow, (long) myWindowInfo);  (**myWindowInfo).recordPlayThru = false;  (**myWindowInfo).createSeparateFiles = false;    //  Open sequence grabber and initialize the sequence grabber.  (**myWindowInfo).theSG = OpenDefaultComponent(SeqGrabComponentType, 0);  if ( (**myWindowInfo).theSG == nil) {    ReportWarning(&quot;\pOpenDefaultComponent failed to open default sequence grabber component.&quot;, 0);    goto bail;  }  err = SGInitialize((**myWindowInfo).theSG);  if ( err != noErr ) {    ReportWarning(&quot;\pCould not initialize sequence grabber: &quot;, err);    goto bail;  }    //  First things first, set the GWorld to the newly created window.  err = SGSetGWorld((**myWindowInfo).theSG, (CGrafPtr) myWindow, GetMainDevice());  if ( err != noErr ) {    ReportWarning(&quot;\pCould not SGSetGWorld: &quot;, err);    goto bail;  }    //  Now, let's create the different channels.  for ( i=0; i&lt;kMAXCHANNELS; i++ ) {    //  If the channel type exists, then create it.    if ( gSGInfo.channelType[i] != 0) {      //  Create channel.      err = SGNewChannel((**myWindowInfo).theSG, gSGInfo.channelType[i],                    &amp;((**myWindowInfo).channel[i]));      if ( err != noErr ) {        //  Fail with this channel.        ReportWarning(&quot;\pCould not open channel: &quot;, err);        (**myWindowInfo).channel[i] = 0;      } else {        //  Set the settings retrieved from preferences file.        if ( gSGInfo.channelSettings[i] != nil ) {          err = SGSetChannelSettings((**myWindowInfo).theSG, (**myWindowInfo).channel[i],                      gSGInfo.channelSettings[i], 0);          if ( err != noErr ) {            ReportWarning(&quot;\pFailed to set channel settings: &quot;, err);          }        } else {        //  Workaround for AV vdigs that don't initialize correctly.          err = SGGetChannelSettings((**myWindowInfo).theSG, (**myWindowInfo).channel[i],                      &amp;(gSGInfo.channelSettings[i]), 0);          if ( err != noErr ){            ReportWarning(&quot;\pCould not get channel settings: &quot;, err);            gSGInfo.channelSettings[i] = nil;          }          err = SGSetChannelSettings((**myWindowInfo).theSG, (**myWindowInfo).channel[i],                      gSGInfo.channelSettings[i], 0);          if ( err != noErr ) {            ReportWarning(&quot;\pFailed to set channel settings: &quot;, err);          }        }      }    } else      (**myWindowInfo).channel[i] = 0;  }    //  If there is a video channel, then set the compression settings.  for ( videoChannel = -1, i=0; i&lt;kMAXCHANNELS; i++ ) {    if ( gSGInfo.channelType[i] == VideoMediaType )      videoChannel = i;  }  if ( videoChannel &gt;= 0 ) {    err = SGSetVideoCompressorType((**myWindowInfo).channel[videoChannel], gSGInfo.cInfo.compressorType);    if ( err != noErr ) {      ReportWarning(&quot;\pCould not set video compressor type: &quot;, err);    }    err = SGSetVideoCompressor((**myWindowInfo).channel[videoChannel], gSGInfo.cInfo.depth, nil,            gSGInfo.cInfo.spatialQuality, gSGInfo.cInfo.temporalQuality, gSGInfo.cInfo.keyFrameRate);    if ( err != noErr ) {      ReportWarning(&quot;\pCould not set video compressor info: &quot;, err);    }  }    //  Update the channels.  err = MyUpdateChannels(myWindow);  if ( err != noErr ) {    ReportWarning(&quot;\pCould not update channels: &quot;, err);    goto bail;  }    //  Start the preview now that everything is set up!!!  err = SGStartPreview((**myWindowInfo).theSG);  if ( err != noErr ) {    ReportWarning(&quot;\pCould not start preview.&quot;, err);    goto bail;  }    return;bail:  SysBeep(50);  if ( (**myWindowInfo).theSG != nil )    CloseComponent((**myWindowInfo).theSG);  if ( myWindowInfo != nil )    DisposHandle((Handle) myWindowInfo);  if ( myWindow != nil )    DisposeWindow(myWindow);  return;}void MyClose(){  long        err;  WindowPtr      closeWindow;  WindowInfoHandle    myWindowInfo;  short        i, videoChannel;    closeWindow = FrontWindow();  if ( closeWindow == nil )    return;  myWindowInfo = (WindowInfoHandle) GetWRefCon(closeWindow);  //  If there is a video channel, then get the compression settings.  for ( videoChannel = -1, i=0; i&lt;kMAXCHANNELS; i++ ) {    if ( gSGInfo.channelType[i] == VideoMediaType )      videoChannel = i;  }  if ( videoChannel &gt;= 0 ) {    err = SGGetVideoCompressorType((**myWindowInfo).channel[videoChannel], &amp;gSGInfo.cInfo.compressorType);    if ( err != noErr )      gSGInfo.cInfo.compressorType = 'raw ';    err = SGGetVideoCompressor((**myWindowInfo).channel[videoChannel], &amp;gSGInfo.cInfo.depth, nil,            &amp;gSGInfo.cInfo.spatialQuality, &amp;gSGInfo.cInfo.temporalQuality,            &amp;gSGInfo.cInfo.keyFrameRate);    if ( err != noErr ) {      gSGInfo.cInfo.depth = 16;      gSGInfo.cInfo.spatialQuality = codecLosslessQuality;      gSGInfo.cInfo.temporalQuality = 0;      gSGInfo.cInfo.keyFrameRate = 0;    }  }    //  Get the video settings.  for ( i=0; i&lt;kMAXCHANNELS; i++ ) {      //  Set the video settings retrieved from preferences file.    if ( gSGInfo.channelType[i] != 0 &amp;&amp; (**myWindowInfo).channel[i] != 0) {      err = SGGetChannelSettings((**myWindowInfo).theSG, (**myWindowInfo).channel[i],                  &amp;(gSGInfo.channelSettings[i]), 0);      if ( err != noErr ){        ReportWarning(&quot;\pCould not get channel settings: &quot;, err);        gSGInfo.channelSettings[i] = nil;      }    }  }      //  Close the component.   if ( (**myWindowInfo).theSG != nil )    CloseComponent((**myWindowInfo).theSG);    if ( myWindowInfo != nil )    DisposHandle((Handle) myWindowInfo);    DisposeWindow(closeWindow);}/* ------------------------------------------------------------------------- */void MySettings(short item){  long      err;  WindowPtr    theWindow;  short      index;    theWindow = FrontWindow();    //  Allow only one window to be opened.  if ( theWindow != nil ) {  //  Yes, window open.    WindowInfoHandle  myWindowInfo;        myWindowInfo = (WindowInfoHandle) GetWRefCon(theWindow);        index = (item - 1) / 2;    if ( (item &amp; 1) == 0 ) {      //  Pause before making changes.      err = SGPause((**myWindowInfo).theSG, true);      if ( err != noErr ) {        ReportWarning(&quot;\pCould not pause preview: &quot;, err);      }      //  Disable channel.      if ( (**myWindowInfo).channel[index] != 0 ) {        SGDisposeChannel((**myWindowInfo).theSG, (**myWindowInfo).channel[index]);        (**myWindowInfo).channel[index] = 0;      }            err = SGPause((**myWindowInfo).theSG, false);      if ( err != noErr ) {        ReportWarning(&quot;\pCould not pause preview: &quot;, err);      }    } else {      //  Simply call SGSettingsDialog!  That simple!      SGSettingsDialog((**myWindowInfo).theSG, (**myWindowInfo).channel[index], 0, nil, DoTheRightThing, nil , 0);    }  }}void MyResize(short item){  WindowPtr    theWindow;  long      err;  Boolean      sizeChanged;  short      width, height;    theWindow = FrontWindow();    //  Allow only one window to be opened.  if ( theWindow != nil ) {  //  Yes, window open.    WindowInfoHandle  myWindowInfo;        myWindowInfo = (WindowInfoHandle) GetWRefCon(theWindow);    sizeChanged = false;    switch ( item ) {      case 1:        width = 160; height = 120;        sizeChanged = true;        break;      case 2:        width = 240; height = 180;        sizeChanged = true;        break;      case 3:        width = 320; height = 240;        sizeChanged = true;        break;      case 5:        sizeChanged = GetCustomSize(&amp;width, &amp;height);        break;    }    if ( sizeChanged ) {      //  Pause the sequence grabber before resizing window.      err = SGPause((**myWindowInfo).theSG, true);      if ( err != noErr ) {        ReportWarning(&quot;\pCould not pause preview: &quot;, err);      }            //  Resize and then update the video channel.      SizeWindow(theWindow, width, height, false);      err = MyUpdateChannels(theWindow);      if ( err != noErr ) {        ReportWarning(&quot;\pCould not update channels: &quot;, err);      }            //  OK.  We can restart again.      err = SGPause((**myWindowInfo).theSG, false);      if ( err != noErr ) {        ReportWarning(&quot;\pCould not pause preview: &quot;, err);      }    }  }  }void MySpecial(short item){  WindowPtr    theWindow;  long      err;  Boolean      updateFlag;    theWindow = FrontWindow();    //  Allow only one window to be opened.  if ( theWindow != nil ) {  //  Yes, window open.    WindowInfoHandle  myWindowInfo;        myWindowInfo = (WindowInfoHandle) GetWRefCon(theWindow);    updateFlag = false;    switch ( item ) {      case kMENU_SPECIALPLAYTHRU:        (**myWindowInfo).recordPlayThru = !(**myWindowInfo).recordPlayThru;        updateFlag = true;        break;      case kMENU_SPECIALSEPARATEFILES:        (**myWindowInfo).createSeparateFiles = !(**myWindowInfo).createSeparateFiles;        break;    }        //  Only update if needed.    if ( updateFlag ) {      //  Pause before changes.      err = SGPause((**myWindowInfo).theSG, true);      if ( err != noErr ) {        ReportWarning(&quot;\pCould not pause preview: &quot;, err);      }            //  Update the channels.      err = MyUpdateChannels(theWindow);      if ( err != noErr ) {        ReportWarning(&quot;\pCould not update channels: &quot;, err);      }            //  OK to continue.      err = SGPause((**myWindowInfo).theSG, false);      if ( err != noErr ) {        ReportWarning(&quot;\pCould not pause preview: &quot;, err);      }    }  }}void MyRecord(){  WindowPtr      theWindow;  long        err;  StandardFileReply  reply;  ComponentInstance  mySG;  AliasHandle      alias;  SGOutput      output;  short        i;    theWindow = FrontWindow();    //  Allow only one window to be opened.  if ( theWindow != nil ) {  //  Yes, window open.    WindowInfoHandle  myWindowInfo;        myWindowInfo = (WindowInfoHandle) GetWRefCon(theWindow);    mySG = (**myWindowInfo).theSG;    if ( mySG != nil ) {            if ( (**myWindowInfo).createSeparateFiles ) {        for ( i=0; i&lt;kMAXCHANNELS; i++ ) {          if ( (**myWindowInfo).channel[i] != 0) {            StandardPutFile(&quot;\PName of multiple file:&quot;, &quot;\pMovie #&quot;, &amp;reply);            if (!reply.sfGood)              return;            err = CreateMovieFile(&amp;(reply.sfFile), 'TVOD', smSystemScript,              createMovieFileDeleteCurFile |              createMovieFileDontCreateMovie |              createMovieFileDontOpenFile, nil, nil);            if ( err != noErr ) {              ReportWarning(&quot;\pCould not create movie file 1: &quot;, err);              goto bail;            }            NewAlias(nil, &amp;(reply.sfFile), &amp;alias);            if ( alias == nil )              return;            err = SGSetDataRef(mySG, (Handle) alias, 'alis', seqGrabToDisk);            if ( err != noErr ) {              ReportWarning(&quot;\pCould not set movie resource output: &quot;, err);              goto bail;            }            err = SGNewOutput(mySG, (Handle) alias, 'alis', seqGrabToDisk, &amp;output);            if ( err != noErr ) {              ReportWarning(&quot;\pCould not create data output1: &quot;, err);              goto bail;            }            err = SGSetChannelOutput(mySG, (**myWindowInfo).channel[i], output);            if ( err != noErr ) {              ReportWarning(&quot;\pCould not set video channel output: &quot;, err);              goto bail;            }          }        }      } else {        //  If creating single file, then do this.        StandardPutFile(&quot;\PName of new movie:&quot;, &quot;\pMovie&quot;, &amp;reply);        if (!reply.sfGood)          return;        err = SGSetDataOutput(mySG, &amp;reply.sfFile, seqGrabToDisk);        if ( err != noErr ) {          ReportWarning(&quot;\pCould not set data output: &quot;, err);          goto bail;        }      }      //  Set the window title so that the user knows that we are recording.      SetWTitle(theWindow, &quot;\pRecording... click mouse to stop.&quot;);      //  Start recording.      err = SGStartRecord(mySG);      if ( err != noErr ) {        ReportWarning(&quot;\pCould not start recording.  The following error was returned: &quot;, err);      }            //  Keep recording until the mouse button is pressed.      while (!Button() &amp;&amp; !err) {        err = SGIdle(mySG);      }            //  Stop recording.      err = SGStop(mySG);      if ( err != noErr ) {        ReportWarning(&quot;\pCould not stop sequence grabber: &quot;, err);        goto bail;      } else        SetWTitle(theWindow, &quot;\pMovie captured.&quot;);      //  Start preview again.  err = MyUpdateChannels(theWindow);  if ( err != noErr ) {    ReportWarning(&quot;\pCould not update channels: &quot;, err);    goto bail;  }        err = SGStartPreview((**myWindowInfo).theSG);      if ( err != noErr ) {        ReportWarning(&quot;\pCould not start preview: &quot;, err);        goto bail;      }            //  Reset the window title.      SetWTitle(theWindow, &quot;\pCapture window&quot;);      FlushEvents(mDownMask | mUpMask, 0);    }  }  bail:  return;}void MyDrag(WindowPtr theWindow, Point where){  long      err;  //  Allow only one window to be opened.  if ( theWindow != nil ) {  //  Yes, window open.    WindowInfoHandle  myWindowInfo;        myWindowInfo = (WindowInfoHandle) GetWRefCon(theWindow);    if ((**myWindowInfo).theSG != nil)      //  Pause preview.      err = SGPause((**myWindowInfo).theSG, true);      if ( err != noErr ) {        ReportWarning(&quot;\pCould no pause preview: &quot;, err);      }            //  Drag window.      DragWindow (theWindow, where, &amp;qd.screenBits.bounds);            //  OK to restart preview.      err = SGPause((**myWindowInfo).theSG, false);      if ( err != noErr ) {        ReportWarning(&quot;\pCould not pause preview: &quot;, err);      }  }}void MyUpdate(WindowPtr theWindow){  long      err;  //  Allow only one window to be opened.  if ( theWindow != nil ) {  //  Yes, window open.    WindowInfoHandle  myWindowInfo;        myWindowInfo = (WindowInfoHandle) GetWRefCon(theWindow);    if ((**myWindowInfo).theSG != nil)      //  Pause and continue to reset clip.      err = SGPause((**myWindowInfo).theSG, true);      if ( err != noErr ) {        ReportWarning(&quot;\pCould not pause preview: &quot;, err);      }      err = SGPause((**myWindowInfo).theSG, false);      if ( err != noErr ) {        ReportWarning(&quot;\pCould not pause preview: &quot;, err);      }  }}long MyUpdateChannels(WindowPtr theWindow){  long        err;  WindowInfoHandle  myWindowInfo;  long        usage;  short        i, videoChannel;  err = noErr;  myWindowInfo = (WindowInfoHandle) GetWRefCon(theWindow);    //  Update the video channel if it exists.  for ( videoChannel = -1, i=0; i&lt;kMAXCHANNELS; i++ ) {    if ( gSGInfo.channelType[i] == VideoMediaType )      videoChannel = i;  }  if ( videoChannel &gt;= 0 ) {    //  Set the bounds to the entire portRect.    err = SGSetChannelBounds((**myWindowInfo).channel[videoChannel], &amp;(theWindow-&gt;portRect));    if ( err != noErr )      goto bail;          //  Set the video usage depending on whether or not there is playthru.    usage = seqGrabPreview | seqGrabRecord;    if ( !((**myWindowInfo).recordPlayThru) )      usage |= seqGrabPlayDuringRecord;    err = SGSetChannelUsage((**myWindowInfo).channel[videoChannel], usage);    if ( err != noErr )      goto bail;  }  for ( i=0; i&lt;kMAXCHANNELS; i++ ) {  //  Since sound may be turned off, check before setting sound usage.    if ( (gSGInfo.channelType[i] != VideoMediaType &amp;&amp; gSGInfo.channelType[i] != 0) &amp;&amp;        (**myWindowInfo).channel[i] != 0) {      err = SGSetChannelUsage((**myWindowInfo).channel[i], seqGrabPreview | seqGrabRecord |  seqGrabPlayDuringRecord);      if ( err != noErr )        goto bail;    }  }  bail:  return ( err );}/* ------------------------------------------------------------------------- */Boolean GetCustomSize(short *width, short *height){  GrafPtr    savePort;  GDHandle  saveGD;  DialogPtr  theDialog;  short    itemHit;  Str255    myStr;  Boolean    done, ret;  long    lWidth, lHeight;    GetPort(&amp;savePort);  saveGD = GetGDevice();  theDialog = GetNewDialog(130, nil, (WindowPtr) -1);  SetPort(theDialog);  SetGDevice(GetMainDevice());    //  Reset data to begin.  SetText(theDialog, 4, &quot;\p640&quot;);  SetText(theDialog, 6, &quot;\p480&quot;);  //  Get membershipid and each inventory id  done = false;  do {    ModalDialog(nil, &amp;itemHit);    GetText(theDialog, 4, myStr);    StringToNum(myStr, &amp;lWidth);    GetText(theDialog, 6, myStr);    StringToNum(myStr, &amp;lHeight);    if (itemHit == 1 ) {      if (lWidth &gt; 0 &amp;&amp; lWidth &lt;= 640 &amp;&amp; lHeight &gt;= 0 &amp;&amp; lHeight &lt;= 480)        done = true;      else        SysBeep(50);    }  } while ((!done) &amp;&amp; (itemHit != 2));  if ( itemHit == 1 ) {    GetText(theDialog, 4, myStr);    StringToNum(myStr, &amp;lWidth);    *width = lWidth;    GetText(theDialog, 6, myStr);    StringToNum(myStr, &amp;lHeight);    *height = lHeight;    ret = true;  } else {    ret = false;  }  DisposeDialog(theDialog);  SetPort(savePort);  SetGDevice(saveGD);    return ( ret );}/* ------------------------------------------------------------------------- */void GetText(DialogPtr theDialog, short item, Str255 myStr){  Handle    myHandle;  Rect    myRect;  short    myType;  GetDItem(theDialog, item, &amp;myType, &amp;myHandle, &amp;myRect);  GetIText(myHandle, myStr);}void SetText(DialogPtr theDialog, short item, Str255 myStr){  Handle    myHandle;  Rect    myRect;  short    myType;  GetDItem(theDialog, item, &amp;myType, &amp;myHandle, &amp;myRect);  SetIText(myHandle, myStr);}</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/MyCaptureApp/listing4.html%3Fid%3DDTS10000327-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/MyCaptureApp/listing4.html%3Fid%3DDTS10000327-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/MyCaptureApp/listing4.html%3Fid%3DDTS10000327-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>