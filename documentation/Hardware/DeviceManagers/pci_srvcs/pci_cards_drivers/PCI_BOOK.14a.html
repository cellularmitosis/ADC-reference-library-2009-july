<HTML><HEAD><META NAME="GENERATOR" CONTENT="Adobe FrameMaker 5.5/HTML Export Filter"><script language="JavaScript" src="frametest.js"></script><TITLE> PrepareMemoryForIO Data Structures</TITLE></HEAD><BODY BGCOLOR="#ffffff"><DIV><a name="top"></a><!-- start of banner --><!--#include virtual="/includes/framesetheader" --><!-- end of banner --><!-- start of path --><font face="Geneva,Helvetica,Arial" size="1"><b><br>PATH<spacer type="horizontal" size="5">&nbsp;</b><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Documentation</a> &gt; <!-- a href="" target="_top" -->Hardware<!-- /a -->  <b>&gt; </b><a href="../../devicemgrs.html" target="_top">Device Managers and Drivers</a> <b>&gt; </b><a href="../pci_srvcs.html" target="_top">PCI Card Services</a> <b>&gt; </b>Designing PCI Cards and Drivers for Power Macintosh Computers</font><br><br><!-- end of path --><A HREF="PCI_BOOK.149.html"><img src="images/up.gif" border="0" width="36" height="16"></A><nobr>&nbsp;</nobr><A HREF="PCI_BOOK.149.html"><img src="images/previous.gif" border="0" width="66" height="16"></A><nobr>&nbsp;</nobr><A HREF="PCI_BOOK.14b.html"><img src="images/next.gif" border="0" width="49" height="16"></A><!-- insert Show/Hide frames --><a href="javascript:testFrame()"><script><!--document.write(frameLink);//--></script><!-- end Show/Hide frames --></A><HR></DIV><H1 CLASS="H3.Heading3"><A NAME="pgfId=3433"> </A><A NAME="31391"> </A>PrepareMemoryForIO Data Structures</H1><P CLASS="T1.Text1"><A NAME="pgfId=3434"> </A>The <TT CLASS="cv">PrepareMemoryForIO</TT> function has a single parameter, a pointer to an <TT CLASS="cv">IOPreparationTable</TT> structure.</P><P CLASS="T1.Text1"><A NAME="pgfId=3435"> </A>Some fields of the <TT CLASS="cv">IOPreparationTable</TT> structure contain pointers to subsidiary structures. There are three types of subsidiary structures:</P><UL><LI CLASS="B1.Bullet1"><A NAME="pgfId=3436"> </A>A <TT CLASS="cv">LogicalMappingTablePtr</TT> value is a pointer to an array of <TT CLASS="cv">LogicalAddress</TT> values. The <TT CLASS="cv">LogicalAddress</TT> table is where <TT CLASS="cv">PrepareMemoryForIO</TT> returns the static logical addresses the driver can use to logically access the client buffer:</LI></UL><CODE CLASS="Cv.Code"><A NAME="pgfId=18599"> </A>&nbsp;&nbsp;&nbsp;&nbsp;typedef LogicalAddress *LogicalMappingTablePtr;</CODE><UL><LI CLASS="B1.Bullet1"><A NAME="pgfId=3438"> </A>A <TT CLASS="cv">PhysicalMappingTablePtr</TT> value is a pointer to an array of <TT CLASS="cv">PhysicalAddress</TT> values. The <TT CLASS="cv">PhysicalAddress</TT> table is where <TT CLASS="cv">PrepareMemoryForIO</TT> returns the physical addresses the driver can use to access the client buffer physically:</LI></UL><CODE CLASS="Cv.Code"><A NAME="pgfId=18603"> </A>&nbsp;&nbsp;&nbsp;&nbsp;typedef PhysicalAddress *PhysicalMappingTablePtr;</CODE><UL><LI CLASS="B1.Bullet1"><A NAME="pgfId=3440"> </A>An <TT CLASS="cv">AddressRangeTablePtr</TT> value is a pointer to an array of <TT CLASS="cv">AddressRange</TT> specifications. All ranges in a given <TT CLASS="cv">AddressRange</TT> array are of the same kind, either all logical or all physical. The <TT CLASS="cv">AddressRange</TT> table is where the driver can specify a user buffer that consists of multiple ranges (that is, a scatter-gather buffer as described in <A HREF="PCI_BOOK.150.html#20214" CLASS="XRef">Scatter-Gather Client Buffers</A>:</LI></UL><CODE CLASS="Cv.Code"><A NAME="pgfId=18607"> </A>&nbsp;&nbsp;&nbsp;&nbsp;typedef struct AddressRange *AddressRangeTablePtr;</CODE><P CLASS="T1.Text1"><A NAME="pgfId=3446"> </A>The <A NAME="&lt;cv&gt;IOPreparationTable&lt;n&gt; data structure"> </A><TT CLASS="cv">IOPreparationTable</TT> structure and its subsidiary structures are diagrammed in <A HREF="PCI_BOOK.14a.html#21499" CLASS="XRef">Figure&nbsp;11-1</A>. </P><DIV><blockquote><H4 CLASS="NoteHead"><A NAME="pgfId=18609"> </A>Note</H4><P CLASS="Note"><A NAME="pgfId=3453"> </A>In <A HREF="PCI_BOOK.14a.html#21499" CLASS="XRef">Figure&nbsp;11-1</A>, gray areas are filled in by the <TT CLASS="cv">PrepareMemoryForIO</TT> function and white areas are filled in by the calling software. The <TT CLASS="cv">preparationID</TT> field is used both ways. </P> </blockquote><P CLASS="T1.Text1"><A NAME="pgfId=3457"> </A>The <TT CLASS="cv">IOPreparationTable</TT> structure is defined as follows:</P><CODE CLASS="Cv.Code"><A NAME="pgfId=18613"> </A>struct IOPreparationTable<BR>{<BR>&nbsp;&nbsp;&nbsp;&nbsp;IOPreparationOptions&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;options;<BR>&nbsp;&nbsp;&nbsp;&nbsp;IOPreparationState&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;state;<BR>&nbsp;&nbsp;&nbsp;&nbsp;IOPreparationID&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;preparationID;<BR>&nbsp;&nbsp;&nbsp;&nbsp;AddressSpaceID&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;addressSpace;<BR>&nbsp;&nbsp;&nbsp;&nbsp;ByteCount&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;granularity;<BR>&nbsp;&nbsp;&nbsp;&nbsp;ByteCount&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;firstPrepared;<BR>&nbsp;&nbsp;&nbsp;&nbsp;ByteCount&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lengthPrepared;<BR>&nbsp;&nbsp;&nbsp;&nbsp;ItemCount&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mappingEntryCount;<BR>&nbsp;&nbsp;&nbsp;&nbsp;LogicalMappingTablePtr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;logicalMapping;<BR>&nbsp;&nbsp;&nbsp;&nbsp;PhysicalMappingTablePtr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;physicalMapping;<BR>&nbsp;&nbsp;&nbsp;&nbsp;union<BR>&nbsp;&nbsp;&nbsp;&nbsp;{<BR>&nbsp;&nbsp;&nbsp;&nbsp;AddressRange&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;range;<BR>&nbsp;&nbsp;&nbsp;&nbsp;MultipleAddressRange&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;multipleRanges;<BR>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rangeInfo;<BR>};</CODE><br><CODE CLASS="Cv.Code"><A NAME="pgfId=18619"> </A>typedef struct IOPreparationTable IOPreparationTable;</CODE><br><CODE CLASS="Cv.Code"><A NAME="pgfId=18625"> </A>typedef OptionBits IOPreparationOptions;<BR>enum {<BR>&nbsp;&nbsp;&nbsp;&nbsp;kIOMultipleRanges&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= 0x00000001,<BR>&nbsp;&nbsp;&nbsp;&nbsp;kIOLogicalRanges&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= 0x00000002,<BR>&nbsp;&nbsp;&nbsp;&nbsp;kIOMinimalLogicalMapping&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= 0x00000004,<BR>&nbsp;&nbsp;&nbsp;&nbsp;kIOShareMappingTables&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= 0x00000008,<BR>&nbsp;&nbsp;&nbsp;&nbsp;kIOIsInput&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= 0x00000010,<BR>&nbsp;&nbsp;&nbsp;&nbsp;kIOIsOutput&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= 0x00000020,<BR>&nbsp;&nbsp;&nbsp;&nbsp;kIOCoherentDataPath&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= 0x00000040,<BR>&nbsp;&nbsp;&nbsp;&nbsp;kIOClientIsUserMode&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= 0x00000080<BR>};</CODE><P CLASS="Fg.Figure"><B><A NAME="pgfId=3466"> </A>Figure&nbsp;11-1	<TT CLASS="cv">IOPreparationTable</TT><A NAME="34418"> </A><A NAME="21499"> </A> structure</B></P><DIV><IMG SRC="PCI_BOOK-26.gif"></DIV><br><CODE CLASS="Cv.Code"><A NAME="pgfId=18631"> </A>typedef OptionBits IOPreparationState;<BR>enum {<BR>&nbsp;&nbsp;&nbsp;&nbsp;kIOStateDone&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= 0x00000001<BR>};</CODE><br><CODE CLASS="Cv.Code"><A NAME="pgfId=18635"> </A>typedef struct MultipleAddressRange MultipleAddressRange;</CODE><br><CODE CLASS="Cv.Code"><A NAME="pgfId=18639"> </A>struct MultipleAddressRange<BR>{<BR>&nbsp;&nbsp;&nbsp;&nbsp;ItemCount&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;entryCount;<BR>&nbsp;&nbsp;&nbsp;&nbsp;AddressRangeTablePtr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rangeTable;<BR>};</CODE><P CLASS="T1.Text1"><A NAME="pgfId=3470"> </A>The <TT CLASS="cv">IOPreparationTable</TT> structure specifies the buffer to be prepared and provides storage for the mapping and other information that are returned. Its fields contain the following information:</P><DL COMPACT><DT CLASS="DT.DefinitionTerm"><A NAME="pgfId=18641"> </A><TT CLASS="cv">options</TT></DT><DD CLASS="DD.DefinitionDef"><A NAME="pgfId=3471"> </A>Optional characteristics of the <TT CLASS="cv">IOPreparationTable</TT> structure and the transfer process. Possible values in this field are discussed in <A HREF="PCI_BOOK.14b.html#35630" CLASS="XRef">IOPreparationTable Options</A>.</DD><DT CLASS="DT.DefinitionTerm"><A NAME="pgfId=18650"> </A><TT CLASS="cv">state</TT></DT><DD CLASS="DD.DefinitionDef"><A NAME="pgfId=3475"> </A>Filled in by <TT CLASS="cv">PrepareMemoryForIO</TT> to indicate the state of the <TT CLASS="cv">IOPreparationTable</TT> structure. The <TT CLASS="cv">kIOStateDone</TT> flag indicates that the buffer has been prepared up to the end of the specified range. See <A HREF="PCI_BOOK.155.html#28479" CLASS="XRef">Partial Preparation</A>.</DD><DT CLASS="DT.DefinitionTerm"><A NAME="pgfId=18659"> </A><TT CLASS="cv">preparationID</TT></DT><DD CLASS="DD.DefinitionDef"><A NAME="pgfId=6728"> </A>Filled in by <TT CLASS="cv">PrepareMemoryForIO</TT> to indicate the identifier that represents the I/O transaction. When the I/O operation is completed or abandoned, the <TT CLASS="cv">IOPreparationID</TT> value is used to finish the transaction, as described in <A HREF="PCI_BOOK.156.html#22447" CLASS="XRef">Finishing I/O Transactions</A>.</DD><DT CLASS="DT.DefinitionTerm"><A NAME="pgfId=18671"> </A><TT CLASS="cv">addressSpace</TT><A NAME="15671"> </A></DT><DD CLASS="DD.DefinitionDef"><A NAME="pgfId=6733"> </A>The address space containing the buffer to be prepared. Current versions of the Mac&nbsp;OS provide only one address space, which it automatically passes to native drivers through <TT CLASS="cv">DoDriverIO</TT>. In general, a driver should always pass the address space it received as a parameter to its <TT CLASS="cv">DoDriverIO</TT> routine in this field. Otherwise, this field must be specified as <TT CLASS="cv">kCurrentAddressSpaceID</TT>.</DD><DT CLASS="DT.DefinitionTerm"><A NAME="pgfId=18681"> </A><TT CLASS="cv">granularity</TT></DT><DD CLASS="DD.DefinitionDef"><A NAME="pgfId=3485"> </A>Information to reduce the memory usage of partial preparations. See <A HREF="PCI_BOOK.155.html#28479" CLASS="XRef">Partial Preparation</A>.</DD><DT CLASS="DT.DefinitionTerm"><A NAME="pgfId=18690"> </A><TT CLASS="cv">firstPrepared</TT></DT><DD CLASS="DD.DefinitionDef"><A NAME="pgfId=3489"> </A>The byte offset into the buffer at which to begin preparation. See <A HREF="PCI_BOOK.155.html#28479" CLASS="XRef">Partial Preparation</A>.</DD><DT CLASS="DT.DefinitionTerm"><A NAME="pgfId=18699"> </A><TT CLASS="cv">lengthPrepared</TT></DT><DD CLASS="DD.DefinitionDef"><A NAME="pgfId=3493"> </A>Filled in by <TT CLASS="cv">PrepareMemoryForIO</TT> to indicate how much of the buffer was successfully prepared, beginning at <TT CLASS="cv">firstPrepared</TT>. See <A HREF="PCI_BOOK.155.html#28479" CLASS="XRef">Partial Preparation</A>.</DD><DT CLASS="DT.DefinitionTerm"><A NAME="pgfId=18708"> </A><TT CLASS="cv">mappingEntryCount</TT></DT><DD CLASS="DD.DefinitionDef"><A NAME="pgfId=3497"> </A>Number of entries in the logical and physical mapping tables supplied. Normally, the driver should allocate as many entries as there are pages in the buffer. The number of pages in a memory range can be calculated from the range's base address and length. If there are not enough entries, a partial preparation is performed within the limit of the tables. See <A HREF="PCI_BOOK.155.html#28479" CLASS="XRef">Partial Preparation</A>.</DD><DT CLASS="DT.DefinitionTerm"><A NAME="pgfId=18717"> </A><TT CLASS="cv">logicalMapping</TT></DT><DD CLASS="DD.DefinitionDef"><A NAME="pgfId=3501"> </A>The address of an array of <TT CLASS="cv">LogicalAddress</TT> values. <TT CLASS="cv">PrepareMemoryForIO</TT> fills the logical mapping table with the static logical mappings for the specified buffer. This table is optional. Mapping tables are discussed in <A HREF="PCI_BOOK.14f.html#22513" CLASS="XRef">Mapping Tables</A>.</DD><DT CLASS="DT.DefinitionTerm"><A NAME="pgfId=18726"> </A><TT CLASS="cv">physicalMapping</TT></DT><DD CLASS="DD.DefinitionDef"><A NAME="pgfId=3505"> </A>The address of an array of <TT CLASS="cv">PhysicalAddress</TT> values. <TT CLASS="cv">PrepareMemoryForIO</TT> fills the physical mapping table with the physical addresses corresponding to the specified buffer. This table is optional. Mapping tables are discussed in <A HREF="PCI_BOOK.14f.html#22513" CLASS="XRef">Mapping Tables</A>.</DD><DT CLASS="DT.DefinitionTerm"><A NAME="pgfId=18735"> </A><TT CLASS="cv">rangeInfo</TT></DT><DD CLASS="DD.DefinitionDef"><A NAME="pgfId=3509"> </A>The buffer to prepare. A simple buffer is represented by a single <TT CLASS="cv">AddressRange</TT> value. A scatter-gather buffer is specified by a <TT CLASS="cv">MultipleAddressRange</TT> structure. If the <TT CLASS="cv">kIOMultipleRanges</TT> flag is omitted from <TT CLASS="cv">options</TT>, <TT CLASS="cv">rangeInfo</TT> is interpreted as an <TT CLASS="cv">AddressRange</TT> value named <TT CLASS="cv">range</TT>. If <TT CLASS="cv">kIOMultipleRanges</TT> is specified in <TT CLASS="cv">options</TT>, <TT CLASS="cv">rangeInfo</TT> is interpreted as a <TT CLASS="cv">MultipleAddressRange</TT> structure named <TT CLASS="cv">multipleRanges</TT>. Scatter-gather buffers are discussed in <A HREF="PCI_BOOK.150.html#20214" CLASS="XRef">Scatter-Gather Client Buffers</A>. Because there might be insufficient resources to prepare the entire buffer, the buffer can be prepared in pieces. This procedure is discussed in <A HREF="PCI_BOOK.155.html#28479" CLASS="XRef">Partial Preparation</A>.</DD></DL COMPACT></DIV><HR>&#169 1999 Apple Computer, Inc. &#150 (Last Updated 26 March 99)<P><A HREF="PCI_BOOK.149.html"><img src="images/up.gif" border="0" width="36" height="16"></A><nobr>&nbsp;</nobr><A HREF="PCI_BOOK.149.html"><img src="images/previous.gif" border="0" width="66" height="16"></A><nobr>&nbsp;</nobr><A HREF="PCI_BOOK.14b.html"><img src="images/next.gif" border="0" width="49" height="16"></A><!-- insert Show/Hide frames --><a href="javascript:testFrame()"><script><!--document.write(frameLink);//--></script><!-- end Show/Hide frames --></A><!-- start of footer --><!--#include virtual="/includes/framesetfooter" --><!-- end of footer --></body></HTML>