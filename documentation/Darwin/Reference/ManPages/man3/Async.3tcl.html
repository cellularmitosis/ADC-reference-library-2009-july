<html><head><title>Mac OS X
 Manual Page For Async(3tcl)</title>
<style type="text/css"><!-- @import "../../../../adcstyle.css"; .char {background: #ffffff; color:#0000ff;}.comment {background:#ffffff; color:#236e25}.function {background:#ffffff; color:#000000;}.keyword {background:#ffffff; color:#761550;}.number {background: #ffffff; color:#0000ff;}.param {background:#ffffff; color:#000000;}.preprocessor {background:#ffffff; color:#236e25}.string {background: #ffffff; color:#891315;}.template {background:#ffffff; color:#761550;}.type {background:#ffffff; color:#761550;}.var {background:#ffffff; color:#000000;} pre.manpages {font-size: 10pt;} .graybox { border-top: 1px solid #919699; border-left: 1px solid #919699; margin-bottom: 10px; } .graybox th { padding: 4px 8px 4px 8px; background: #E2E2E2; font-size: 12px; font-weight: bold; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .graybox td { padding: 8px; font-size: 12px; text-align: left; vertical-align: top; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .whiteout { font-size: 1px; background: #ffffff; color: #ffffff; } --></style>
<style type="text/css" media="print, aural, braille, embossed, projection, tty"><!-- @import "../../../../adcstyle.css"; .char {background: #ffffff; color:#0000ff;}.comment {background:#ffffff; color:#236e25}.function {background:#ffffff; color:#000000;}.keyword {background:#ffffff; color:#761550;}.number {background: #ffffff; color:#0000ff;}.param {background:#ffffff; color:#000000;}.preprocessor {background:#ffffff; color:#236e25}.string {background: #ffffff; color:#891315;}.template {background:#ffffff; color:#761550;}.type {background:#ffffff; color:#761550;}.var {background:#ffffff; color:#000000;} pre.manpages {font-size: 10pt;} .graybox { border-top: 1px solid #919699; border-left: 1px solid #919699; margin-bottom: 10px; } .graybox th { padding: 4px 8px 4px 8px; background: #E2E2E2; font-size: 12px; font-weight: bold; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .graybox td { padding: 8px; font-size: 12px; text-align: left; vertical-align: top; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .whiteout { display: none; } --></style>
</head><body bgcolor="white">
<a name="//apple_ref/doc/man/3tcl/Async" title="Mac OS X
 Manual Page for Async(3tcl)"><a name="//apple_ref/doc/man/3/Async" title="Mac OS X
 Manual Page for Async(3tcl)"><!-- headerDoc=man; indexgroup=Section 3tcl; uid="//apple_ref/doc/man/3tcl/Async"; name=Async(3tcl) --></a>
<!--#include virtual="/includes/framesetheader"-->
<table width=600><tr><td scope="row">
<!-- begin breadcrumb insert request --><font face="Geneva,Helvetica,Arial" size="1">
 <a target="_top" href="http://developer.apple.com">ADC Home</a> <b>&gt;</b> <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> <b>&gt;</b> <a href="../../../../../reference/index.html#//apple_ref/doc/uid/TP30001281" target="_top">Reference</a> <b>&gt;</b> <!-- a href="" target="_top" -->Mac OS X<!-- /a --> <b>&gt;</b> <a href="../index.html#//apple_ref/doc/framework/manpages" target="_top">Mac OS X Man Pages</a></font>
<!-- end breadcrumb insert request -->
<p>&nbsp;</p>
</td></tr></table>
<!-- end of header -->
<table border="0"  cellpadding="2" cellspacing="2" width="630pt"><tr><td valign="top" height="12" colspan="5" scope="row">
<p style='text-align:justify;'>This document is a Mac OS X manual page.  Manual pages are a command-line technology
for providing documentation.  You can view these manual pages locally using the
<a href="../man1/man.1.html#//apple_ref/doc/man/1/man">man(1)</a> command.
These manual pages come from many different sources, and thus, have a variety of writing
styles.</p>
<p style='text-align:justify;'>For more information about the manual page format, see the manual page for 
<a href="../man5/manpages.5.html#//apple_ref/doc/man/5/manpages">manpages(5)</a>.</p>
</td></tr></table>
<hr />
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row"><pre class="manpages"><tt>
Tcl_AsyncCreate(3)                         Tcl Library Procedures                         <a href="Tcl_AsyncCreate.3tcl.html#//apple_ref/doc/man/3/Tcl_AsyncCreate">Tcl_AsyncCreate(3)</a>



____________________________________________________________________________________________________________

<b>NAME</b>
       Tcl_AsyncCreate,  Tcl_AsyncMark,  Tcl_AsyncInvoke, Tcl_AsyncDelete, Tcl_AsyncReady - handle asynchro-<font color="#ffffff" class="whiteout">nous&nbsp;asynchronous</font>
       nous events

<b>SYNOPSIS</b>
       <b>#include</b> <b>&lt;tcl.h&gt;</b>

       Tcl_AsyncHandler
       <b>Tcl_AsyncCreate</b>(<u>proc,</u> <u>clientData</u>)

       <b>Tcl_AsyncMark</b>(<u>async</u>)

       int
       <b>Tcl_AsyncInvoke</b>(<u>interp,</u> <u>code</u>)

       <b>Tcl_AsyncDelete</b>(<u>async</u>)

       int
       <b>Tcl_AsyncReady</b>()

<b>ARGUMENTS</b>
       Tcl_AsyncProc      <u>*proc</u>        (in)      Procedure to invoke to handle an asynchronous event.

       ClientData         <u>clientData</u>   (in)      One-word value to pass to <u>proc</u>.

       Tcl_AsyncHandler   <u>async</u>        (in)      Token for asynchronous event handler.

       Tcl_Interp         <u>*interp</u>      (in)      Tcl interpreter in which command was being  evaluated  when
                                                 handler  was  invoked,  or NULL if handler was invoked when
                                                 there was no interpreter active.

       int                <u>code</u>         (in)      Completion code from command that just completed in <u>interp</u>,
                                                 or 0 if <u>interp</u> is NULL.
____________________________________________________________________________________________________________


<b>DESCRIPTION</b>
       These  procedures  provide a safe mechanism for dealing with asynchronous events such as signals.  If
       an event such as a signal occurs while a Tcl script is being evaluated then it isn't safe to take any
       substantive  action  to process the event.  For example, it isn't safe to evaluate a Tcl script since
       the interpreter may already be in the middle of evaluating a script; it may not even be safe to allo-<font color="#ffffff" class="whiteout">cate&nbsp;allocate</font>
       cate memory, since a memory allocation could have been in progress when the event occurred.  The only
       safe approach is to set a flag indicating that the event occurred, then handle the event  later  when
       the world has returned to a clean state, such as after the current Tcl command completes.

       <b>Tcl_AsyncCreate</b>,  <b>Tcl_AsyncDelete</b>, and <b>Tcl_AsyncReady</b> are thread sensitive.  They access and/or set a
       thread-specific data structure in the event of an --enable-thread built core.  The token  created  by
       Tcl_AsyncCreate  contains the needed thread information it was called from so that calling Tcl_Async-<font color="#ffffff" class="whiteout">Mark(token)&nbsp;Tcl_AsyncMark(token)</font>
       Mark(token) will only yield the origin thread into the AsyncProc.

       <b>Tcl_AsyncCreate</b> creates an asynchronous handler and returns a token for it.  The asynchronous handler
       must be created before any occurrences of the asynchronous event that it is intended to handle (it is
       not safe to create a handler at the time of an event).  When an asynchronous event  occurs  the  code
       that  detects  the  event (such as a signal handler) should call <b>Tcl_AsyncMark</b> with the token for the
       handler.  <b>Tcl_AsyncMark</b> will mark the handler as ready to execute, but it will not invoke the handler
       immediately.   Tcl  will call the <u>proc</u> associated with the handler later, when the world is in a safe
       state, and <u>proc</u> can then carry out the actions associated with the asynchronous event.   <u>Proc</u>  should
       have arguments and result that match the type <b>Tcl_AsyncProc</b>:
              typedef int Tcl_AsyncProc(
                ClientData <u>clientData</u>,
                Tcl_Interp *<u>interp</u>,
                int <u>code</u>);
       The <u>clientData</u> will be the same as the <u>clientData</u> argument passed to <b>Tcl_AsyncCreate</b> when the handler
       was created.  If <u>proc</u> is invoked just after a command has completed execution in an interpreter, then
       <u>interp</u>  will identify the interpreter in which the command was evaluated and <u>code</u> will be the comple-<font color="#ffffff" class="whiteout">tion&nbsp;completion</font>
       tion code returned by that command.  The command's  result  will  be  present  in  the  interpreter's
       result.   When  <u>proc</u>  returns, whatever it leaves in the interpreter's result will be returned as the
       result of the command and the integer value returned by <u>proc</u> will be used as the new completion  code
       for the command.

       It is also possible for <u>proc</u> to be invoked when no interpreter is active.  This can happen, for exam-<font color="#ffffff" class="whiteout">ple,&nbsp;example,</font>
       ple, if an asynchronous event occurs while the application is waiting for interactive input or  an  X
       event.   In  this case <u>interp</u> will be NULL and <u>code</u> will be 0, and the return value from <u>proc</u> will be
       ignored.

       The procedure <b>Tcl_AsyncInvoke</b> is called to invoke all of the handlers that are ready.  The  procedure
       <b>Tcl_AsyncReady</b>  will return non-zero whenever any asynchronous handlers are ready;  it can be checked
       to avoid calls to <b>Tcl_AsyncInvoke</b> when there are no ready handlers.  Tcl calls  <b>Tcl_AsyncReady</b>  after
       each command is evaluated and calls <b>Tcl_AsyncInvoke</b> if needed.  Applications may also call <b>Tcl_Async</b>-<font color="#ffffff" class="whiteout">Invoke&nbsp;Tcl_AsyncInvoke</font>
       <b>Invoke</b> at interesting times for that application.  For example, Tcl's event handler  calls  <b>Tcl_Asyn</b>-<font color="#ffffff" class="whiteout">cReady&nbsp;Tcl_AsyncReady</font>
       <b>cReady</b>  after  each  event  and  calls  <b>Tcl_AsyncInvoke</b>  if needed.  The <u>interp</u> and <u>code</u> arguments to
       <b>Tcl_AsyncInvoke</b> have the same meaning as for <u>proc</u>:  they identify the active interpreter, if any, and
       the completion code from the command that just completed.

       <b>Tcl_AsyncDelete</b> removes an asynchronous handler so that its <u>proc</u> will never be invoked again.  A han-<font color="#ffffff" class="whiteout">dler&nbsp;handler</font>
       dler can be deleted even when ready, and it will still not be invoked.

       If multiple handlers become active at the same time, the handlers are invoked in the order they  were
       created (oldest handler first).  The <u>code</u> and the interpreter's result for later handlers reflect the
       values returned by earlier handlers, so that the most recently created handler has last say about the
       interpreter's result and completion code.  If new handlers become ready while handlers are executing,
       <b>Tcl_AsyncInvoke</b> will invoke them all;  at each point it invokes the highest-priority  (oldest)  ready
       handler, repeating this over and over until there are no longer any ready handlers.


<b>WARNING</b>
       It  is  almost always a bad idea for an asynchronous event handler to modify the interpreter's result
       or return a code different from its <u>code</u> argument.  This sort of behavior can disrupt  the  execution
       of scripts in subtle ways and result in bugs that are extremely difficult to track down.  If an asyn-<font color="#ffffff" class="whiteout">chronous&nbsp;asynchronous</font>
       chronous event handler needs to evaluate Tcl scripts then it  should  first  save  the  interpreter's
       result  plus  the  values of the variables <b>errorInfo</b> and <b>errorCode</b> (this can be done, for example, by
       storing them in dynamic strings).  When the asynchronous handler is finished it  should  restore  the
       interpreter's result, <b>errorInfo</b>, and <b>errorCode</b>, and return the <u>code</u> argument.


<b>KEYWORDS</b>
       asynchronous event, handler, signal



Tcl                                                  7.0                                  <a href="Tcl_AsyncCreate.3tcl.html#//apple_ref/doc/man/3/Tcl_AsyncCreate">Tcl_AsyncCreate(3)</a>
</tt></pre>
</td></tr></table>
	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Darwin/Reference/ManPages/man3/Async.3tcl.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Darwin/Reference/ManPages/man3/Async.3tcl.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Darwin/Reference/ManPages/man3/Async.3tcl.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

</body></html>
