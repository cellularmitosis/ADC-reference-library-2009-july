<!-- Generated by Harlequin WebMaker 2.2.3 (23-Apr-1996)
LispWorks 3.2.2 -->
<HTML> <HEAD>
<TITLE>Processing Query Results(IM:IC)</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING481></A>



<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->


<!-- Main Body -->

<CENTER>
<P>
<A HREF="IAC-480.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="IAC-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="IAC-529.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="IAC-482.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="IAC-2.html"><B>Interapplication Communication</B></A> / <BR><DD><A HREF="IAC-469.html"><B>Chapter 12 - Data Access Manager</B></A> / <A HREF="IAC-474.html"><B>Using the Data Access Manager</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING481-0></A>
<H2><A NAME=MARKER-9-168></A><A NAME=MARKER-21-169></A>Processing Query Results</H2>
 <A NAME=MARKER-2-170></A>You can use the low-level function <CODE>DBGetItem</CODE> to retrieve a single data item returned by a query, or you can use the high-level function <CODE>DBGetQueryResults</CODE> to retrieve all of the query results at once. If you use the <CODE>DBGetQueryResults</CODE> function, you can then use the <CODE>DBResultsToText</CODE> function to convert the results to ASCII text. The <CODE>DBResultsToText</CODE> function calls routines called <I>result handlers,</I> which are installed in memory by applications or by system extensions (files containing <CODE>'INIT'</CODE> resources). This section discusses the use of the <CODE>DBGetItem</CODE> and <CODE>DBGetQueryResults</CODE> functions and describes how to write and install a result handler.<P>
<A NAME=HEADING481-2></A>
<H3><A NAME=MARKER-9-171></A><A NAME=MARKER-21-172></A>Getting Query Results</H3>
 <A NAME=MARKER-2-173></A>The <CODE>DBGetItem</CODE> function retrieves a single data item that was returned by a data source in response to a query. When you call the <CODE>DBGetItem</CODE> function, you specify the data type to be retrieved. If you do not know what data type to expect, you can specify the <CODE>typeAnyType</CODE> constant for the <CODE>dataType</CODE> parameter, and the data server returns the next data item regardless of data type. It also returns information about the data item, including data type and length. <P>
 If you do not know the length of the next data item, you can specify <CODE>NIL</CODE> for the <CODE>buffer</CODE> parameter in the <CODE>DBGetItem</CODE> function, and the data server returns the data type, length, and number of decimal places without retrieving the data item. The next time you call the <CODE>DBGetItem</CODE> function with a nonzero value for the buffer parameter, the function retrieves the data item. <P>
 If you want to skip a data item, specify the <CODE>typeDiscard</CODE> constant for the <CODE>dataType</CODE> parameter. Then the next time you call the <CODE>DBGetItem</CODE> function, it retrieves the following data item.<P>
 You should use the <CODE>DBGetItem</CODE> function if you want complete control over the retrieval of each item of data. If you want the Data Access Manager to retrieve the data for you, use the <CODE>DBGetQueryResults</CODE> function instead.<P>
 <A HREF=#MARKER-9-1>Table 12-1</A> shows the data types recognized by the Data Access Manager. You use a constant to specify each data type, as follows:<P>
<PRE>
CONST {data types}
      typeAnyType    =  0;       {can be any data type} 
      typeNone       = 'none';   {no more data expected}
      typeBoolean    = 'bool';   {Boolean}
      typeSMInt      = 'shor';   {short integer}
      typeInteger    = 'long';   {integer}
      typeSMFloat    = 'sing';   {short floating point}
      typeFloat      = 'doub';   {floating point}
      typeDate       = 'date';   {date}
      typeTime       = 'time';   {time}
      typeTimeStamp  = 'tims';   {date and time}
      typeChar       = 'TEXT';   {character}
      typeDecimal    = 'deci';   {decimal number}
      typeMoney      = 'mone';   {money value}
      typeVChar      = 'vcha';   {variable character}
      typeVBin       = 'vbin';   {variable binary}
      typeLChar      = 'lcha';   {long character}
      typeLBin       = 'lbin';   {long binary}
      typeDiscard    = 'disc';   {discard next data item}
      typeUnknown    = 'unkn';   {result handler for unknown }
                                 { data type}
      typeColBreak   = 'colb';   {result handler for column break}
      typeRowBreak   = 'rowb';   {result handler for end of line}
</PRE>
 The writer of a database extension can define other data types to support specific data sources or data servers.<P>
 Each data type has a standard definition, shown in <A HREF=#MARKER-9-1>Table 12-1</A>. For example, if the <CODE>DBGetItem</CODE> function returns the <CODE>typeInteger</CODE> constant for the <CODE>dataType</CODE> parameter, you know that the data item represents an integer value and that a 4-byte buffer is necessary to hold it. Similarly, if you are using the <CODE>DBSendItem</CODE> function to send to the data server a data item that you identify as <CODE>typeFloat</CODE>, the data server expects to receive an 8-byte floating-point value. <P>
 Notice that some of these data types are defined to have a specific length (referred to as an <A NAME=MARKER-6-174></A><I>implied length</I>), and some do not. The <CODE>len</CODE> parameter of the <CODE>DBSendItem</CODE> and <CODE>DBGetItem</CODE> functions indicates the length of an individual data item. The <CODE>DBGetQueryResults</CODE> function returns a handle to an array of lengths, decimal places, and flags in the <CODE>colInfo</CODE> field of the results record. The <CODE>typeAnyType</CODE>, <CODE>typeColBreak</CODE>, and <CODE>typeRowBreak</CODE> constants do not refer to specific data types, and therefore the length specification is not applicable for these constants.<P>
 
<TABLE BORDER="0" CELLPADDING=3>
<CAPTION><A NAME=MARKER-9-1></A><A NAME=MARKER-21-2></A><B>Table 12-1 Data types defined by the Data Access Manager</B>  </CAPTION>
<TH>Constant<TH>Length<TH>Definition<TR>
<TD>typeAnyType<TD>NA<TD><A NAME=MARKER-2-3></A>Any data type (used as an input parameter to the <CODE>DBGetItem</CODE> function only; never returned by the function).<TR>
<TD>typeNone<TD>0<TD><A NAME=MARKER-2-4></A>Empty.<TR>
<TD>typeBoolean<TD>1 byte<TD><CODE><A NAME=MARKER-2-5></A>TRUE</CODE> (<CODE>1</CODE>) or <CODE>FALSE</CODE> (<CODE>0</CODE>).<TR>
<TD>typeSMInt<TD>2 bytes<TD><A NAME=MARKER-2-6></A>Signed integer value.<TR>
<TD>typeInteger<TD>4 bytes<TD><A NAME=MARKER-2-7></A>Signed long integer value.<TR>
<TD>typeSMFloat<TD>4 bytes<TD><A NAME=MARKER-2-8></A>Signed floating-point value.<TR>
<TD>typeFloat<TD>8 bytes<TD><A NAME=MARKER-2-9></A>Signed floating-point value.<TR>
<TD>typeDate<TD>4 bytes<TD><A NAME=MARKER-2-10></A>Date; a long integer value consisting of a year (most significant 16 bits), month (8 bits), and day (least significant 8 bits).<TR>
<TD>typeTime<TD>4 bytes<TD><A NAME=MARKER-2-11></A>Time; a long integer value consisting of an hour (0-23; most significant 8 bits), minute (8 bits), second (8 bits), and hundredths of a second (least significant 8 bits).<TR>
<TD>typeTimeStamp<TD>8 bytes<TD><A NAME=MARKER-2-12></A>Date and time. A long integer date value followed by a long integer time value.<TR>
<TD>typeChar<TD>Any<TD><A NAME=MARKER-2-13></A>Fixed-length character string, not <CODE>NULL</CODE> terminated. The length of the string is defined by the specific data source.<TR>
<TD>typeDecimal<TD>Any<TD>Packed decimal string. A contiguous string of 4-bit nibbles, each of which contains a decimal number, except for the low nibble of the highest-addressed byte (that is, the last nibble in the string), which contains a sign. The value of the sign nibble can be 10, 12, 14, or 15 for a positive number or 11 or 13 for a negative number; 12 is recommended for a positive number and 13 is recommended for a negative number. The most significant digit is the high-order nibble of the lowest-addressed byte (that is, the first nibble to appear in the string).<P>The total number of nibbles (including the sign nibble) must be even; therefore, the high nibble of the highest-addressed byte of a number with an even number of digits must be 0.<P>For example, the number +123 is represented as $123C.<P>graphics/DA-L-13.jpg<P>The number -1234 is represented as $01234D.<P>graphics/DA-L-14.jpg<P>The length of a packed decimal string is defined as the number of bytes, including any extra leading 0 and the sign nibble. A packed decimal string can have from 0 to 31 digits, not including the sign nibble.<P>In addition to the length of a packed decimal string, each data item has an associated value that indicates the number of digits that follow the decimal place. The <CODE>places</CODE> parameter in the <CODE>DBGetItem</CODE> and <CODE>DBSendItem</CODE> functions indicates the number of decimal places in an individual data item. The <CODE>DBGetQueryResults</CODE> function returns the number of decimal places.<TR>
<TD>typeMoney<TD>Any<TD><A NAME=MARKER-2-14></A>Same as <CODE>typeDecimal</CODE>, but always has two decimal places. <TR>
<TD>typeVChar<TD>Any<TD><A NAME=MARKER-2-15></A>Variable-length character string, <CODE>NULL</CODE> terminated.<TR>
<TD>&nbsp;<TD>&nbsp;<TD>&nbsp;<TR>
<TD>typeVBin<TD>Any<TD><A NAME=MARKER-2-16></A>Not defined. Reserved for future use.<TR>
<TD>typeLChar<TD>Any<TD><A NAME=MARKER-2-17></A>Not defined. Reserved for future use.<TR>
<TD>typeLBin<TD>Any<TD><A NAME=MARKER-2-18></A>Not defined. Reserved for future use.<TR>
<TD>typeDiscard<TD>NA<TD><A NAME=MARKER-2-19></A>Do not retrieve the next data item (used as an input parameter to the <CODE>DBGetItem</CODE> function only; never returned by the function).<TR>
<TD>typeUnknown<TD>NA<TD>A dummy data type for the result handler that processes any data type for which no other result handler is available (used as an input parameter to the <CODE>DBInstallResultHandler</CODE>, <CODE>DBRemoveResultHandler</CODE>, and <CODE>DBGetResultHandler</CODE> functions only; never returned by the <CODE>DBGetItem</CODE> function).<TR>
<TD>typeColBreak<TD>NA<TD><A NAME=MARKER-2-20></A>A dummy data type for the result handler that the <CODE>DBGetQueryResults</CODE> function calls after each item that is not the last item in a row (used as an input parameter to the <CODE>DBInstallResultHandler</CODE>, <CODE>DBRemoveResultHandler</CODE>, and <CODE>DBGetResultHandler</CODE> functions only; never returned by the <CODE>DBGetItem</CODE> function).<TR>
<TD>typeRowBreak<TD>NA<TD><A NAME=MARKER-2-21></A>A dummy data type for the result handler that the <CODE>DBGetQueryResults</CODE> function calls at the end of each row (used as an input parameter to the<CODE> DBInstallResultHandler</CODE>,<CODE> DBRemoveResultHandler</CODE>, and <CODE>DBGetResultHandler</CODE> functions only; never returned by the <CODE>DBGetItem</CODE> function).</TABLE>
<P>
 <A NAME=MARKER-2-175></A><A NAME=MARKER-2-176></A>The <CODE>DBGetQueryResults</CODE> function retrieves all of the data that was returned by a data source in response to a query, unless insufficient memory is available to hold the data, in which case it retrieves as many complete rows of data as possible. The <CODE>DBGetQueryResults</CODE> function stores the data in a structure called a <A NAME=MARKER-6-177></A><I>results record.</I> You must allocate the results record data structure and pass this record to the <CODE>DBGetQueryResults</CODE> function. The Data Access Manager allocates the handles inside the results record. When your application is finished using the results record, you must deallocate both the results record and the handles inside the results record.<P>
 The results record is defined by the <CODE>ResultsRecord</CODE> data type.<P>
<PRE>
TYPE ResultsRecord = 
   RECORD
      numRows:    Integer;          {number of rows retrieved}
      numCols:    Integer;          {number of columns per row}
      colTypes:   ColTypesHandle;   {type of data in each column}
      colData:    Handle;           {array of data items}
      colInfo:    ColInfoHandle;    {info about each data item}
   END;
</PRE>
 <A NAME=MARKER-2-264></A>The <CODE>numRows</CODE> field in the results record indicates the total number of rows retrieved. If the <CODE>DBGetQueryResults</CODE> function returns a result code other than <CODE>rcDBValue</CODE>, then not all of the data actually returned by the data source was retrieved. This could happen, for instance, if the user's computer does not have sufficient memory space to hold all the data. In this case, your application can make more space available (by writing the data in the data record to disk, for example) and then call the <CODE>DBGetQueryResults</CODE> function again to complete retrieval of the data.<P>
<DL>
<DT><B>Note</B>
<DD>The <CODE>DBGetQueryResults</CODE> function retrieves whole rows only; if it runs out of space in the middle of a row, it stores the partial row in a private buffer so that the data in the results record ends with the last complete row. Because the last partial row is no longer available from the data server, you cannot start to retrieve data with the <CODE>DBGetQueryResults</CODE> function and then switch to the <CODE>DBGetItem</CODE> function to complete the data retrieval.<EM></EM>   <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
 <A NAME=MARKER-21-43></A>The <CODE>numCols</CODE> field indicates the number of columns in each row of data.<P>
 <A NAME=MARKER-2-41></A>The <CODE>colTypes</CODE> field is a handle to an array of data types, specifying the type of data in each column. The number of elements in the array is equal to the value in the <CODE>numCols</CODE> field. <A HREF=#MARKER-9-1>Table 12-1</A> beginning on <A HREF=#MARKER-9-1>page 12-39</A> shows the standard data types. <P>
 <A NAME=MARKER-2-237></A>The <CODE>colData</CODE> field is a handle to the data retrieved by the <CODE>DBGetQueryResults</CODE> function.<P>
 <A NAME=MARKER-21-346></A>The <CODE>colInfo</CODE> field is a handle to an array of records of type <CODE>DBColInfoRecord</CODE>, each of which specifies the length, places, and flags for a data item. There are as many records in the array as there are data items retrieved by the <CODE>DBGetQueryResults</CODE> function. Here is the <CODE>DBColInfoRecord</CODE> type definition:<P>
<PRE>
TYPE DBColInfoRecord = 
   RECORD
      len:        Integer;       {length of data item}
      places:     Integer;       {places for decimal and }
                                 { money data items}
      flags:      Integer;       {flags for data item}
   END;
</PRE>
 <A NAME=MARKER-2-254></A>The <CODE>len</CODE> field indicates the length of the data item. The <CODE>DBGetQueryResults</CODE> function returns a value in this field only for those data types that do not have implied lengths; see <A HREF=#MARKER-9-1>Table 12-1</A> beginning on <A HREF=#MARKER-9-1>page 12-39</A>. <P>
 <A NAME=MARKER-2-256></A>The <CODE>places</CODE> field indicates the number of decimal places in data items of types <CODE>typeMoney</CODE> and <CODE>typeDecimal</CODE>. For all other data types, the <CODE>places</CODE> field returns 0. <P>
 <A NAME=MARKER-2-41></A>The least significant bit of the <CODE>flags</CODE> field is set to 1 if the data item is in the last column of the row. The third bit of the <CODE>flags</CODE> field is 1 if the data item is <CODE>NULL</CODE>. You can use the constants <CODE>kDBLastColFlag</CODE> and <CODE>kDBNullFlag</CODE> to test for these <DFN>flag</DFN> bits.<A NAME=MARKER-2-186></A><A NAME=MARKER-2-187></A><A NAME=MARKER-2-188></A> <P>
<A NAME=HEADING481-26></A>
<H3><A NAME=MARKER-9-189></A><A NAME=MARKER-21-190></A>Converting Query Results to Text</H3>
 <A NAME=MARKER-2-195></A><A NAME=MARKER-9-172></A><A NAME=MARKER-2-193></A>The <CODE>DBResultsToText</CODE> function provided by the high-level interface converts the data retrieved by the <CODE>DBGetQueryResults</CODE> function into strings of ASCII text. This function makes it easier for you to display retrieved data for the user. <P>
 <A NAME=MARKER-2-194></A><A NAME=MARKER-2-195></A>For the <CODE>DBResultsToText</CODE> function to convert data of a specific type to text, either the application or the system software must have a routine called a <I>result handler.</I> With System 7, Apple Computer, Inc., provides system result handlers for the data types listed here. (These data types are described in <A HREF=#MARKER-9-1>Table 12-1</A> beginning on <A HREF=#MARKER-9-1>page 12-39</A>.) 
<TABLE BORDER="0" CELLPADDING=3><TH ALIGN=LEFT>Data type<TH>Constant<TH>Data type<TH>Constant<TR>
<TD>Boolean<TD>typeBoolean<TD>Time<TD>typeTime<TR>
<TD>Short integer<TD>typeSMInt<TD>Date and time<TD>typeTimeStamp<TR>
<TD>Integer<TD>typeInteger<TD>Character<TD>typeChar<TR>
<TD>Short floating point<TD>typeSMFloat<TD>Decimal number<TD>typeDecimal<TR>
<TD>Floating point<TD>typeFloat<TD>Money value<TD>typeMoney<TR>
<TD>Date<TD>typeDate<TD>Variable character<TD>typeVChar</TABLE>
<P>
<DL>
<DT><B>Note</B>
<DD>Apple's system result handler for the variable character (<CODE>typeVChar</CODE>) data type strips trailing spaces from the character string.<EM></EM>   <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
 In addition to the result handlers for these standard data types, Apple provides the following three system result handlers, which correspond to no specific data type: 
<TABLE BORDER="0" CELLPADDING=3><TH ALIGN=LEFT>Data type<TH>Constant<TR>
<TD>Unknown <TD>typeUnknown<TR>
<TD>Column break<TD>typeColBreak<TR>
<TD>End of line<TD>typeRowBreak</TABLE>
<P>
 The <CODE>typeUnknown</CODE> result handler processes any data type for which no other result handler is available. The <CODE>DBResultsToText</CODE> function calls the <CODE>typeColBreak</CODE> result handler after each item that is not the last item in a row. This result handler does not correspond to any data type, but adds a delimiter character to separate columns of text. The default <CODE>typeColBreak</CODE> result handler inserts a tab character. Similarly, the <CODE>DBResultsToText</CODE> function calls the <CODE>typeRowBreak</CODE> result handler at the end of each row of data to add a character that separates the rows of text. The default <CODE>typeRowBreak</CODE> result handler inserts a return character. Your application can install your own <CODE>typeColBreak</CODE> and <CODE>typeRowBreak</CODE> result handlers to insert whatever characters you wish--or to insert no character at all, if you prefer.<A NAME=MARKER-2-196></A><A NAME=MARKER-2-197></A><A NAME=MARKER-2-198></A><P>
 <A NAME=MARKER-2-199></A><A NAME=MARKER-2-200></A><A NAME=MARKER-2-201></A><EM>Y</EM>ou can install result handlers for any data types you know about. When you call the <CODE>DBInstallResultHandler</CODE> function, you can specify whether the result handler you are installing is a system result handler. A <A NAME=MARKER-6-202></A><B>system result handler</B> is available to all applications that use the system. All other result handlers (called <A NAME=MARKER-6-203></A><B>application result handlers</B>) are associated with a particular application. The <CODE>DBResultsToText</CODE> function always uses a result handler for the current application in preference to a system result handler for the same data type. When you install a system result handler for the same data type as an already installed system result handler, the new result handler replaces the old one. Similarly, when you install an application result handler for the same data type as a result handler already installed for the same application, the new result handler replaces the old one for that application. <A NAME=MARKER-2-204></A><P>
 Result handlers are stored in memory. The Data Access Manager installs its system result handlers the first time the Macintosh Operating System loads the Data Access Manager into memory. You must reinstall your own application result handlers each time your application starts up. You can also install your own system result handlers each time your application starts up, or you can provide a system extension (that is, a file with an <CODE>'INIT'</CODE> resource) that installs system result handlers each time the user starts up the system.<P>
 Here is a function declaration for a result handler function<A NAME=MARKER-2-205></A><A NAME=MARKER-2-206></A>:<P>
<PRE>
FUNCTION MyResultHandler (dataType: DBType; 
                          theLen, thePlaces, theFlags: Integer; 
                          theData: Ptr; theText: Handle): OSErr;
</PRE>
 The <CODE>dataType</CODE> parameter specifies the data type of the data item that the <CODE>DBResultsToText</CODE> function is passing to the result handler. <A HREF=#MARKER-9-1>Table 12-1</A> beginning on <A HREF=#MARKER-9-1>page 12-39</A> describes the standard data types. <P>
 The parameters <CODE>theLen</CODE> and <CODE>thePlaces</CODE> specify the length and number of decimal places of the data item that the <CODE>DBResultsToText</CODE> function wants the result handler to convert to text. <P>
 The parameter <CODE>theFlags</CODE> is the value returned for the <CODE>flags</CODE> parameter by the <CODE>DBGetItem</CODE> function. If the least significant bit of this parameter is set to 1, the data item is in the last column of the row. If the third bit of this parameter is set to 1, the data item is <CODE>NULL</CODE>. You can use the constants <CODE>kDBLastColFlag</CODE> and <CODE>kDBNullFlag</CODE> to test for these flag bits.<P>
 The parameter <CODE>theData</CODE> is a pointer to the data that the result handler is to convert to text.<P>
 The parameter <CODE>theText</CODE> is a handle to the buffer that is to hold the text version of the data. The result handler should use the Memory Manager's <CODE>SetHandleSize</CODE> function to increase the size of the buffer as necessary to hold the new text, and append the new text to the end of the text already in the buffer. The <CODE>SetHandleSize</CODE> function is described in the chapter "Memory Manager" in <I>Inside Macintosh: Memory.</I><P>
 If the result handler successfully converts the data to text, it should return a result code of 0 (<CODE>noErr</CODE>). <P>
 You can use the <CODE>DBInstallResultHandler</CODE> function to install a result handler and the <CODE>DBRemoveResultHandler</CODE> function to remove an application result handler. You can install and replace system result handlers, but you cannot remove them. <P>
 The following line of code installs an application result handler. The first parameter (<CODE>typeInteger</CODE>) specifies the data type that this result handler processes. The second parameter (<CODE>MyTypeIntegerHandler</CODE>) is a pointer to the result handler routine. The last parameter (<CODE>FALSE</CODE>) is a Boolean value specifying that this routine is not a system result handler.<P>
<PRE>
err := DBInstallResultHandler
                      (typeInteger,@MyTypeIntegerHandler,FALSE);
</PRE>
 <A HREF=#MARKER-9-207>Listing 12-6</A> shows a result handler that converts the integer data type to text.<P>
<B>Listing 12-6  <A NAME=MARKER-9-207></A><A NAME=MARKER-21-208></A>A result handler</B><P>
<PRE>
FUNCTION MyTypeIntegerHandler(datatype: DBType; theLen: Integer;
                              theData: Ptr; 
                              theText: Handle): OSErr;
VAR   
   theInt:        LongInt;
   theTextLen:    LongInt;
   temp:          Str255;
   atemp1:        Ptr;
   atemp2:        LongInt;
   atemp3:        LongInt;
BEGIN
   BlockMove(theData, @theInt, sizeof(theInt));
   NumToString(theInt, temp);                {convert to text}
   theTextLen := GetHandleSize(theText);     {get current size }
                                             { of theText}
                                             {size text handle}
   SetHandleSize(theText, theTextLen + LongInt(LENGTH(temp)));
   IF (MemError &lt;&gt; noErr) THEN 
      MyTypeIntegerHandler := MemError
   ELSE
   BEGIN
      atemp1 := Ptr(ORD(@temp));
      atemp2 := LongInt(theText^) + theTextLen;
      atemp3 := LongInt(LENGTH(temp));
      {use BlockMove to append text}
      BlockMove(P2CStr(atemp1), Ptr(atemp2), atemp3);
      MyTypeIntegerHandler := MemError;
   END;
END;
</PRE>
</BLOCKQUOTE>
<HR>
<center>
<A HREF="IAC-480.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="IAC-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="IAC-529.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="IAC-482.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="IAC-3.html">&copy; Apple Computer, Inc.</A><br>7 JUL 1996</center></font><P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML>  
