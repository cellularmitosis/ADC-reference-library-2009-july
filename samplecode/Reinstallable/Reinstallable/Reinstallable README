/* *  Sample reinstallable init *  v 1.0 * *  August 1993  Greg Robbins * *  This sample INIT patches a trap globally yet is reinstallable: *  it can be recompiled and run without rebooting. * *  Usually, when an INIT patches a trap, changing the INIT requires *  reinstalling the INIT in the Extensions folder and rebooting. *  This INIT demonstrates a technique which allows new INIT code to *  replace most of the old code without the developer having to reboot. * *  This INIT just patches Standard File (_Pack3) and beeps when *  a standard file dialog is raised. * *  Demonstration: * *  ¥ put the Reinstallable Init in the Extensions folder and reboot *  ¥ bring up a standard file dialog; notice the beep *  ¥ drag the Reinstallable twoBeep INIT file onto the *    LaunchInits program *  ¥ bring up a standard file dialog again and notice both beeps  * *  The trick is to keep a global handle in the system heap containing  *  the addresses of the routines we want executed for each *  patched item.  The handle to the globals is available via Gestalt. * *  A permanently installed dispatcher routine (part of the init code) *  is used to get the address of our patch routine and jump to it. * *  The second time the init code runs, it will use the existing global *  handle, and just update the addresses of our patch routines so the *  dispatcher code jumps to the correct places. * *  A couple of critical items: *    - The init loaded at boot time contains the patch dispatchers, so *      it must never be disposed of.  We will simply strand it in the *      heap when the first reinstallation occurs. *    - If we change anything about which routines are patched, this invalidates *      the global handle struct format, so we must reboot *    - Similarly, if the dispatching code is changed, we must reboot *      since only the dispatching code from the first time the init is *      installed can be used. *    - The dispatch and patch routines destroy registers, so they *      may not be suitable for OS patches * *  Globals: * *  Since this code only uses a single true global (a handle to our *  globals in the system heap) I used a simpler method than Think C's *  A4 globals.  The global handle is stored smack in the middle of the *  GetGlobalsHandleFromStorage routine. Calling GGHFS with a handle *  stores the handle there; calling GGHFS with no parameter returns *  the stored handle.  (The handle can also be retrieved from *  Gestalt, but that is too slow a method for use in a trap patch.) *   */