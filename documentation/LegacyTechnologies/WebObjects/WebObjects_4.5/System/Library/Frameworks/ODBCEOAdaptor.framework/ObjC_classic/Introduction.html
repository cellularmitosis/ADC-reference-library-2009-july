<HTML>		<HEAD>		<TITLE>					</TITLE>		</HEAD>	<body bgcolor="#ffffff"><!--start of banner --><!-- #include virtual="/techpubs/navbar" --><!-- end of banner --><!--start of path --><font face="Geneva,Helvetica,Arial" size="1"><b>PATH<spacer type="horizontal" size="5">&nbsp;</b> <a href="../../../../../../index.html" target="_top">Documentation</a> <b>&gt;</b> <a href="../../../../../webobjects.html" target="_top">WebObjects 4.5</a> <b>&gt;</b>ODBCEOAdaptor Reference</font><br><br><!--end of path --><a href="ODBCEOAdaptorTOC.html"><img src="../../../../../images/up.gif" border="0" alt="Table of Contents"></a> <br><h1><FONT COLOR=\"#000066\">ODBCEOAdaptorFramework</FONT></h1><br><blockquote><b>Framework: </b>System/Library/Frameworks/ODBCEOAdaptor.framework</blockquote><blockquote><b>Header File Directories: </b>System/Library/Frameworks/ODBCEOAdaptor.framework/Headers</blockquote><br><h2>Introduction</h2><p>The ODBCEOAdaptor framework is a set of classes that allowyour programs to connect to an ODBC server. These classes provideODBC-specific method implementations for the EOAccess framework's EOAdaptor,EOAdaptorChannel, EOAdaptorContext, and EOSQLExpression abstractclasses.</p><p>ODBC (Open Data Base Connectivity) defines a standard interfacethat Windows applications can use to access any data source. Unlikethe other Enterprise Objects Frameworks adaptors that support a singletype of database, the ODBC adaptor supports any data source thathas an ODBC driver. Consequently, in addition to having standardadaptor features, the ODBC adaptor also manages information relatingto the driver and to the data types defined by the data source thedriver supports.</p><p>The following table lists the classes in the ODBCEOAdaptorFramework and provides a brief description of each class.</p><br><table border = \"1\"><tr><td scope="row"><b>Class</b></td><td><b>Description</b></td></tr><tr><td scope="row">ODBCAdaptor</td><td>Representsa single connection to a ODBC database server, and is responsiblefor keeping login and model information, performing ODBC-specificformatting of SQL expressions, and reporting errors. </td></tr><tr><td scope="row">ODBCChannel</td><td>Representsan independent communication channel to the database server itsODBCAdaptor is connected to.</td></tr><tr><td scope="row">ODBCContext</td><td>Representsa single transaction scope on the database server to which its adaptorobject is connected.</td></tr><tr><td scope="row">ODBCSQLExpression</td><td>Defineshow to build SQL statements for ODBCChannels.</td></tr></table><br><br><a name = "BCEFADAC"><h2>The Connection Dictionary</h2></a><p>The connection dictionary contains items needed to connectto an ODBC server, such as the data source (it's common to omitthe user name and password from the connection dictionary, and promptusers to enter those values in a login panel). The keys of thisdictionary identify the information the server expects, and thevalues of those keys are the values that the adaptor uses when tryingto connect to the server.</p><p>The ODBC adaptor defines string constants for use as connectiondictionary keys:</p><ul><li> <a frame= "conv" href="Classes/ODBCAdaptor.html#BICBFDBB">dataSourceKey</a></li><li> <a frame= "conv" href="Classes/ODBCAdaptor.html#BICGHCFJ">userNameKey</a></li><li> <a frame= "conv" href="Classes/ODBCAdaptor.html#BICFHFGF">passwordKey</a></li><li> <a frame= "conv" href="Classes/ODBCAdaptor.html#BICHAFIA">connectionStringKey</a></li><li> <a frame= "conv" href="Classes/ODBCAdaptor.html#BICCFEEJ">typeInfoKey</a></li><li> <a frame= "conv" href="Classes/ODBCAdaptor.html#BICJHJFH">driverInfoKey</a></li></ul><p>The value for the <code>connectionStringKey</code> containsthe user name, password, and data source. If an entry for <code>connectionStringKey</code> ispresent in the connection dictionary, the other login keys (<code>dataSourceKey</code>, <code>userNameKey</code>,and <code>passwordKey</code>) areignored and the value for <code>connectionStringKey</code> isused to connect to the database.</p><p>The value for the <code>typeInfoKey</code> isa dictionary that is used to cache type information. This is donebecause different ODBC drivers work with different data types. Cachingtype information in the connection dictionary avoids costly connectionsto the driver and the database. The dictionary for the <code>typeInfoKey</code> containsthe following information for every type in your database:</p><blockquote><pre>defaultODBCType = (&lt;CHAR/TIMESTAMP/BIT/...&gt;, ...)precision = &lt;precision&gt;minScale = &lt;minScale&gt;maxScale = &lt;maxScale&gt;isUnsigned = &lt;YES/NO&gt;isNullable = &lt;YES/NO&gt;isSearchable = &lt;YES/NO&gt;createParams = &lt;0/1/2&gt;</pre></blockquote><br><p>The value for the <code>driverInfoKey</code> isa dictionary that stores information about the driver, such as itsname and version.</p><p>For more information on the connection dictionary key constants,see the  <a frame= "conv" href="Classes/ODBCAdaptor.html#ODBCAdaptor">ODBCAdaptor</a> class specification.</p><p></p><br><h2>Locking</h2><p>All adaptors use the database server's native locking facilitiesto lock rows on the server. If you're using the Microsoft SQLServer, the ODBC adaptor locks a row by using the HOLDLOCK keywordin SELECT statements. In all other cases it uses the SELECT... FORUPDATE... statement. Locking occurs when:</p><ul><li>You send the adaptor channel a <b>selectAttributes:fetchSpecification:lock:entity:</b> messagewith YES specified as the value for the <b>lock:</b> keyword.</li><li>You explicitly lock an object's row with the EODatabaseContext's <b>lockObjectWithGlobalID:editingContext:</b> message.</li><li>You set pessimistic locking at the database level and fetchobjects.</li></ul><br><h2>Data Type Mapping</h2><p>Every adaptor provides a mapping between each server datatype and the Objective-C type to which a database value will becoerced when it's fetched from the database. ODBC adds an intermediatelayer: the generic ODBC type (identifier) to which each databasedata type maps.</p><p>For example, the following table shows the mapping from someof the Microsoft Access database data types to ODBC to Objective-C:</p><br><table border = \"1\"><tr><td scope="row"><b>MicrosoftAccess Database Type	</b></td><td><b>Generic ODBC Type 	</b></td><td><b>Objective-C Type</b></td></tr><tr><td scope="row"><code>TEXT</code></td><td><code>SQL_VARCHAR</code></td><td>NSString</td></tr><tr><td scope="row"><code>CURRENCY</code></td><td><code>SQL_NUMERIC</code></td><td>NSDecimalNumber</td></tr><tr><td scope="row"><code>BINARY</code></td><td><code>SQL_BINARY</code></td><td>NSData</td></tr><tr><td scope="row"><code>DATETIME</code></td><td><code>SQL_TIMESTAMP</code></td><td>NSCalendarDate</td></tr></table><br><p>The following table lists the mapping between generic ODBCtypes and Objective-C types.</p><br><table border = \"1\"><tr><td scope="row"><b>ODBCData Type</b></td><td><b>Objective-C Data Type</b></td></tr><tr><td scope="row"><code>SQL_VARCHAR</code></td><td>NSString</td></tr><tr><td scope="row"><code>SQL_CHAR</code></td><td>NSString</td></tr><tr><td scope="row"><code>SQL_LONGVARCHAR</code></td><td>NSString</td></tr><tr><td scope="row"><code>SQL_DECIMAL</code></td><td>NSDecimalNumber</td></tr><tr><td scope="row"><code>SQL_NUMERIC</code></td><td>NSDecimalNumber</td></tr><tr><td scope="row"><code>SQL_BIGINT</code></td><td>NSNumber</td></tr><tr><td scope="row"><code>SQL_SMALLINT</code></td><td>NSNumber</td></tr><tr><td scope="row"><code>SQL_INTEGER</code></td><td>NSNumber</td></tr><tr><td scope="row"><code>SQL_REAL</code></td><td>NSNumber</td></tr><tr><td scope="row"><code>SQL_FLOAT</code></td><td>NSNumber</td></tr><tr><td scope="row"><code>SQL_DOUBLE</code></td><td>NSNumber</td></tr><tr><td scope="row"><code>SQL_BIT</code></td><td>NSNumber</td></tr><tr><td scope="row"><code>SQL_TINYINT</code></td><td>NSNumber</td></tr><tr><td scope="row"><code>SQL_VARBINARY</code></td><td>NSData</td></tr><tr><td scope="row"><code>SQL_BINARY</code></td><td>NSData</td></tr><tr><td scope="row"><code>SQL_LONGVARBINARY</code></td><td>NSData</td></tr><tr><td scope="row"><code>SQL_TIMESTAMP</code></td><td>NSCalendarDate</td></tr><tr><td scope="row"><code>SQL_DATE</code></td><td>NSCalendarDate</td></tr><tr><td scope="row"><code>SQL_TIME</code></td><td>NSCalendarDate</td></tr></table><br><p>Since ODBCAdaptor's type information is stored in a model'sconnection dictionary, the type mapping methods-<b>externalTypesWithModel:</b>, <b>internalTypeForExternalType:model:</b>,and <b>isValidQualifierType:model:</b>-use themodel argument if it is provided. If the model argument isn't provided,these methods don't have data type information available to them.</p><br><h2>Prototype Attributes</h2><p>The ODBCEOAdaptor Framework provides the following set ofprototype attributes:</p><br><table border = \"1\"><tr><td scope="row"><b>Name</b></td><td><b>External Type</b></td><td><b>ValueClass Name</b></td><td><b>Other Attributes</b></td></tr><tr><td scope="row"><code>binaryID</code></td><td><code>BINARY</code></td><td>NSData</td><td><code>width= 12</code></td></tr><tr><td scope="row"><code>city</code></td><td><code>CHAR</code></td><td>NSString</td><td><code>columnName= CITY</code><code>width = 50</code></td></tr><tr><td scope="row"><code>date</code></td><td><code>DATETIME</code></td><td>NSCalendarDate</td><td><code>columnName= ""</code></td></tr><tr><td scope="row"><code>longText</code></td><td><code>LONGTEXT</code></td><td>NSString</td><td>&nbsp;</td></tr><tr><td scope="row"><code>money</code></td><td><code>CURRENCY</code></td><td>NSDecimalNumber</td><td><code>columnName= ""</code></td></tr><tr><td scope="row"><code>phoneNumber</code></td><td><code>CHAR</code></td><td>NSString</td><td><code>columnName= PHONE</code><code>width = 20</code></td></tr><tr><td scope="row"><code>rawImage</code></td><td><code>LONGBINARY</code></td><td>NSData</td><td><code>columnName= RAW_IMAGE</code></td></tr><tr><td scope="row"><code>state</code></td><td><code>CHAR</code></td><td>NSString</td><td><code>columnName= STATE</code><code>width = 2</code></td></tr><tr><td scope="row"><code>streetAddress</code></td><td><code>CHAR</code></td><td>NSString</td><td><code>columnName= STREET_ADDRESS</code><code>width = 100</code></td></tr><tr><td scope="row"><code>tiffImage</code></td><td><code>LONGBINARY</code></td><td>NSImage</td><td><code>adaptorValueConversionMethodName=    TIFFRepresentation</code><code>columnName = PHOTO</code><code>valueFactoryMethodName =    "imageWithData:"</code></td></tr><tr><td scope="row"><code>uniqueID</code></td><td><code>LONG</code></td><td>NSNumber</td><td><code>columnName= ""</code><code>valueType = i</code></td></tr><tr><td scope="row"><code>zipCode</code></td><td><code>CHAR</code></td><td>NSString</td><td><code>columnName= ZIP</code><code>width = 10</code></td></tr></table><br><br><h2>Generating Primary Keys</h2><p>Each adaptor provides a database-specific implementation ofthe method <b>primaryKeyForNewRowWithEntity:</b> forgenerating primary keys. The ODBCChannel's implementation usesa table named <code>EO_PK_TABLE</code> tokeep track of the next available primary key value for a given table. Thetable contains a row for each table for which the adaptor providesprimary key values.</p><p>ODBCChannel's implementation of <b>primaryKeyForNewRowWithEntity:</b> attemptsto select a value from the <code>EO_PK_TABLE</code> forthe new row's table. If the attempt fails because the table doesn'texist, the adaptor creates the table using the following SQL statement:</p><blockquote><pre>CREATE TABLE EO_PK_TABLE (    NAME TEXT_TYPE(40),    PK NUMBER_TYPE)</pre></blockquote><br><p>where <em>TEXT_TYPE</em> is the external(database) type for characters and <em>NUMBER_TYPE</em> isthe external type for the table's primary key attribute. The ODBCadaptor sets the PK value for each row to the corresponding table'smaximum primary key value plus one. After determining a primarykey value for the new row, the ODBC adaptor updates the counterin the corresponding row in <code>EO_PK_TABLE</code>.</p><p>For more information on this topic, see <i>EnterpriseObjects Framework Developer's Guide</i>.</p><br><h2>Bind Variables</h2><p>The ODBCAdaptor uses bind variables. A bind variable is aplaceholder used in an SQL statement that is replaced with an actualvalue after the database server determines an execution plan. Youuse the following ODBCSQLExpression methods to operate on bind variables:</p><ul><li> <a frame= "conv" href="Classes/ODBCSQLExpression.html#//apple_ref/occ/clm/ODBCSQLExpression/bindVariableDictionaryForAttribute:value:">- bindVariableDictionaryForAttribute:value:</a></li><li> <a frame= "conv" href="Classes/ODBCSQLExpression.html#//apple_ref/occ/clm/ODBCSQLExpression/mustUseBindVariableForAttribute:">- mustUseBindVariableForAttribute:</a></li><li> <a frame= "conv" href="Classes/ODBCSQLExpression.html#//apple_ref/occ/clm/ODBCSQLExpression/shouldUseBindVariableForAttribute:">- shouldUseBindVariableForAttribute:</a></li></ul><br><a href="ODBCEOAdaptorTOC.html"><img src="../../../../../images/up.gif" border="0" alt="Table of Contents"></a> </BODY></HTML>