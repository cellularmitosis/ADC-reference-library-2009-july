<html><head><title>Mac OS X
 Manual Page For DBI(3pm)</title>
<style type="text/css"><!-- @import "../../../../adcstyle.css"; .char {background: #ffffff; color:#0000ff;}.comment {background:#ffffff; color:#236e25}.function {background:#ffffff; color:#000000;}.keyword {background:#ffffff; color:#761550;}.number {background: #ffffff; color:#0000ff;}.param {background:#ffffff; color:#000000;}.preprocessor {background:#ffffff; color:#236e25}.string {background: #ffffff; color:#891315;}.template {background:#ffffff; color:#761550;}.type {background:#ffffff; color:#761550;}.var {background:#ffffff; color:#000000;} pre.manpages {font-size: 10pt;} .graybox { border-top: 1px solid #919699; border-left: 1px solid #919699; margin-bottom: 10px; } .graybox th { padding: 4px 8px 4px 8px; background: #E2E2E2; font-size: 12px; font-weight: bold; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .graybox td { padding: 8px; font-size: 12px; text-align: left; vertical-align: top; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .whiteout { font-size: 1px; background: #ffffff; color: #ffffff; } --></style>
<style type="text/css" media="print, aural, braille, embossed, projection, tty"><!-- @import "../../../../adcstyle.css"; .char {background: #ffffff; color:#0000ff;}.comment {background:#ffffff; color:#236e25}.function {background:#ffffff; color:#000000;}.keyword {background:#ffffff; color:#761550;}.number {background: #ffffff; color:#0000ff;}.param {background:#ffffff; color:#000000;}.preprocessor {background:#ffffff; color:#236e25}.string {background: #ffffff; color:#891315;}.template {background:#ffffff; color:#761550;}.type {background:#ffffff; color:#761550;}.var {background:#ffffff; color:#000000;} pre.manpages {font-size: 10pt;} .graybox { border-top: 1px solid #919699; border-left: 1px solid #919699; margin-bottom: 10px; } .graybox th { padding: 4px 8px 4px 8px; background: #E2E2E2; font-size: 12px; font-weight: bold; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .graybox td { padding: 8px; font-size: 12px; text-align: left; vertical-align: top; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .whiteout { display: none; } --></style>
</head><body bgcolor="white">
<a name="//apple_ref/doc/man/3pm/DBI" title="Mac OS X
 Manual Page for DBI(3pm)"><a name="//apple_ref/doc/man/3/DBI" title="Mac OS X
 Manual Page for DBI(3pm)"><!-- headerDoc=man; indexgroup=Section 3pm; uid="//apple_ref/doc/man/3pm/DBI"; name=DBI(3pm) --></a>
<!--#include virtual="/includes/framesetheader"-->
<table width=600><tr><td scope="row">
<!-- begin breadcrumb insert request --><font face="Geneva,Helvetica,Arial" size="1">
 <a target="_top" href="http://developer.apple.com">ADC Home</a> <b>&gt;</b> <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> <b>&gt;</b> <a href="../../../../../reference/index.html#//apple_ref/doc/uid/TP30001281" target="_top">Reference</a> <b>&gt;</b> <!-- a href="" target="_top" -->Mac OS X<!-- /a --> <b>&gt;</b> <a href="../index.html#//apple_ref/doc/framework/manpages" target="_top">Mac OS X Man Pages</a></font>
<!-- end breadcrumb insert request -->
<p>&nbsp;</p>
</td></tr></table>
<!-- end of header -->
<table border="0"  cellpadding="2" cellspacing="2" width="630pt"><tr><td valign="top" height="12" colspan="5" scope="row">
<p style='text-align:justify;'>This document is a Mac OS X manual page.  Manual pages are a command-line technology
for providing documentation.  You can view these manual pages locally using the
<a href="../man1/man.1.html#//apple_ref/doc/man/1/man">man(1)</a> command.
These manual pages come from many different sources, and thus, have a variety of writing
styles.</p>
<p style='text-align:justify;'>For more information about the manual page format, see the manual page for 
<a href="../man5/manpages.5.html#//apple_ref/doc/man/5/manpages">manpages(5)</a>.</p>
</td></tr></table>
<hr />
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row"><pre class="manpages"><tt>
DBI(3)                               User Contributed Perl Documentation                              DBI(3)



<b>NAME</b>
       DBI - Database independent interface for Perl

<b>SYNOPSIS</b>
         use DBI;

         @driver_names = DBI-&gt;available_drivers;
         %drivers      = DBI-&gt;installed_drivers;
         @data_sources = DBI-&gt;data_sources($driver_name, \%attr);

         $dbh = DBI-&gt;connect($data_source, $username, $auth, \%attr);

         $rv  = $dbh-&gt;do($statement);
         $rv  = $dbh-&gt;do($statement, \%attr);
         $rv  = $dbh-&gt;do($statement, \%attr, @bind_values);

         $ary_ref  = $dbh-&gt;selectall_arrayref($statement);
         $hash_ref = $dbh-&gt;selectall_hashref($statement, $key_field);

         $ary_ref  = $dbh-&gt;selectcol_arrayref($statement);
         $ary_ref  = $dbh-&gt;selectcol_arrayref($statement, \%attr);

         @row_ary  = $dbh-&gt;selectrow_array($statement);
         $ary_ref  = $dbh-&gt;selectrow_arrayref($statement);
         $hash_ref = $dbh-&gt;selectrow_hashref($statement);

         $sth = $dbh-&gt;prepare($statement);
         $sth = $dbh-&gt;prepare_cached($statement);

         $rc = $sth-&gt;bind_param($p_num, $bind_value);
         $rc = $sth-&gt;bind_param($p_num, $bind_value, $bind_type);
         $rc = $sth-&gt;bind_param($p_num, $bind_value, \%attr);

         $rv = $sth-&gt;execute;
         $rv = $sth-&gt;execute(@bind_values);
         $rv = $sth-&gt;execute_array(\%attr, ...);

         $rc = $sth-&gt;bind_col($col_num, \$col_variable);
         $rc = $sth-&gt;bind_columns(@list_of_refs_to_vars_to_bind);

         @row_ary  = $sth-&gt;fetchrow_array;
         $ary_ref  = $sth-&gt;fetchrow_arrayref;
         $hash_ref = $sth-&gt;fetchrow_hashref;

         $ary_ref  = $sth-&gt;fetchall_arrayref;
         $ary_ref  = $sth-&gt;fetchall_arrayref( $slice, $max_rows );

         $hash_ref = $sth-&gt;fetchall_hashref( $key_field );

         $rv  = $sth-&gt;rows;

         $rc  = $dbh-&gt;begin_work;
         $rc  = $dbh-&gt;commit;
         $rc  = $dbh-&gt;rollback;

         $quoted_string = $dbh-&gt;quote($string);

         $rc  = $h-&gt;err;
         $str = $h-&gt;errstr;
         $rv  = $h-&gt;state;

         $rc  = $dbh-&gt;disconnect;

       <u>The</u> <u>synopsis</u> <u>above</u> <u>only</u> <u>lists</u> <u>the</u> <u>major</u> <u>methods</u> <u>and</u> <u>parameters.</u>

       <b>GETTING</b> <b>HELP</b>

       If you have questions about DBI, or DBD driver modules, you can get help from the <u>dbi-users@perl.org</u>
       mailing list.  You can get help on subscribing and using the list by emailing
       <u>dbi-users-help@perl.org</u>.

       To help you make the best use of the dbi-users mailing list, and any other lists or forums you may
       use, I <u>strongly</u> recommend that you read "How To Ask Questions The Smart Way" by Eric Raymond:
       &lt;<a href="http://www.catb.org/~esr/faqs/smart-questions.html">http://www.catb.org/~esr/faqs/smart-questions.html</a>.

       If you think you've found a bug then please also read "How to Report Bugs Effectively" by Simon
       Tatham: &lt;<a href="http://www.chiark.greenend.org.uk/~sgtatham/bugs.html">http://www.chiark.greenend.org.uk/~sgtatham/bugs.html</a>.

       The DBI home page at &lt;<a href="http://dbi.perl.org/">http://dbi.perl.org/</a> is always worth a visit and includes an FAQ and links to
       other resources.

       Before asking any questions, reread this document, consult the archives and read the DBI FAQ. The
       archives are listed at the end of this document and on the DBI home page.  An FAQ is installed as a
       DBI::FAQ module so you can read it by executing "perldoc DBI::FAQ".  However the DBI::FAQ module is
       currently (2004) outdated relative to the online FAQ on the DBI home page.

       This document often uses terms like <u>references</u>, <u>objects</u>, <u>methods</u>.  If you're not familar with those
       terms then it would be a good idea to read at least the following perl manuals first: perlreftut,
       perldsc, perllol, and perlboot.

       Please note that Tim Bunce does not maintain the mailing lists or the web page (generous volunteers
       do that).  So please don't send mail directly to him; he just doesn't have the time to answer
       questions personally. The <u>dbi-users</u> mailing list has lots of experienced people who should be able to
       help you if you need it. If you do email Tim he's very likely to just forward it to the mailing list.

       <b>NOTES</b>

       This is the DBI specification that corresponds to the DBI version 1.52.

       The DBI is evolving at a steady pace, so it's good to check that you have the latest copy.

       The significant user-visible changes in each release are documented in the DBI::Changes module so you
       can read them by executing "perldoc DBI::Changes".

       Some DBI changes require changes in the drivers, but the drivers can take some time to catch up.
       Newer versions of the DBI have added features that may not yet be supported by the drivers you use.
       Talk to the authors of your drivers if you need a new feature that's not yet supported.

       Features added after DBI 1.21 (February 2002) are marked in the text with the version number of the
       DBI release they first appeared in.

       Extensions to the DBI API often use the "DBIx::*" namespace.  See "Naming Conventions and Name
       Space". DBI extension modules can be found at &lt;<a href="http://search.cpan.org/search?mode=module&amp;query=DBIx">http://search.cpan.org/search?mode=module&amp;query=DBIx</a>.
       And all modules related to the DBI can be found at
       &lt;<a href="http://search.cpan.org/search?query=DBI&amp;mode=all">http://search.cpan.org/search?query=DBI&amp;mode=all</a>.

<b>DESCRIPTION</b>
       The DBI is a database access module for the Perl programming language.  It defines a set of methods,
       variables, and conventions that provide a consistent database interface, independent of the actual
       database being used.

       It is important to remember that the DBI is just an interface.  The DBI is a layer of "glue" between
       an application and one or more database <u>driver</u> modules.  It is the driver modules which do most of
       the real work. The DBI provides a standard interface and framework for the drivers to operate within.

       <b>Architecture</b> <b>of</b> <b>a</b> <b>DBI</b> <b>Application</b>

                    |&lt;- Scope of DBI -&gt;|
                         .-.   .--------------.   .-------------.
         .-------.       | |---| XYZ Driver   |---| XYZ Engine  |
         | Perl  |       | |   `--------------'   `-------------'
         | script|  |A|  |D|   .--------------.   .-------------.
         | using |--|P|--|B|---|Oracle Driver |---|Oracle Engine|
         | DBI   |  |I|  |I|   `--------------'   `-------------'
         | API   |       | |...
         |methods|       | |... Other drivers
         `-------'       | |...
                         `-'

       The API, or Application Programming Interface, defines the call interface and variables for Perl
       scripts to use. The API is implemented by the Perl DBI extension.

       The DBI "dispatches" the method calls to the appropriate driver for actual execution.  The DBI is
       also responsible for the dynamic loading of drivers, error checking and handling, providing default
       implementations for methods, and many other non-database specific duties.

       Each driver contains implementations of the DBI methods using the private interface functions of the
       corresponding database engine.  Only authors of sophisticated/multi-database applications or generic
       library functions need be concerned with drivers.

       <b>Notation</b> <b>and</b> <b>Conventions</b>

       The following conventions are used in this document:

         $dbh    Database handle object
         $sth    Statement handle object
         $drh    Driver handle object (rarely seen or used in applications)
         $h      Any of the handle types above ($dbh, $sth, or $drh)
         $rc     General Return Code  (boolean: true=ok, false=error)
         $rv     General Return Value (typically an integer)
         @ary    List of values returned from the database, typically a row of data
         $rows   Number of rows processed (if available, else -1)
         $fh     A filehandle
         undef   NULL values are represented by undefined values in Perl
         \%attr  Reference to a hash of attribute values passed to methods

       Note that Perl will automatically destroy database and statement handle objects if all references to
       them are deleted.

       <b>Outline</b> <b>Usage</b>

       To use DBI, first you need to load the DBI module:

         use DBI;
         use strict;

       (The "use strict;" isn't required but is strongly recommended.)

       Then you need to "connect" to your data source and get a <u>handle</u> for that connection:

         $dbh = DBI-&gt;connect($dsn, $user, $password,
                             { RaiseError =&gt; 1, AutoCommit =&gt; 0 });

       Since connecting can be expensive, you generally just connect at the start of your program and
       disconnect at the end.

       Explicitly defining the required "AutoCommit" behaviour is strongly recommended and may become
       mandatory in a later version.  This determines whether changes are automatically committed to the
       database when executed, or need to be explicitly committed later.

       The DBI allows an application to "prepare" statements for later execution.  A prepared statement is
       identified by a statement handle held in a Perl variable.  We'll call the Perl variable $sth in our
       examples.

       The typical method call sequence for a "SELECT" statement is:

         prepare,
           execute, fetch, fetch, ...
           execute, fetch, fetch, ...
           execute, fetch, fetch, ...

       for example:

         $sth = $dbh-&gt;prepare("SELECT foo, bar FROM table WHERE baz=?");

         $sth-&gt;execute( $baz );

         while ( @row = $sth-&gt;fetchrow_array ) {
           print "@row\n";
         }

       The typical method call sequence for a <u>non</u>-"SELECT" statement is:

         prepare,
           execute,
           execute,
           execute.

       for example:

         $sth = $dbh-&gt;prepare("INSERT INTO table(foo,bar,baz) VALUES (?,?,?)");

         while(&lt;CSV&gt;) {
           chomp;
           my ($foo,$bar,$baz) = split /,/;
               $sth-&gt;execute( $foo, $bar, $baz );
         }

       The "do()" method can be used for non repeated <u>non</u>-"SELECT" statement (or with drivers that don't
       support placeholders):

         $rows_affected = $dbh-&gt;do("UPDATE your_table SET foo = foo + 1");

       To commit your changes to the database (when "AutoCommit" is off):

         $dbh-&gt;commit;  # or call $dbh-&gt;rollback; to undo changes

       Finally, when you have finished working with the data source, you should "disconnect" from it:

         $dbh-&gt;disconnect;

       <b>General</b> <b>Interface</b> <b>Rules</b> <b>&amp;</b> <b>Caveats</b>

       The DBI does not have a concept of a "current session". Every session has a handle object (i.e., a
       $dbh) returned from the "connect" method.  That handle object is used to invoke database related
       methods.

       Most data is returned to the Perl script as strings. (Null values are returned as "undef".)  This
       allows arbitrary precision numeric data to be handled without loss of accuracy.  Beware that Perl may
       not preserve the same accuracy when the string is used as a number.

       Dates and times are returned as character strings in the current default format of the corresponding
       database engine.  Time zone effects are database/driver dependent.

       Perl supports binary data in Perl strings, and the DBI will pass binary data to and from the driver
       without change. It is up to the driver implementors to decide how they wish to handle such binary
       data.

       Most databases that understand multiple character sets have a default global charset. Text stored in
       the database is, or should be, stored in that charset; if not, then that's the fault of either the
       database or the application that inserted the data. When text is fetched it should be automatically
       converted to the charset of the client, presumably based on the locale. If a driver needs to set a
       flag to get that behaviour, then it should do so; it should not require the application to do that.

       Multiple SQL statements may not be combined in a single statement handle ($sth), although some
       databases and drivers do support this (notably Sybase and SQL Server).

       Non-sequential record reads are not supported in this version of the DBI.  In other words, records
       can only be fetched in the order that the database returned them, and once fetched they are
       forgotten.

       Positioned updates and deletes are not directly supported by the DBI.  See the description of the
       "CursorName" attribute for an alternative.

       Individual driver implementors are free to provide any private functions and/or handle attributes
       that they feel are useful.  Private driver functions can be invoked using the DBI "func()" method.
       Private driver attributes are accessed just like standard attributes.

       Many methods have an optional "\%attr" parameter which can be used to pass information to the driver
       implementing the method. Except where specifically documented, the "\%attr" parameter can only be
       used to pass driver specific hints. In general, you can ignore "\%attr" parameters or pass it as
       "undef".

       <b>Naming</b> <b>Conventions</b> <b>and</b> <b>Name</b> <b>Space</b>

       The DBI package and all packages below it ("DBI::*") are reserved for use by the DBI. Extensions and
       related modules use the "DBIx::" namespace (see &lt;<a href="http://www.perl.com/CPAN/modules/by-module/DBIx/">http://www.perl.com/CPAN/modules/by-module/DBIx/</a>).
       Package names beginning with "DBD::" are reserved for use by DBI database drivers.  All environment
       variables used by the DBI or by individual DBDs begin with ""DBI_"" or ""DBD_"".

       The letter case used for attribute names is significant and plays an important part in the
       portability of DBI scripts.  The case of the attribute name is used to signify who defined the
       meaning of that name and its values.

         Case of name  Has a meaning defined by
         ------------  ------------------------<font color="#ffffff" class="whiteout">UPPER_CASE&nbsp;-----------------------UPPER_CASE</font>
         UPPER_CASE    Standards, e.g.,  X/Open, ISO SQL92 etc (portable)
         MixedCase     DBI API (portable), underscores are not used.
         lower_case    Driver or database engine specific (non-portable)

       It is of the utmost importance that Driver developers only use lowercase attribute names when
       defining private attributes. Private attribute names must be prefixed with the driver name or
       suitable abbreviation (e.g., ""ora_"" for Oracle, ""ing_"" for Ingres, etc).

       <b>SQL</b> <b>-</b> <b>A</b> <b>Query</b> <b>Language</b>

       Most DBI drivers require applications to use a dialect of SQL (Structured Query Language) to interact
       with the database engine.  The "Standards Reference Information" section provides links to useful
       information about SQL.

       The DBI itself does not mandate or require any particular language to be used; it is language
       independent. In ODBC terms, the DBI is in "pass-thru" mode, although individual drivers might not be.
       The only requirement is that queries and other statements must be expressed as a single string of
       characters passed as the first argument to the "prepare" or "do" methods.

       For an interesting diversion on the <u>real</u> history of RDBMS and SQL, from the people who made it
       happen, see:

         <a href="http://ftp.digital.com/pub/DEC/SRC/technical-notes/SRC-1997-018-html/sqlr95.html">http://ftp.digital.com/pub/DEC/SRC/technical-notes/SRC-1997-018-html/sqlr95.html</a>

       Follow the "Full Contents" then "Intergalactic dataspeak" links for the SQL history.

       <b>Placeholders</b> <b>and</b> <b>Bind</b> <b>Values</b>

       Some drivers support placeholders and bind values.  <u>Placeholders</u>, also called parameter markers, are
       used to indicate values in a database statement that will be supplied later, before the prepared
       statement is executed.  For example, an application might use the following to insert a row of data
       into the SALES table:

         INSERT INTO sales (product_code, qty, price) VALUES (?, ?, ?)

       or the following, to select the description for a product:

         SELECT description FROM products WHERE product_code = ?

       The "?" characters are the placeholders.  The association of actual values with placeholders is known
       as <u>binding</u>, and the values are referred to as <u>bind</u> <u>values</u>.

       Note that the "?" is not enclosed in quotation marks, even when the placeholder represents a string.
       Some drivers also allow placeholders like ":"<u>name</u> and ":"<u>n</u> (e.g., ":1", ":2", and so on) in addition
       to "?", but their use is not portable.

       With most drivers, placeholders can't be used for any element of a statement that would prevent the
       database server from validating the statement and creating a query execution plan for it. For
       example:

         "SELECT name, age FROM ?"         # wrong (will probably fail)
         "SELECT name, ?   FROM people"    # wrong (but may not 'fail')

       Also, placeholders can only represent single scalar values.  For example, the following statement
       won't work as expected for more than one value:

         "SELECT name, age FROM people WHERE name IN (?)"    # wrong
         "SELECT name, age FROM people WHERE name IN (?,?)"  # two names

       When using placeholders with the SQL "LIKE" qualifier, you must remember that the placeholder
       substitutes for the whole string.  So you should use ""... LIKE ? ..."" and include any wildcard
       characters in the value that you bind to the placeholder.

       <b>NULL</b> <b>Values</b>

       Undefined values, or "undef", are used to indicate NULL values.  You can insert and update columns
       with a NULL value as you would a non-NULL value.  These examples insert and update the column "age"
       with a NULL value:

         $sth = $dbh-&gt;prepare(qq{
           INSERT INTO people (fullname, age) VALUES (?, ?)
         });
         $sth-&gt;execute("Joe Bloggs", undef);

         $sth = $dbh-&gt;prepare(qq{
           UPDATE people SET age = ? WHERE fullname = ?
         });
         $sth-&gt;execute(undef, "Joe Bloggs");

       However, care must be taken when trying to use NULL values in a "WHERE" clause.  Consider:

         SELECT fullname FROM people WHERE age = ?

       Binding an "undef" (NULL) to the placeholder will <u>not</u> select rows which have a NULL "age"!  At least
       for database engines that conform to the SQL standard.  Refer to the SQL manual for your database
       engine or any SQL book for the reasons for this.  To explicitly select NULLs you have to say ""WHERE
       age IS NULL"".

       A common issue is to have a code fragment handle a value that could be either "defined" or "undef"
       (non-NULL or NULL) at runtime.  A simple technique is to prepare the appropriate statement as needed,
       and substitute the placeholder for non-NULL cases:

         $sql_clause = defined $age? "age = ?" : "age IS NULL";
         $sth = $dbh-&gt;prepare(qq{
           SELECT fullname FROM people WHERE $sql_clause
         });
         $sth-&gt;execute(defined $age ? $age : ());

       The following technique illustrates qualifying a "WHERE" clause with several columns, whose
       associated values ("defined" or "undef") are in a hash %h:

         for my $col ("age", "phone", "email") {
           if (defined $h{$col}) {
             push @sql_qual, "$col = ?";
             push @sql_bind, $h{$col};
           }
           else {
             push @sql_qual, "$col IS NULL";
           }
         }
         $sql_clause = join(" AND ", @sql_qual);
         $sth = $dbh-&gt;prepare(qq{
             SELECT fullname FROM people WHERE $sql_clause
         });
         $sth-&gt;execute(@sql_bind);

       The techniques above call prepare for the SQL statement with each call to execute.  Because calls to
       <u>prepare()</u> can be expensive, performance can suffer when an application iterates many times over
       statements like the above.

       A better solution is a single "WHERE" clause that supports both NULL and non-NULL comparisons.  Its
       SQL statement would need to be prepared only once for all cases, thus improving performance.  Several
       examples of "WHERE" clauses that support this are presented below.  But each example lacks
       portability, robustness, or simplicity.  Whether an example is supported on your database engine
       depends on what SQL extensions it provides, and where it supports the "?"  placeholder in a
       statement.

         0)  age = ?
         1)  NVL(age, xx) = NVL(?, xx)
         2)  ISNULL(age, xx) = ISNULL(?, xx)
         3)  DECODE(age, ?, 1, 0) = 1
         4)  age = ? OR (age IS NULL AND ? IS NULL)
         5)  age = ? OR (age IS NULL AND SP_ISNULL(?) = 1)
         6)  age = ? OR (age IS NULL AND ? = 1)

       Statements formed with the above "WHERE" clauses require execute statements as follows.  The
       arguments are required, whether their values are "defined" or "undef".

         0,1,2,3)  $sth-&gt;execute($age);
         4,5)      $sth-&gt;execute($age, $age);
         6)        $sth-&gt;execute($age, defined($age) ? 0 : 1);

       Example 0 should not work (as mentioned earlier), but may work on a few database engines anyway (e.g.
       Sybase).  Example 0 is part of examples 4, 5, and 6, so if example 0 works, these other examples may
       work, even if the engine does not properly support the right hand side of the "OR" expression.

       Examples 1 and 2 are not robust: they require that you provide a valid column value xx (e.g. '~')
       which is not present in any row.  That means you must have some notion of what data won't be stored
       in the column, and expect clients to adhere to that.

       Example 5 requires that you provide a stored procedure (SP_ISNULL in this example) that acts as a
       function: it checks whether a value is null, and returns 1 if it is, or 0 if not.

       Example 6, the least simple, is probably the most portable, i.e., it should work with with most, if
       not all, database engines.

       Here is a table that indicates which examples above are known to work on various database engines:

                          -----Examples------
                          0  1  2  3  4  5  6
                          -  -  -  -  -  -  -
         Oracle 9         N  Y  N  Y  Y  ?  Y
         Informix IDS 9   N  N  N  Y  N  Y  Y
         MS SQL           N  N  Y  N  Y  ?  Y
         Sybase           Y  N  N  N  N  N  Y
         AnyData,DBM,CSV  Y  N  N  N  Y  Y* Y

       * Works only because Example 0 works.

       DBI provides a sample perl script that will test the examples above on your database engine and tell
       you which ones work.  It is located in the <u>ex/</u> subdirectory of the DBI source distribution, or here:
       &lt;<a href="http://svn.perl.org/modules/dbi/trunk/ex/perl_dbi_nulls_test.pl">http://svn.perl.org/modules/dbi/trunk/ex/perl_dbi_nulls_test.pl</a> Please use the script to help us
       fill-in and maintain this table.

       <b>Performance</b>

       Without using placeholders, the insert statement shown previously would have to contain the literal
       values to be inserted and would have to be re-prepared and re-executed for each row. With
       placeholders, the insert statement only needs to be prepared once. The bind values for each row can
       be given to the "execute" method each time it's called. By avoiding the need to re-prepare the
       statement for each row, the application typically runs many times faster. Here's an example:

         my $sth = $dbh-&gt;prepare(q{
           INSERT INTO sales (product_code, qty, price) VALUES (?, ?, ?)
         }) or die $dbh-&gt;errstr;
         while (&lt;&gt;) {
             chomp;
             my ($product_code, $qty, $price) = split /,/;
             $sth-&gt;execute($product_code, $qty, $price) or die $dbh-&gt;errstr;
         }
         $dbh-&gt;commit or die $dbh-&gt;errstr;

       See "execute" and "bind_param" for more details.

       The "q{...}" style quoting used in this example avoids clashing with quotes that may be used in the
       SQL statement. Use the double-quote like "qq{...}" operator if you want to interpolate variables into
       the string.  See "Quote and Quote-like Operators" in perlop for more details.

       See also the "bind_columns" method, which is used to associate Perl variables with the output columns
       of a "SELECT" statement.

<b>THE</b> <b>DBI</b> <b>PACKAGE</b> <b>AND</b> <b>CLASS</b>
       In this section, we cover the DBI class methods, utility functions, and the dynamic attributes
       associated with generic DBI handles.

       <b>DBI</b> <b>Constants</b>

       Constants representing the values of the SQL standard types can be imported individually by name, or
       all together by importing the special ":sql_types" tag.

       The names and values of all the defined SQL standard types can be produced like this:

         foreach (@{ $DBI::EXPORT_TAGS{sql_types} }) {
           printf "%s=%d\n", $_, &amp;{"DBI::$_"};
         }

       These constants are defined by SQL/CLI, ODBC or both.  "SQL_BIGINT" is (currently) omitted, because
       SQL/CLI and ODBC provide conflicting codes.

       See the "type_info", "type_info_all", and "bind_param" methods for possible uses.

       Note that just because the DBI defines a named constant for a given data type doesn't mean that
       drivers will support that data type.

       <b>DBI</b> <b>Class</b> <b>Methods</b>

       The following methods are provided by the DBI class:

       "parse_dsn"
             ($scheme, $driver, $attr_string, $attr_hash, $driver_dsn) = DBI-&gt;parse_dsn($dsn)
                 or die "Can't parse DBI DSN '$dsn'";

           Breaks apart a DBI Data Source Name (DSN) and returns the individual parts. If $dsn doesn't
           contain a valid DSN then <u>parse</u><b>_</b><u>dsn()</u> returns an empty list.

           $scheme is the first part of the DSN and is currently always 'dbi'.  $driver is the driver name,
           possibly defaulted to $ENV{DBI_DRIVER}, and may be undefined.  $attr_string is the contents of
           the optional attribute string, which may be undefined.  If $attr_string is not empty then
           $attr_hash is a reference to a hash containing the parsed attribute names and values.
           $driver_dsn is the last part of the DBI DSN string. For example:

             ($scheme, $driver, $attr_string, $attr_hash, $driver_dsn)
                 = DBI-&gt;parse_dsn("DBI:MyDriver(RaiseError=&gt;1):db=test;port=42");
             $scheme      = 'dbi';
             $driver      = 'MyDriver';
             $attr_string = 'RaiseError=&gt;1';
             $attr_hash   = { 'RaiseError' =&gt; '1' };
             $driver_dsn  = 'db=test;port=42';

           The <u>parse</u><b>_</b><u>dsn()</u> method was added in DBI 1.43.

       "connect"
             $dbh = DBI-&gt;connect($data_source, $username, $password)
                       or die $DBI::errstr;
             $dbh = DBI-&gt;connect($data_source, $username, $password, \%attr)
                       or die $DBI::errstr;

           Establishes a database connection, or session, to the requested $data_source.  Returns a database
           handle object if the connection succeeds. Use "$dbh-&gt;disconnect" to terminate the connection.

           If the connect fails (see below), it returns "undef" and sets both $DBI::err and $DBI::errstr.
           (It does <u>not</u> explicitly set $!.) You should generally test the return status of "connect" and
           "print $DBI::errstr" if it has failed.

           Multiple simultaneous connections to multiple databases through multiple drivers can be made via
           the DBI. Simply make one "connect" call for each database and keep a copy of each returned
           database handle.

           The $data_source value must begin with ""dbi:"<u>driver</u><b>_</b><u>name</u>":"".  The <u>driver</u><b>_</b><u>name</u> specifies the
           driver that will be used to make the connection. (Letter case is significant.)

           As a convenience, if the $data_source parameter is undefined or empty, the DBI will substitute
           the value of the environment variable "DBI_DSN".  If just the <u>driver</u><b>_</b><u>name</u> part is empty (i.e.,
           the $data_source prefix is ""dbi::""), the environment variable "DBI_DRIVER" is used. If neither
           variable is set, then "connect" dies.

           Examples of $data_source values are:

             dbi:DriverName:database_name
             dbi:DriverName:database_name@hostname:port
             dbi:DriverName:database=database_name;host=hostname;port=port

           There is <u>no</u> <u>standard</u> for the text following the driver name. Each driver is free to use whatever
           syntax it wants. The only requirement the DBI makes is that all the information is supplied in a
           single string.  You must consult the documentation for the drivers you are using for a
           description of the syntax they require.

           It is recommended that drivers support the ODBC style, shown in the last example above. It is
           also recommended that that they support the three common names '"host"', '"port"', and
           '"database"' (plus '"db"' as an alias for "database"). This simplifies automatic construction of
           basic DSNs: "dbi:$driver:database=$db;host=$host;port=$port".  Drivers should aim to 'do
           something reasonable' when given a DSN in this form, but if any part is meaningless for that
           driver (such as 'port' for Informix) it should generate an error if that part is not empty.

           If the environment variable "DBI_AUTOPROXY" is defined (and the driver in $data_source is not
           ""Proxy"") then the connect request will automatically be changed to:

             $ENV{DBI_AUTOPROXY};dsn=$data_source

           "DBI_AUTOPROXY" is typically set as ""dbi:Proxy:hostname=...;port=..."".  If $ENV{DBI_AUTOPROXY}
           doesn't begin with '"dbi:"' then "dbi:Proxy:" will be prepended to it first.  See the DBD::Proxy
           documentation for more details.

           If $username or $password are undefined (rather than just empty), then the DBI will substitute
           the values of the "DBI_USER" and "DBI_PASS" environment variables, respectively.  The DBI will
           warn if the environment variables are not defined.  However, the everyday use of these
           environment variables is not recommended for security reasons. The mechanism is primarily
           intended to simplify testing.  See below for alternative way to specify the username and
           password.

           "DBI-&gt;connect" automatically installs the driver if it has not been installed yet. Driver
           installation either returns a valid driver handle, or it <u>dies</u> with an error message that includes
           the string ""install_driver"" and the underlying problem. So "DBI-&gt;connect" will die on a driver
           installation failure and will only return "undef" on a connect failure, in which case
           $DBI::errstr will hold the error message.  Use "eval { ... }" if you need to catch the
           ""install_driver"" error.

           The $data_source argument (with the ""dbi:...:"" prefix removed) and the $username and $password
           arguments are then passed to the driver for processing. The DBI does not define any
           interpretation for the contents of these fields.  The driver is free to interpret the
           $data_source, $username, and $password fields in any way, and supply whatever defaults are
           appropriate for the engine being accessed.  (Oracle, for example, uses the ORACLE_SID and
           TWO_TASK environment variables if no $data_source is specified.)

           The "AutoCommit" and "PrintError" attributes for each connection default to "on". (See
           "AutoCommit" and "PrintError" for more information.)  However, it is strongly recommended that
           you explicitly define "AutoCommit" rather than rely on the default. The "PrintWarn" attribute
           defaults to on if $^W is true, i.e., perl is running with warnings enabled.

           The "\%attr" parameter can be used to alter the default settings of "PrintError", "RaiseError",
           "AutoCommit", and other attributes. For example:

             $dbh = DBI-&gt;connect($data_source, $user, $pass, {
                   PrintError =&gt; 0,
                   AutoCommit =&gt; 0
             });

           The username and password can also be specified using the attributes "Username" and "Password",
           in which case they take precedence over the $username and $password parameters.

           You can also define connection attribute values within the $data_source parameter. For example:

             dbi:DriverName(PrintWarn=&gt;1,PrintError=&gt;0,Taint=&gt;1):...

           Individual attributes values specified in this way take precedence over any conflicting values
           specified via the "\%attr" parameter to "connect".

           The "dbi_connect_method" attribute can be used to specify which driver method should be called to
           establish the connection. The only useful values are 'connect', 'connect_cached', or some
           specialized case like 'Apache::DBI::connect' (which is automatically the default when running
           within Apache).

           Where possible, each session ($dbh) is independent from the transactions in other sessions. This
           is useful when you need to hold cursors open across transactions--for example, if you use one
           session for your long lifespan cursors (typically read-only) and another for your short update
           transactions.

           For compatibility with old DBI scripts, the driver can be specified by passing its name as the
           fourth argument to "connect" (instead of "\%attr"):

             $dbh = DBI-&gt;connect($data_source, $user, $pass, $driver);

           In this "old-style" form of "connect", the $data_source should not start with
           ""dbi:driver_name:"". (If it does, the embedded driver_name will be ignored). Also note that in
           this older form of "connect", the "$dbh-&gt;{AutoCommit}" attribute is <u>undefined</u>, the
           "$dbh-&gt;{PrintError}" attribute is off, and the old "DBI_DBNAME" environment variable is checked
           if "DBI_DSN" is not defined. Beware that this "old-style" "connect" will soon be withdrawn in a
           future version of DBI.

       "connect_cached"
             $dbh = DBI-&gt;connect_cached($data_source, $username, $password)
                       or die $DBI::errstr;
             $dbh = DBI-&gt;connect_cached($data_source, $username, $password, \%attr)
                       or die $DBI::errstr;

           "connect_cached" is like "connect", except that the database handle returned is also stored in a
           hash associated with the given parameters. If another call is made to "connect_cached" with the
           same parameter values, then the corresponding cached $dbh will be returned if it is still valid.
           The cached database handle is replaced with a new connection if it has been disconnected or if
           the "ping" method fails.

           That the behaviour of this method differs in several respects from the behaviour of persistent
           connections implemented by Apache::DBI.  However, if Apache::DBI is loaded then "connect_cached"
           will use it.

           Caching connections can be useful in some applications, but it can also cause problems, such as
           too many connections, and so should be used with care. In particular, avoid changing the
           attributes of a database handle created via <u>connect</u><b>_</b><u>cached()</u> because it will affect other code
           that may be using the same handle.

           Where multiple separate parts of a program are using <u>connect</u><b>_</b><u>cached()</u> to connect to the same
           database with the same (initial) attributes it is a good idea to add a private attribute to the
           <u>connect</u><b>_</b><u>cached()</u> call to effectively limit the scope of the caching. For example:

             DBI-&gt;connect_cached(..., { private_foo_cachekey =&gt; "Bar", ... });

           Handles returned from that <u>connect</u><b>_</b><u>cached()</u> call will only be returned by other <u>connect</u><b>_</b><u>cached()</u>
           call elsewhere in the code if those other calls also pass in the same attribute values, including
           the private one.  (I've used "private_foo_cachekey" here as an example, you can use any attribute
           name with a "private_" prefix.)

           Taking that one step further, you can limit a particular <u>connect</u><b>_</b><u>cached()</u> call to return handles
           unique to that one place in the code by setting the private attribute to a unique value for that
           place:

             DBI-&gt;connect_cached(..., { private_foo_cachekey =&gt; __FILE__.__LINE__, ... });

           By using a private attribute you still get connection caching for the individual calls to
           <u>connect</u><b>_</b><u>cached()</u> but, by making separate database conections for separate parts of the code, the
           database handles are isolated from any attribute changes made to other handles.

           The cache can be accessed (and cleared) via the "CachedKids" attribute:

             my $CachedKids_hashref = $dbh-&gt;{Driver}-&gt;{CachedKids};
             %$CachedKids_hashref = () if $CachedKids_hashref;

       "available_drivers"
             @ary = DBI-&gt;available_drivers;
             @ary = DBI-&gt;available_drivers($quiet);

           Returns a list of all available drivers by searching for "DBD::*" modules through the directories
           in @INC. By default, a warning is given if some drivers are hidden by others of the same name in
           earlier directories. Passing a true value for $quiet will inhibit the warning.

       "installed_drivers"
             %drivers = DBI-&gt;installed_drivers();

           Returns a list of driver name and driver handle pairs for all drivers 'installed' (loaded) into
           the current process.  The driver name does not include the 'DBD::' prefix.

           To get a list of all drivers available in your perl instalation you can use "available_drivers".

           Added in DBI 1.49.

       "installed_versions"
             DBI-&gt;installed_versions;
             @ary  = DBI-&gt;installed_versions;
             %hash = DBI-&gt;installed_versions;

           Calls <u>available</u><b>_</b><u>drivers()</u> and attempts to load each of them in turn using <u>install</u><b>_</b><u>driver()</u>.  For
           each load that succeeds the driver name and version number are added to a hash. When running
           under DBI::PurePerl drivers which appear not be pure-perl are ignored.

           When called in array context the list of successfully loaded drivers is returned (without the
           'DBD::' prefix).

           When called in scalar context a reference to the hash is returned and the hash will also contain
           other entries for the "DBI" version, "OS" name, etc.

           When called in a void context the <u>installed</u><b>_</b><u>versions()</u> method will print out a formatted list of
           the hash contents, one per line.

           Due to the potentially high memory cost and unknown risks of loading in an unknown number of
           drivers that just happen to be installed on the system, this method is nor recommended for
           general use.  Use <u>available</u><b>_</b><u>drivers()</u> instead.

           The <u>installed</u><b>_</b><u>versions()</u> method is primarily intended as a quick way to see from the command line
           what's installed. For example:

             perl -MDBI -e 'DBI-&gt;installed_versions'

           The <u>installed</u><b>_</b><u>versions()</u> method was added in DBI 1.38.

       "data_sources"
             @ary = DBI-&gt;data_sources($driver);
             @ary = DBI-&gt;data_sources($driver, \%attr);

           Returns a list of data sources (databases) available via the named driver.  If $driver is empty
           or "undef", then the value of the "DBI_DRIVER" environment variable is used.

           The driver will be loaded if it hasn't been already. Note that if the driver loading fails then
           <u>data</u><b>_</b><u>sources()</u> <u>dies</u> with an error message that includes the string ""install_driver"" and the
           underlying problem.

           Data sources are returned in a form suitable for passing to the "connect" method (that is, they
           will include the ""dbi:$driver:"" prefix).

           Note that many drivers have no way of knowing what data sources might be available for it. These
           drivers return an empty or incomplete list or may require driver-specific attributes.

           There is also a <u>data</u><b>_</b><u>sources()</u> method defined for database handles.

       "trace"
             DBI-&gt;trace($trace_setting)
             DBI-&gt;trace($trace_setting, $trace_filename)
             $trace_setting = DBI-&gt;trace;

           The "DBI-&gt;trace" method sets the <u>global</u> <u>default</u> trace settings and returns the <u>previous</u> trace
           settings. It can also be used to change where the trace output is sent.

           There's a similar method, "$h-&gt;trace", which sets the trace settings for the specific handle it's
           called on.

           See the "TRACING" section for full details about the DBI's powerful tracing facilities.

       <b>DBI</b> <b>Utility</b> <b>Functions</b>

       In addition to the DBI methods listed in the previous section, the DBI package also provides several
       utility functions.

       These can be imported into your code by listing them in the "use" statement. For example:

         use DBI qw(neat data_diff);

       Alternatively, all these utility functions (except hash) can be imported using the ":utils" import
       tag. For example:

         use DBI qw(:utils);

       "data_string_desc"
             $description = data_string_desc($string);

           Returns an informal description of the string. For example:

             UTF8 off, ASCII, 42 characters 42 bytes
             UTF8 off, non-ASCII, 42 characters 42 bytes
             UTF8 on, non-ASCII, 4 characters 6 bytes
             UTF8 on but INVALID encoding, non-ASCII, 4 characters 6 bytes
             UTF8 off, undef

           The initial "UTF8" on/off refers to Perl's internal SvUTF8 flag.  If $string has the SvUTF8 flag
           set but the sequence of bytes it contains are not a valid UTF-8 encoding then <u>data</u><b>_</b><u>string</u><b>_</b><u>desc()</u>
           will report "UTF8 on but INVALID encoding".

           The "ASCII" vs "non-ASCII" portion shows "ASCII" if <u>all</u> the characters in the string are ASCII
           (have code points &lt;= 127).

           The <u>data</u><b>_</b><u>string</u><b>_</b><u>desc()</u> function was added in DBI 1.46.

       "data_string_diff"
             $diff = data_string_diff($a, $b);

           Returns an informal description of the first character difference between the strings. If both $a
           and $b contain the same sequence of characters then <u>data</u><b>_</b><u>string</u><b>_</b><u>diff()</u> returns an empty string.
           For example:

            Params a &amp; b     Result
            ------------     ------
            'aaa', 'aaa'     ''
            'aaa', 'abc'     'Strings differ at index 2: a[2]=a, b[2]=b'
            'aaa', undef     'String b is undef, string a has 3 characters'
            'aaa', 'aa'      'String b truncated after 2 characters'

           Unicode characters are reported in "\x{XXXX}" format. Unicode code points in the range U+0800 to
           U+08FF are unassigned and most likely to occur due to double-encoding. Characters in this range
           are reported as "\x{08XX}='C'" where "C" is the corresponding latin-1 character.

           The <u>data</u><b>_</b><u>string</u><b>_</b><u>diff()</u> function only considers logical <u>characters</u> and not the underlying
           encoding. See "data_diff" for an alternative.

           The <u>data</u><b>_</b><u>string</u><b>_</b><u>diff()</u> function was added in DBI 1.46.

       "data_diff"
             $diff = data_diff($a, $b);
             $diff = data_diff($a, $b, $logical);

           Returns an informal description of the difference between two strings.  It calls
           "data_string_desc" and "data_string_diff" and returns the combined results as a multi-line
           string.

           For example, "data_diff("abc", "ab\x{263a}")" will return:

             a: UTF8 off, ASCII, 3 characters 3 bytes
             b: UTF8 on, non-ASCII, 3 characters 5 bytes
             Strings differ at index 2: a[2]=c, b[2]=\x{263A}

           If $a and $b are identical in both the characters they contain <u>and</u> their physical encoding then
           <u>data</u><b>_</b><u>diff()</u> returns an empty string.  If $logical is true then physical encoding differences are
           ignored (but are still reported if there is a difference in the characters).

           The <u>data</u><b>_</b><u>diff()</u> function was added in DBI 1.46.

       "neat"
             $str = neat($value);
             $str = neat($value, $maxlen);

           Return a string containing a neat (and tidy) representation of the supplied value.

           Strings will be quoted, although internal quotes will <u>not</u> be escaped.  Values known to be numeric
           will be unquoted. Undefined (NULL) values will be shown as "undef" (without quotes).

           If the string is flagged internally as utf8 then double quotes will be used, otherwise single
           quotes are used and unprintable characters will be replaced by dot (.).

           For result strings longer than $maxlen the result string will be truncated to "$maxlen-4" and
           ""...'"" will be appended.  If $maxlen is 0 or "undef", it defaults to $DBI::neat_maxlen which,
           in turn, defaults to 400.

           This function is designed to format values for human consumption.  It is used internally by the
           DBI for "trace" output. It should typically <u>not</u> be used for formatting values for database use.
           (See also "quote".)

       "neat_list"
             $str = neat_list(\@listref, $maxlen, $field_sep);

           Calls "neat" on each element of the list and returns a string containing the results joined with
           $field_sep. $field_sep defaults to ", ".

       "looks_like_number"
             @bool = looks_like_number(@array);

           Returns true for each element that looks like a number.  Returns false for each element that does
           not look like a number.  Returns "undef" for each element that is undefined or empty.

       "hash"
             $hash_value = DBI::hash($buffer, $type);

           Return a 32-bit integer 'hash' value corresponding to the contents of $buffer.  The $type
           parameter selects which kind of hash algorithm should be used.

           For the technically curious, type 0 (which is the default if $type isn't specified) is based on
           the Perl 5.1 hash except that the value is forced to be negative (for obscure historical
           reasons).  Type 1 is the better "Fowler / Noll / Vo" (FNV) hash. See
           &lt;<a href="http://www.isthe.com/chongo/tech/comp/fnv/">http://www.isthe.com/chongo/tech/comp/fnv/</a> for more information.  Both types are implemented in
           C and are very fast.

           This function doesn't have much to do with databases, except that it can be handy to store hash
           values in a database.

       <b>DBI</b> <b>Dynamic</b> <b>Attributes</b>

       Dynamic attributes are always associated with the <u>last</u> <u>handle</u> <u>used</u> (that handle is represented by $h
       in the descriptions below).

       Where an attribute is equivalent to a method call, then refer to the method call for all related
       documentation.

       Warning: these attributes are provided as a convenience but they do have limitations. Specifically,
       they have a short lifespan: because they are associated with the last handle used, they should only
       be used <u>immediately</u> after calling the method that "sets" them.  If in any doubt, use the
       corresponding method call.

       $DBI::err
           Equivalent to "$h-&gt;err".

       $DBI::errstr
           Equivalent to "$h-&gt;errstr".

       $DBI::state
           Equivalent to "$h-&gt;state".

       $DBI::rows
           Equivalent to "$h-&gt;rows". Please refer to the documentation for the "rows" method.

       $DBI::lasth
           Returns the DBI object handle used for the most recent DBI method call.  If the last DBI method
           call was a DESTROY then $DBI::lasth will return the handle of the parent of the destroyed handle,
           if there is one.

<b>METHODS</b> <b>COMMON</b> <b>TO</b> <b>ALL</b> <b>HANDLES</b>
       The following methods can be used by all types of DBI handles.

       "err"
             $rv = $h-&gt;err;

           Returns the <u>native</u> database engine error code from the last driver method called. The code is
           typically an integer but you should not assume that.

           The DBI resets $h-&gt;err to undef before almost all DBI method calls, so the value only has a short
           lifespan. Also, for most drivers, the statement handles share the same error variable as the
           parent database handle, so calling a method on one handle may reset the error on the related
           handles.

           (Methods which don't reset err before being called include <u>err()</u> and <u>errstr()</u>, obviously,
           <u>state()</u>, <u>rows()</u>, <u>func()</u>, <u>trace()</u>, <u>trace</u><b>_</b><u>msg()</u>, <u>ping()</u>, and the tied hash attribute <u>FETCH()</u> and
           <u>STORE()</u> methods.)

           If you need to test for specific error conditions <u>and</u> have your program be portable to different
           database engines, then you'll need to determine what the corresponding error codes are for all
           those engines and test for all of them.

           A driver may return 0 from <u>err()</u> to indicate a warning condition after a method call. Similarly,
           a driver may return an empty string to indicate a 'success with information' condition. In both
           these cases the value is false but not undef. The <u>errstr()</u> and <u>state()</u> methods may be used to
           retrieve extra information in these cases.

           See "set_err" for more information.

       "errstr"
             $str = $h-&gt;errstr;

           Returns the native database engine error message from the last DBI method called. This has the
           same lifespan issues as the "err" method described above.

           The returned string may contain multiple messages separated by newline characters.

           The <u>errstr()</u> method should not be used to test for errors, use <u>err()</u> for that, because drivers
           may return 'success with information' or warning messages via <u>errstr()</u> for methods that have not
           'failed'.

           See "set_err" for more information.

       "state"
             $str = $h-&gt;state;

           Returns a state code in the standard SQLSTATE five character format.  Note that the specific
           success code 00000 is translated to any empty string (false). If the driver does not support
           SQLSTATE (and most don't), then state will return "S1000" (General Error) for all errors.

           The driver is free to return any value via "state", e.g., warning codes, even if it has not
           declared an error by returning a true value via the "err" method described above.

           The <u>state()</u> method should not be used to test for errors, use <u>err()</u> for that, because drivers may
           return a 'success with information' or warning state code via <u>errstr()</u> for methods that have not
           'failed'.

       "set_err"
             $rv = $h-&gt;set_err($err, $errstr);
             $rv = $h-&gt;set_err($err, $errstr, $state);
             $rv = $h-&gt;set_err($err, $errstr, $state, $method);
             $rv = $h-&gt;set_err($err, $errstr, $state, $method, $rv);

           Set the "err", "errstr", and "state" values for the handle.  This method is typically only used
           by DBI drivers and DBI subclasses.

           If the "HandleSetErr" attribute holds a reference to a subroutine it is called first. The
           subroutine can alter the $err, $errstr, $state, and $method values. See "HandleSetErr" for full
           details.  If the subroutine returns a true value then the handle "err", "errstr", and "state"
           values are not altered and <u>set</u><b>_</b><u>err()</u> returns an empty list (it normally returns $rv which
           defaults to undef, see below).

           Setting "err" to a <u>true</u> value indicates an error and will trigger the normal DBI error handling
           mechanisms, such as "RaiseError" and "HandleError", if they are enabled, when execution returns
           from the DBI back to the application.

           Setting "err" to "" indicates an 'information' state, and setting it to "0" indicates a 'warning'
           state. Setting "err" to "undef" also sets "errstr" to undef, and "state" to "", irrespective of
           the values of the $errstr and $state parameters.

           The $method parameter provides an alternate method name for the
           "RaiseError"/"PrintError"/"PrintWarn" error string instead of the fairly unhelpful '"set_err"'.

           The "set_err" method normally returns undef.  The $rv parameter provides an alternate return
           value.

           Some special rules apply if the "err" or "errstr" values for the handle are <u>already</u> set...

           If "errstr" is true then: "" [err was %s now %s]"" is appended if $err is true and "err" is
           already true; "" [state was %s now %s]"" is appended if $state is true and "state" is already
           true; then ""\n"" and the new $errstr are appended. Obviously the %s's above are replaced by the
           corresponding values.

           The handle "err" value is set to $err if: $err is true; or handle "err" value is undef; or $err
           is defined and the length is greater than the handle "err" length. The effect is that an
           'information' state only overrides undef; a 'warning' overrides undef or 'information', and an
           'error' state overrides anything.

           The handle "state" value is set to $state if $state is true and the handle "err" value was set
           (by the rules above).

           Support for warning and information states was added in DBI 1.41.

       "trace"
             $h-&gt;trace($trace_settings);
             $h-&gt;trace($trace_settings, $trace_filename);
             $trace_settings = $h-&gt;trace;

           The <u>trace()</u> method is used to alter the trace settings for a handle (and any future children of
           that handle).  It can also be used to change where the trace output is sent.

           There's a similar method, "DBI-&gt;trace", which sets the global default trace settings.

           See the "TRACING" section for full details about the DBI's powerful tracing facilities.

       "trace_msg"
             $h-&gt;trace_msg($message_text);
             $h-&gt;trace_msg($message_text, $min_level);

           Writes $message_text to the trace file if the trace level is greater than or equal to $min_level
           (which defaults to 1).  Can also be called as "DBI-&gt;trace_msg($msg)".

           See "TRACING" for more details.

       "func"
             $h-&gt;func(@func_arguments, $func_name) or die ...;

           The "func" method can be used to call private non-standard and non-portable methods implemented
           by the driver. Note that the function name is given as the <u>last</u> argument.

           It's also important to note that the <u>func()</u> method does not clear a previous error ($DBI::err
           etc.) and it does not trigger automatic error detection (RaiseError etc.) so you must check the
           return status and/or $h-&gt;err to detect errors.

           (This method is not directly related to calling stored procedures.  Calling stored procedures is
           currently not defined by the DBI.  Some drivers, such as DBD::Oracle, support it in non-portable
           ways.  See driver documentation for more details.)

           See also "install_method" for how you can avoid needing to use <u>func()</u> and gain.

       "can"
             $is_implemented = $h-&gt;can($method_name);

           Returns true if $method_name is implemented by the driver or a default method is provided by the
           DBI.  It returns false where a driver hasn't implemented a method and the default method is
           provided by the DBI is just an empty stub.

       "parse_trace_flags"
             $trace_settings_integer = $h-&gt;parse_trace_flags($trace_settings);

           Parses a string containing trace settings and returns the corresponding integer value used
           internally by the DBI and drivers.

           The $trace_settings argument is a string containing a trace level between 0 and 15 and/or trace
           flag names separated by vertical bar (""|"") or comma ("","") characters. For example:
           "SQL|3|foo".

           It uses the <u>parse</u><b>_</b><u>trace</u><b>_</b><u>flag()</u> method, described below, to process the individual trage flag
           names.

           The <u>parse</u><b>_</b><u>trace</u><b>_</b><u>flags()</u> method was added in DBI 1.42.

       "parse_trace_flag"
             $bit_flag = $h-&gt;parse_trace_flag($trace_flag_name);

           Returns the bit flag corresponding to the trace flag name in $trace_flag_name.  Drivers are
           expected to override this method and check if $trace_flag_name is a driver specific trace flags
           and, if not, then call the DBIs default <u>parse</u><b>_</b><u>trace</u><b>_</b><u>flag()</u>.

           The <u>parse</u><b>_</b><u>trace</u><b>_</b><u>flag()</u> method was added in DBI 1.42.

       "swap_inner_handle"
             $rc = $h1-&gt;swap_inner_handle( $h2 );
             $rc = $h1-&gt;swap_inner_handle( $h2, $allow_reparent );

           Brain transplants for handles. You don't need to know about this unless you want to become a
           handle surgeon.

           A DBI handle is a reference to a tied hash. A tied hash has an <u>inner</u> hash that actually holds the
           contents.  The <u>swap</u><b>_</b><u>inner</u><b>_</b><u>handle()</u> method swaps the inner hashes between two handles. The $h1 and
           $h2 handles still point to the same tied hashes, but what those hashes are tied to has been
           swapped.  In effect $h1 <u>becomes</u> $h2 and vice-versa. This is powerful stuff. Use with care.

           As a small safety measure, the two handles, $h1 and $h2, have to share the same parent unless
           $allow_reparent is true.

           The <u>swap</u><b>_</b><u>inner</u><b>_</b><u>handle()</u> method was added in DBI 1.44.

<b>ATTRIBUTES</b> <b>COMMON</b> <b>TO</b> <b>ALL</b> <b>HANDLES</b>
       These attributes are common to all types of DBI handles.

       Some attributes are inherited by child handles. That is, the value of an inherited attribute in a
       newly created statement handle is the same as the value in the parent database handle. Changes to
       attributes in the new statement handle do not affect the parent database handle and changes to the
       database handle do not affect existing statement handles, only future ones.

       Attempting to set or get the value of an unknown attribute generates a warning, except for private
       driver specific attributes (which all have names starting with a lowercase letter).

       Example:

         $h-&gt;{AttributeName} = ...;    # set/write
         ... = $h-&gt;{AttributeName};    # get/read

       "Warn" (boolean, inherited)
           The "Warn" attribute enables useful warnings for certain bad practices. It is enabled by default
           and should only be disabled in rare circumstances.  Since warnings are generated using the Perl
           "warn" function, they can be intercepted using the Perl $SIG{__WARN__} hook.

           The "Warn" attribute is not related to the "PrintWarn" attribute.

       "Active" (boolean, read-only)
           The "Active" attribute is true if the handle object is "active". This is rarely used in
           applications. The exact meaning of active is somewhat vague at the moment. For a database handle
           it typically means that the handle is connected to a database ("$dbh-&gt;disconnect" sets "Active"
           off).  For a statement handle it typically means that the handle is a "SELECT" that may have more
           data to fetch. (Fetching all the data or calling "$sth-&gt;finish" sets "Active" off.)

       "Executed" (boolean)
           The "Executed" attribute is true if the handle object has been "executed".  Currently only the
           $dbh <u>do()</u> method and the $sth <u>execute()</u>, <u>execute</u><b>_</b><u>array()</u>, and <u>execute</u><b>_</b><u>for</u><b>_</b><u>fetch()</u> methods set the
           "Executed" attribute.

           When it's set on a handle it is also set on the parent handle at the same time. So calling
           <u>execute()</u> on a $sth also sets the "Executed" attribute on the parent $dbh.

           The "Executed" attribute for a database handle is cleared by the <u>commit()</u> and <u>rollback()</u> methods.
           The "Executed" attribute of a statement handle is not cleared by the DBI under any circumstances
           and so acts as a permanent record of whether the statement handle was ever used.

           The "Executed" attribute was added in DBI 1.41.

       "Kids" (integer, read-only)
           For a driver handle, "Kids" is the number of currently existing database handles that were
           created from that driver handle.  For a database handle, "Kids" is the number of currently
           existing statement handles that were created from that database handle.  For a statement handle,
           the value is zero.

       "ActiveKids" (integer, read-only)
           Like "Kids", but only counting those that are "Active" (as above).

       "CachedKids" (hash ref)
           For a database handle, "CachedKids" returns a reference to the cache (hash) of statement handles
           created by the "prepare_cached" method.  For a driver handle, returns a reference to the cache
           (hash) of database handles created by the "connect_cached" method.

       "Type" (scalar)
           The "Type" attribute identifies the type of a DBI handle.  Returns "dr" for driver handles, "db"
           for database handles and "st" for statement handles.

       "ChildHandles" (array ref)
           The ChildHandles attribute contains a reference to an array of all the handles created by this
           handle which are still accessible.  The contents of the array are weak-refs and will become undef
           when the handle goes out of scope.

           "ChildHandles" returns undef if your perl version does not support weak references (check the
           Scalar::Util module).  The referenced array returned should be treated as read-only.

           For example, to enumerate all driver handles, database handles and statement handles:

               sub show_child_handles {
                   my ($h, $level) = @_;
                   $level ||= 0;
                   printf "%sh %s %s\n", $h-&gt;{Type}, "\t" x $level, $h;
                   show_child_handles($_, $level + 1)
                       for (grep { defined } @{$h-&gt;{ChildHandles}});
               }

               my %drivers = DBI-&gt;installed_drivers();
               show_child_handles($_) for (values %drivers);

       "CompatMode" (boolean, inherited)
           The "CompatMode" attribute is used by emulation layers (such as Oraperl) to enable compatible
           behaviour in the underlying driver (e.g., DBD::Oracle) for this handle. Not normally set by
           application code.

           It also has the effect of disabling the 'quick FETCH' of attribute values from the handles
           attribute cache. So all attribute values are handled by the drivers own FETCH method. This makes
           them slightly slower but is useful for special-purpose drivers like DBD::Multiplex.

       "InactiveDestroy" (boolean)
           The default value, false, means a handle will be fully destroyed as normal when the last
           reference to it is removed, just as you'd expect.

           If set true then the handle will be treated by the DESTROY as if it was no longer Active, and so
           the <u>database</u> <u>engine</u> related effects of DESTROYing a handle will be skipped.

           Think of the name as meaning 'treat the handle as not-Active in the DESTROY method'.

           For a database handle, this attribute does not disable an <u>explicit</u> call to the disconnect method,
           only the implicit call from DESTROY that happens if the handle is still marked as "Active".

           This attribute is specifically designed for use in Unix applications that "fork" child processes.
           Either the parent or the child process, but not both, should set "InactiveDestroy" true on all
           their shared handles.  (Note that some databases, including Oracle, don't support passing a
           database connection across a fork.)

           To help tracing applications using fork the process id is shown in the trace log whenever a DBI
           or handle <u>trace()</u> method is called.  The process id also shown for <u>every</u> method call if the DBI
           trace level (not handle trace level) is set high enough to show the trace from the DBI's method
           dispatcher, e.g. &gt;= 9.

       "PrintWarn" (boolean, inherited)
           The "PrintWarn" attribute controls the printing of warnings recorded by the driver.  When set to
           a true value the DBI will check method calls to see if a warning condition has been set. If so,
           the DBI will effectively do a "warn("$class $method warning: $DBI::errstr")" where $class is the
           driver class and $method is the name of the method which failed. E.g.,

             DBD::Oracle::db execute warning: ... warning text here ...

           By default, "DBI-&gt;connect" sets "PrintWarn" "on" if $^W is true, i.e., perl is running with
           warnings enabled.

           If desired, the warnings can be caught and processed using a $SIG{__WARN__} handler or modules
           like CGI::Carp and CGI::ErrorWrap.

           See also "set_err" for how warnings are recorded and "HandleSetErr" for how to influence it.

           Fetching the full details of warnings can require an extra round-trip to the database server for
           some drivers. In which case the driver may opt to only fetch the full details of warnings if the
           "PrintWarn" attribute is true. If "PrintWarn" is false then these drivers should still indicate
           the fact that there were warnings by setting the warning string to, for example: "3 warnings".

       "PrintError" (boolean, inherited)
           The "PrintError" attribute can be used to force errors to generate warnings (using "warn") in
           addition to returning error codes in the normal way.  When set "on", any method which results in
           an error occuring will cause the DBI to effectively do a "warn("$class $method failed:
           $DBI::errstr")" where $class is the driver class and $method is the name of the method which
           failed. E.g.,

             DBD::Oracle::db prepare failed: ... error text here ...

           By default, "DBI-&gt;connect" sets "PrintError" "on".

           If desired, the warnings can be caught and processed using a $SIG{__WARN__} handler or modules
           like CGI::Carp and CGI::ErrorWrap.

       "RaiseError" (boolean, inherited)
           The "RaiseError" attribute can be used to force errors to raise exceptions rather than simply
           return error codes in the normal way. It is "off" by default.  When set "on", any method which
           results in an error will cause the DBI to effectively do a "die("$class $method failed:
           $DBI::errstr")", where $class is the driver class and $method is the name of the method that
           failed. E.g.,

             DBD::Oracle::db prepare failed: ... error text here ...

           If you turn "RaiseError" on then you'd normally turn "PrintError" off.  If "PrintError" is also
           on, then the "PrintError" is done first (naturally).

           Typically "RaiseError" is used in conjunction with "eval { ... }" to catch the exception that's
           been thrown and followed by an "if ($@) { ... }" block to handle the caught exception.  For
           example:

             eval {
               ...
               $sth-&gt;execute();
               ...
             };
             if ($@) {
               # $sth-&gt;err and $DBI::err will be true if error was from DBI
               warn $@; # print the error
               ... # do whatever you need to deal with the error
             }

           In that eval block the $DBI::lasth variable can be useful for diagnosis and reporting if you
           can't be sure which handle triggered the error.  For example, $DBI::lasth-&gt;{Type} and
           $DBI::lasth-&gt;{Statement}.

           See also "Transactions".

           If you want to temporarily turn "RaiseError" off (inside a library function that is likely to
           fail, for example), the recommended way is like this:

             {
               local $h-&gt;{RaiseError};  # localize and turn off for this block
               ...
             }

           The original value will automatically and reliably be restored by Perl, regardless of how the
           block is exited.  The same logic applies to other attributes, including "PrintError".

       "HandleError" (code ref, inherited)
           The "HandleError" attribute can be used to provide your own alternative behaviour in case of
           errors. If set to a reference to a subroutine then that subroutine is called when an error is
           detected (at the same point that "RaiseError" and "PrintError" are handled).

           The subroutine is called with three parameters: the error message string that "RaiseError" and
           "PrintError" would use, the DBI handle being used, and the first value being returned by the
           method that failed (typically undef).

           If the subroutine returns a false value then the "RaiseError" and/or "PrintError" attributes are
           checked and acted upon as normal.

           For example, to "die" with a full stack trace for any error:

             use Carp;
             $h-&gt;{HandleError} = sub { confess(shift) };

           Or to turn errors into exceptions:

             use Exception; # or your own favourite exception module
             $h-&gt;{HandleError} = sub { Exception-&gt;new('DBI')-&gt;raise($_[0]) };

           It is possible to 'stack' multiple HandleError handlers by using closures:

             sub your_subroutine {
               my $previous_handler = $h-&gt;{HandleError};
               $h-&gt;{HandleError} = sub {
                 return 1 if $previous_handler and &amp;$previous_handler(@_);
                 ... your code here ...
               };
             }

           Using a "my" inside a subroutine to store the previous "HandleError" value is important.  See
           perlsub and perlref for more information about <u>closures</u>.

           It is possible for "HandleError" to alter the error message that will be used by "RaiseError" and
           "PrintError" if it returns false.  It can do that by altering the value of $_[0]. This example
           appends a stack trace to all errors and, unlike the previous example using Carp::confess, this
           will work "PrintError" as well as "RaiseError":

             $h-&gt;{HandleError} = sub { $_[0]=Carp::longmess($_[0]); 0; };

           It is also possible for "HandleError" to hide an error, to a limited degree, by using "set_err"
           to reset $DBI::err and $DBI::errstr, and altering the return value of the failed method. For
           example:

             $h-&gt;{HandleError} = sub {
               return 0 unless $_[0] =~ /^\S+ fetchrow_arrayref failed:/;
               return 0 unless $_[1]-&gt;err == 1234; # the error to 'hide'
               $h-&gt;set_err(undef,undef);   # turn off the error
               $_[2] = [ ... ];    # supply alternative return value
               return 1;
             };

           This only works for methods which return a single value and is hard to make reliable (avoiding
           infinite loops, for example) and so isn't recommended for general use!  If you find a <u>good</u> use
           for it then please let me know.

       "HandleSetErr" (code ref, inherited)
           The "HandleSetErr" attribute can be used to intercept the setting of handle "err", "errstr", and
           "state" values.  If set to a reference to a subroutine then that subroutine is called whenever
           <u>set</u><b>_</b><u>err()</u> is called, typically by the driver or a subclass.

           The subroutine is called with five arguments, the first five that were passed to <u>set</u><b>_</b><u>err()</u>: the
           handle, the "err", "errstr", and "state" values being set, and the method name. These can be
           altered by changing the values in the @_ array. The return value affects <u>set</u><b>_</b><u>err()</u> behaviour, see
           "set_err" for details.

           It is possible to 'stack' multiple HandleSetErr handlers by using closures. See "HandleError" for
           an example.

           The "HandleSetErr" and "HandleError" subroutines differ in subtle but significant ways.
           HandleError is only invoked at the point where the DBI is about to return to the application with
           "err" set true.  It's not invoked by the failure of a method that's been called by another DBI
           method.  HandleSetErr, on the other hand, is called whenever <u>set</u><b>_</b><u>err()</u> is called with a defined
           "err" value, even if false.  So it's not just for errors, despite the name, but also warn and
           info states.  The <u>set</u><b>_</b><u>err()</u> method, and thus HandleSetErr, may be called multiple times within a
           method and is usually invoked from deep within driver code.

           In theory a driver can use the return value from HandleSetErr via <u>set</u><b>_</b><u>err()</u> to decide whether to
           continue or not. If <u>set</u><b>_</b><u>err()</u> returns an empty list, indicating that the HandleSetErr code has
           'handled' the 'error', the driver could then continue instead of failing (if that's a reasonable
           thing to do).  This isn't excepted to be common and any such cases should be clearly marked in
           the driver documentation and discussed on the dbi-dev mailing list.

           The "HandleSetErr" attribute was added in DBI 1.41.

       "ErrCount" (unsigned integer)
           The "ErrCount" attribute is incremented whenever the <u>set</u><b>_</b><u>err()</u> method records an error. It isn't
           incremented by warnings or information states. It is not reset by the DBI at any time.

           The "ErrCount" attribute was added in DBI 1.41. Older drivers may not have been updated to use
           <u>set</u><b>_</b><u>err()</u> to record errors and so this attribute may not be incremented when using them.

       "ShowErrorStatement" (boolean, inherited)
           The "ShowErrorStatement" attribute can be used to cause the relevant Statement text to be
           appended to the error messages generated by the "RaiseError", "PrintError", and "PrintWarn"
           attributes.  Only applies to errors on statement handles plus the <u>prepare()</u>, <u>do()</u>, and the
           various "select*()" database handle methods.  (The exact format of the appended text is subject
           to change.)

           If "$h-&gt;{ParamValues}" returns a hash reference of parameter (placeholder) values then those are
           formatted and appended to the end of the Statement text in the error message.

       "TraceLevel" (integer, inherited)
           The "TraceLevel" attribute can be used as an alternative to the "trace" method to set the DBI
           trace level and trace flags for a specific handle.  See "TRACING" for more details.

           The "TraceLevel" attribute is especially useful combined with "local" to alter the trace settings
           for just a single block of code.

       "FetchHashKeyName" (string, inherited)
           The "FetchHashKeyName" attribute is used to specify whether the <u>fetchrow</u><b>_</b><u>hashref()</u> method should
           perform case conversion on the field names used for the hash keys. For historical reasons it
           defaults to '"NAME"' but it is recommended to set it to '"NAME_lc"' (convert to lower case) or
           '"NAME_uc"' (convert to upper case) according to your preference.  It can only be set for driver
           and database handles.  For statement handles the value is frozen when <u>prepare()</u> is called.

       "ChopBlanks" (boolean, inherited)
           The "ChopBlanks" attribute can be used to control the trimming of trailing space characters from
           fixed width character (CHAR) fields. No other field types are affected, even where field values
           have trailing spaces.

           The default is false (although it is possible that the default may change).  Applications that
           need specific behaviour should set the attribute as needed.

           Drivers are not required to support this attribute, but any driver which does not support it must
           arrange to return "undef" as the attribute value.

       "LongReadLen" (unsigned integer, inherited)
           The "LongReadLen" attribute may be used to control the maximum length of 'long' type fields
           (LONG, BLOB, CLOB, MEMO, etc.) which the driver will read from the database automatically when it
           fetches each row of data.

           The "LongReadLen" attribute only relates to fetching and reading long values; it is not involved
           in inserting or updating them.

           A value of 0 means not to automatically fetch any long data.  Drivers may return undef or an
           empty string for long fields when "LongReadLen" is 0.

           The default is typically 0 (zero) bytes but may vary between drivers.  Applications fetching long
           fields should set this value to slightly larger than the longest long field value to be fetched.

           Some databases return some long types encoded as pairs of hex digits.  For these types,
           "LongReadLen" relates to the underlying data length and not the doubled-up length of the encoded
           string.

           Changing the value of "LongReadLen" for a statement handle after it has been "prepare"'d will
           typically have no effect, so it's common to set "LongReadLen" on the $dbh before calling
           "prepare".

           For most drivers the value used here has a direct effect on the memory used by the statement
           handle while it's active, so don't be too generous. If you can't be sure what value to use you
           could execute an extra select statement to determine the longest value.  For example:

             $dbh-&gt;{LongReadLen} = $dbh-&gt;selectrow_array(qq{
                 SELECT MAX(OCTET_LENGTH(long_column_name))
                 FROM table WHERE ...
             });
             $sth = $dbh-&gt;prepare(qq{
                 SELECT long_column_name, ... FROM table WHERE ...
             });

           You may need to take extra care if the table can be modified between the first select and the
           second being executed. You may also need to use a different function if <u>OCTET</u><b>_</b><u>LENGTH()</u> does not
           work for long types in your database. For example, for Sybase use <u>DATALENGTH()</u> and for Oracle use
           <u>LENGTHB()</u>.

           See also "LongTruncOk" for information on truncation of long types.

       "LongTruncOk" (boolean, inherited)
           The "LongTruncOk" attribute may be used to control the effect of fetching a long field value
           which has been truncated (typically because it's longer than the value of the "LongReadLen"
           attribute).

           By default, "LongTruncOk" is false and so fetching a long value that needs to be truncated will
           cause the fetch to fail.  (Applications should always be sure to check for errors after a fetch
           loop in case an error, such as a divide by zero or long field truncation, caused the fetch to
           terminate prematurely.)

           If a fetch fails due to a long field truncation when "LongTruncOk" is false, many drivers will
           allow you to continue fetching further rows.

           See also "LongReadLen".

       "TaintIn" (boolean, inherited)
           If the "TaintIn" attribute is set to a true value <u>and</u> Perl is running in taint mode (e.g.,
           started with the "-T" option), then all the arguments to most DBI method calls are checked for
           being tainted. <u>This</u> <u>may</u> <u>change.</u>

           The attribute defaults to off, even if Perl is in taint mode.  See perlsec for more about taint
           mode.  If Perl is not running in taint mode, this attribute has no effect.

           When fetching data that you trust you can turn off the TaintIn attribute, for that statement
           handle, for the duration of the fetch loop.

           The "TaintIn" attribute was added in DBI 1.31.

       "TaintOut" (boolean, inherited)
           If the "TaintOut" attribute is set to a true value <u>and</u> Perl is running in taint mode (e.g.,
           started with the "-T" option), then most data fetched from the database is considered tainted.
           <u>This</u> <u>may</u> <u>change.</u>

           The attribute defaults to off, even if Perl is in taint mode.  See perlsec for more about taint
           mode.  If Perl is not running in taint mode, this attribute has no effect.

           When fetching data that you trust you can turn off the TaintOut attribute, for that statement
           handle, for the duration of the fetch loop.

           Currently only fetched data is tainted. It is possible that the results of other DBI method
           calls, and the value of fetched attributes, may also be tainted in future versions. That change
           may well break your applications unless you take great care now. If you use DBI Taint mode,
           please report your experience and any suggestions for changes.

           The "TaintOut" attribute was added in DBI 1.31.

       "Taint" (boolean, inherited)
           The "Taint" attribute is a shortcut for "TaintIn" and "TaintOut" (it is also present for
           backwards compatibility).

           Setting this attribute sets both "TaintIn" and "TaintOut", and retrieving it returns a true value
           if and only if "TaintIn" and "TaintOut" are both set to true values.

       "Profile" (inherited)
           The "Profile" attribute enables the collection and reporting of method call timing statistics.
           See the DBI::Profile module documentation for <u>much</u> more detail.

           The "Profile" attribute was added in DBI 1.24.

       "private_your_module_name_*"
           The DBI provides a way to store extra information in a DBI handle as "private" attributes. The
           DBI will allow you to store and retrieve any attribute which has a name starting with
           ""private_"".

           It is <u>strongly</u> recommended that you use just <u>one</u> private attribute (e.g., use a hash ref) <u>and</u>
           give it a long and unambiguous name that includes the module or application name that the
           attribute relates to (e.g., ""private_YourFullModuleName_thingy"").

           Because of the way the Perl tie mechanism works you cannot reliably use the "||=" operator
           directly to initialise the attribute, like this:

             my $foo = $dbh-&gt;{private_yourmodname_foo} ||= { ... }; # WRONG

           you should use a two step approach like this:

             my $foo = $dbh-&gt;{private_yourmodname_foo};
             $foo ||= $dbh-&gt;{private_yourmodname_foo} = { ... };

           This attribute is primarily of interest to people sub-classing DBI.

<b>DBI</b> <b>DATABASE</b> <b>HANDLE</b> <b>OBJECTS</b>
       This section covers the methods and attributes associated with database handles.

       <b>Database</b> <b>Handle</b> <b>Methods</b>

       The following methods are specified for DBI database handles:

       "clone"
             $new_dbh = $dbh-&gt;clone();
             $new_dbh = $dbh-&gt;clone(\%attr);

           The "clone" method duplicates the $dbh connection by connecting with the same parameters ($dsn,
           $user, $password) as originally used.

           The attributes for the cloned connect are the same as those used for the original connect, with
           some other attribute merged over them depending on the \%attr parameter.

           If \%attr is given then the attributes it contains are merged into the original attributes and
           override any with the same names.  Effectively the same as doing:

             %attribues_used = ( %original_attributes, %attr );

           If \%attr is not given then it defaults to a hash containing all the attributes in the attribute
           cache of $dbh excluding any non-code references, plus the main boolean attributes (RaiseError,
           PrintError, AutoCommit, etc.). This behaviour is subject to change.

           The clone method can be used even if the database handle is disconnected.

           The "clone" method was added in DBI 1.33. It is very new and likely to change.

       "data_sources"
             @ary = $dbh-&gt;data_sources();
             @ary = $dbh-&gt;data_sources(\%attr);

           Returns a list of data sources (databases) available via the $dbh driver's <u>data</u><b>_</b><u>sources()</u> method,
           plus any extra data sources that the driver can discover via the connected $dbh. Typically the
           extra data sources are other databases managed by the same server process that the $dbh is
           connected to.

           Data sources are returned in a form suitable for passing to the "connect" method (that is, they
           will include the ""dbi:$driver:"" prefix).

           The <u>data</u><b>_</b><u>sources()</u> method, for a $dbh, was added in DBI 1.38.

       "do"
             $rows = $dbh-&gt;do($statement)           or die $dbh-&gt;errstr;
             $rows = $dbh-&gt;do($statement, \%attr)   or die $dbh-&gt;errstr;
             $rows = $dbh-&gt;do($statement, \%attr, @bind_values) or die ...

           Prepare and execute a single statement. Returns the number of rows affected or "undef" on error.
           A return value of "-1" means the number of rows is not known, not applicable, or not available.

           This method is typically most useful for <u>non</u>-"SELECT" statements that either cannot be prepared
           in advance (due to a limitation of the driver) or do not need to be executed repeatedly. It
           should not be used for "SELECT" statements because it does not return a statement handle (so you
           can't fetch any data).

           The default "do" method is logically similar to:

             sub do {
                 my($dbh, $statement, $attr, @bind_values) = @_;
                 my $sth = $dbh-&gt;prepare($statement, $attr) or return undef;
                 $sth-&gt;execute(@bind_values) or return undef;
                 my $rows = $sth-&gt;rows;
                 ($rows == 0) ? "0E0" : $rows; # always return true if no error
             }

           For example:

             my $rows_deleted = $dbh-&gt;do(q{
                 DELETE FROM table
                 WHERE status = ?
             }, undef, 'DONE') or die $dbh-&gt;errstr;

           Using placeholders and @bind_values with the "do" method can be useful because it avoids the need
           to correctly quote any variables in the $statement. But if you'll be executing the statement many
           times then it's more efficient to "prepare" it once and call "execute" many times instead.

           The "q{...}" style quoting used in this example avoids clashing with quotes that may be used in
           the SQL statement. Use the double-quote-like "qq{...}" operator if you want to interpolate
           variables into the string.  See "Quote and Quote-like Operators" in perlop for more details.

       "last_insert_id"
             $rv = $dbh-&gt;last_insert_id($catalog, $schema, $table, $field);
             $rv = $dbh-&gt;last_insert_id($catalog, $schema, $table, $field, \%attr);

           Returns a value 'identifying' the row just inserted, if possible.  Typically this would be a
           value assigned by the database server to a column with an <u>auto</u><b>_</b><u>increment</u> or <u>serial</u> type.  Returns
           undef if the driver does not support the method or can't determine the value.

           The $catalog, $schema, $table, and $field parameters may be required for some drivers (see
           below).  If you don't know the parameter values and your driver does not need them, then use
           "undef" for each.

           There are several caveats to be aware of with this method if you want to use it for portable
           applications:

           <b>*</b> For some drivers the value may only available immediately after the insert statement has
           executed (e.g., mysql, Informix).

           <b>*</b> For some drivers the $catalog, $schema, $table, and $field parameters are required, for others
           they are ignored (e.g., mysql).

           <b>*</b> Drivers may return an indeterminate value if no insert has been performed yet.

           <b>*</b> For some drivers the value may only be available if placeholders have <u>not</u> been used (e.g.,
           Sybase, MS SQL). In this case the value returned would be from the last non-placeholder insert
           statement.

           <b>*</b> Some drivers may need driver-specific hints about how to get the value. For example, being told
           the name of the database 'sequence' object that holds the value. Any such hints are passed as
           driver-specific attributes in the \%attr parameter.

           <b>*</b> If the underlying database offers nothing better, then some drivers may attempt to implement
           this method by executing ""select max($field) from $table"". Drivers using any approach like this
           should issue a warning if "AutoCommit" is true because it is generally unsafe - another process
           may have modified the table between your insert and the select. For situations where you know it
           is safe, such as when you have locked the table, you can silence the warning by passing "Warn" =&gt;
           0 in \%attr.

           <b>*</b> If no insert has been performed yet, or the last insert failed, then the value is
           implementation defined.

           Given all the caveats above, it's clear that this method must be used with care.

           The "last_insert_id" method was added in DBI 1.38.

       "selectrow_array"
             @row_ary = $dbh-&gt;selectrow_array($statement);
             @row_ary = $dbh-&gt;selectrow_array($statement, \%attr);
             @row_ary = $dbh-&gt;selectrow_array($statement, \%attr, @bind_values);

           This utility method combines "prepare", "execute" and "fetchrow_array" into a single call. If
           called in a list context, it returns the first row of data from the statement.  The $statement
           parameter can be a previously prepared statement handle, in which case the "prepare" is skipped.

           If any method fails, and "RaiseError" is not set, "selectrow_array" will return an empty list.

           If called in a scalar context for a statement handle that has more than one column, it is
           undefined whether the driver will return the value of the first column or the last. So don't do
           that.  Also, in a scalar context, an "undef" is returned if there are no more rows or if an error
           occurred. That "undef" can't be distinguished from an "undef" returned because the first field
           value was NULL.  For these reasons you should exercise some caution if you use "selectrow_array"
           in a scalar context, or just don't do that.

       "selectrow_arrayref"
             $ary_ref = $dbh-&gt;selectrow_arrayref($statement);
             $ary_ref = $dbh-&gt;selectrow_arrayref($statement, \%attr);
             $ary_ref = $dbh-&gt;selectrow_arrayref($statement, \%attr, @bind_values);

           This utility method combines "prepare", "execute" and "fetchrow_arrayref" into a single call. It
           returns the first row of data from the statement.  The $statement parameter can be a previously
           prepared statement handle, in which case the "prepare" is skipped.

           If any method fails, and "RaiseError" is not set, "selectrow_array" will return undef.

       "selectrow_hashref"
             $hash_ref = $dbh-&gt;selectrow_hashref($statement);
             $hash_ref = $dbh-&gt;selectrow_hashref($statement, \%attr);
             $hash_ref = $dbh-&gt;selectrow_hashref($statement, \%attr, @bind_values);

           This utility method combines "prepare", "execute" and "fetchrow_hashref" into a single call. It
           returns the first row of data from the statement.  The $statement parameter can be a previously
           prepared statement handle, in which case the "prepare" is skipped.

           If any method fails, and "RaiseError" is not set, "selectrow_hashref" will return undef.

       "selectall_arrayref"
             $ary_ref = $dbh-&gt;selectall_arrayref($statement);
             $ary_ref = $dbh-&gt;selectall_arrayref($statement, \%attr);
             $ary_ref = $dbh-&gt;selectall_arrayref($statement, \%attr, @bind_values);

           This utility method combines "prepare", "execute" and "fetchall_arrayref" into a single call. It
           returns a reference to an array containing a reference to an array (or hash, see below) for each
           row of data fetched.

           The $statement parameter can be a previously prepared statement handle, in which case the
           "prepare" is skipped. This is recommended if the statement is going to be executed many times.

           If "RaiseError" is not set and any method except "fetchall_arrayref" fails then
           "selectall_arrayref" will return "undef"; if "fetchall_arrayref" fails then it will return with
           whatever data has been fetched thus far. You should check "$sth-&gt;err" afterwards (or use the
           "RaiseError" attribute) to discover if the data is complete or was truncated due to an error.

           The "fetchall_arrayref" method called by "selectall_arrayref" supports a $max_rows parameter. You
           can specify a value for $max_rows by including a '"MaxRows"' attribute in \%attr. In which case
           <u>finish()</u> is called for you after <u>fetchall</u><b>_</b><u>arrayref()</u> returns.

           The "fetchall_arrayref" method called by "selectall_arrayref" also supports a $slice parameter.
           You can specify a value for $slice by including a '"Slice"' or '"Columns"' attribute in \%attr.
           The only difference between the two is that if "Slice" is not defined and "Columns" is an array
           ref, then the array is assumed to contain column index values (which count from 1), rather than
           perl array index values.  In which case the array is copied and each value decremented before
           passing to "/fetchall_arrayref".

           You may often want to fetch an array of rows where each row is stored as a hash. That can be done
           simple using:

             my $emps = $dbh-&gt;selectall_arrayref(
                 "SELECT ename FROM emp ORDER BY ename",
                 { Slice =&gt; {} }
             );
             foreach my $emp ( @$emps ) {
                 print "Employee: $emp-&gt;{ename}\n";
             }

           Or, to fetch into an array instead of an array ref:

             @result = @{ $dbh-&gt;selectall_arrayref($sql, { Slice =&gt; {} }) };

           See "fetchall_arrayref" method for more details.

       "selectall_hashref"
             $hash_ref = $dbh-&gt;selectall_hashref($statement, $key_field);
             $hash_ref = $dbh-&gt;selectall_hashref($statement, $key_field, \%attr);
             $hash_ref = $dbh-&gt;selectall_hashref($statement, $key_field, \%attr, @bind_values);

           This utility method combines "prepare", "execute" and "fetchall_hashref" into a single call. It
           returns a reference to a hash containing one entry, at most, for each row, as returned by
           <u>fetchall</u><b>_</b><u>hashref()</u>.

           The $statement parameter can be a previously prepared statement handle, in which case the
           "prepare" is skipped.  This is recommended if the statement is going to be executed many times.

           The $key_field parameter defines which column, or columns, are used as keys in the returned hash.
           It can either be the name of a single field, or a reference to an array containing multiple field
           names. Using multiple names yields a tree of nested hashes.

           If a row has the same key as an earlier row then it replaces the earlier row.

           If any method except "fetchrow_hashref" fails, and "RaiseError" is not set, "selectall_hashref"
           will return "undef".  If "fetchrow_hashref" fails and "RaiseError" is not set, then it will
           return with whatever data it has fetched thus far. $DBI::err should be checked to catch that.

           See <u>fetchall</u><b>_</b><u>hashref()</u> for more details.

       "selectcol_arrayref"
             $ary_ref = $dbh-&gt;selectcol_arrayref($statement);
             $ary_ref = $dbh-&gt;selectcol_arrayref($statement, \%attr);
             $ary_ref = $dbh-&gt;selectcol_arrayref($statement, \%attr, @bind_values);

           This utility method combines "prepare", "execute", and fetching one column from all the rows,
           into a single call. It returns a reference to an array containing the values of the first column
           from each row.

           The $statement parameter can be a previously prepared statement handle, in which case the
           "prepare" is skipped. This is recommended if the statement is going to be executed many times.

           If any method except "fetch" fails, and "RaiseError" is not set, "selectcol_arrayref" will return
           "undef".  If "fetch" fails and "RaiseError" is not set, then it will return with whatever data it
           has fetched thus far. $DBI::err should be checked to catch that.

           The "selectcol_arrayref" method defaults to pushing a single column value (the first) from each
           row into the result array. However, it can also push another column, or even multiple columns per
           row, into the result array. This behaviour can be specified via a '"Columns"' attribute which
           must be a ref to an array containing the column number or numbers to use. For example:

             # get array of id and name pairs:
             my $ary_ref = $dbh-&gt;selectcol_arrayref("select id, name from table", { Columns=&gt;[1,2] });
             my %hash = @$ary_ref; # build hash from key-value pairs so $hash{$id} =&gt; name

           You can specify a maximum number of rows to fetch by including a '"MaxRows"' attribute in \%attr.

       "prepare"
             $sth = $dbh-&gt;prepare($statement)          or die $dbh-&gt;errstr;
             $sth = $dbh-&gt;prepare($statement, \%attr)  or die $dbh-&gt;errstr;

           Prepares a statement for later execution by the database engine and returns a reference to a
           statement handle object.

           The returned statement handle can be used to get attributes of the statement and invoke the
           "execute" method. See "Statement Handle Methods".

           Drivers for engines without the concept of preparing a statement will typically just store the
           statement in the returned handle and process it when "$sth-&gt;execute" is called. Such drivers are
           unlikely to give much useful information about the statement, such as "$sth-&gt;{NUM_OF_FIELDS}",
           until after "$sth-&gt;execute" has been called. Portable applications should take this into account.

           In general, DBI drivers do not parse the contents of the statement (other than simply counting
           any "Placeholders"). The statement is passed directly to the database engine, sometimes known as
           pass-thru mode. This has advantages and disadvantages. On the plus side, you can access all the
           functionality of the engine being used. On the downside, you're limited if you're using a simple
           engine, and you need to take extra care if writing applications intended to be portable between
           engines.

           Portable applications should not assume that a new statement can be prepared and/or executed
           while still fetching results from a previous statement.

           Some command-line SQL tools use statement terminators, like a semicolon, to indicate the end of a
           statement. Such terminators should not normally be used with the DBI.

       "prepare_cached"
             $sth = $dbh-&gt;prepare_cached($statement)
             $sth = $dbh-&gt;prepare_cached($statement, \%attr)
             $sth = $dbh-&gt;prepare_cached($statement, \%attr, $if_active)

           Like "prepare" except that the statement handle returned will be stored in a hash associated with
           the $dbh. If another call is made to "prepare_cached" with the same $statement and %attr
           parameter values, then the corresponding cached $sth will be returned without contacting the
           database server.

           The $if_active parameter lets you adjust the behaviour if an already cached statement handle is
           still Active.  There are several alternatives:

           <b>0</b>: A warning will be generated, and <u>finish()</u> will be called on the statement handle before it is
           returned.  This is the default behaviour if $if_active is not passed.
           <b>1</b>: <u>finish()</u> will be called on the statement handle, but the warning is suppressed.
           <b>2</b>: Disables any checking.
           <b>3</b>: The existing active statement handle will be removed from the cache and a new statement handle
           prepared and cached in its place. This is the safest option because it doesn't affect the state
           of the old handle, it just removes it from the cache. [Added in DBI 1.40]

           Here are some examples of "prepare_cached":

             sub insert_hash {
               my ($table, $field_values) = @_;
               # sort to keep field order, and thus sql, stable for prepare_cached
               my @fields = sort keys %$field_values;
               my @values = @{$field_values}{@fields};
               my $sql = sprintf "insert into %s (%s) values (%s)",
                   $table, join(",", @fields), join(",", ("?")x@fields);
               my $sth = $dbh-&gt;prepare_cached($sql);
               return $sth-&gt;execute(@values);
             }

             sub search_hash {
               my ($table, $field_values) = @_;
               # sort to keep field order, and thus sql, stable for prepare_cached
               my @fields = sort keys %$field_values;
               my @values = @{$field_values}{@fields};
               my $qualifier = "";
               $qualifier = "where ".join(" and ", map { "$_=?" } @fields) if @fields;
               $sth = $dbh-&gt;prepare_cached("SELECT * FROM $table $qualifier");
               return $dbh-&gt;selectall_arrayref($sth, {}, @values);
             }

           <u>Caveat</u> <u>emptor:</u> This caching can be useful in some applications, but it can also cause problems
           and should be used with care. Here is a contrived case where caching would cause a significant
           problem:

             my $sth = $dbh-&gt;prepare_cached('SELECT * FROM foo WHERE bar=?');
             $sth-&gt;execute(...);
             while (my $data = $sth-&gt;fetchrow_hashref) {

               # later, in some other code called within the loop...
               my $sth2 = $dbh-&gt;prepare_cached('SELECT * FROM foo WHERE bar=?');
               $sth2-&gt;execute(...);
               while (my $data2 = $sth2-&gt;fetchrow_arrayref) {
                 do_stuff(...);
               }
             }

           In this example, since both handles are preparing the exact same statement, $sth2 will not be its
           own statement handle, but a duplicate of $sth returned from the cache. The results will certainly
           not be what you expect.  Typically the the inner fetch loop will work normally, fetching all the
           records and terminating when there are no more, but now $sth is the same as $sth2 the outer fetch
           loop will also terminate.

           You'll know if you run into this problem because <u>prepare</u><b>_</b><u>cached()</u> will generate a warning by
           default (when $if_active is false).

           The cache used by <u>prepare</u><b>_</b><u>cached()</u> is keyed by both the statement and any attributes so you can
           also avoid this issue by doing something like:

             $sth = $dbh-&gt;prepare_cached("...", { dbi_dummy =&gt; __FILE__.__LINE__ });

           which will ensure that prepare_cached only returns statements cached by that line of code in that
           source file.

       "commit"
             $rc  = $dbh-&gt;commit     or die $dbh-&gt;errstr;

           Commit (make permanent) the most recent series of database changes if the database supports
           transactions and AutoCommit is off.

           If "AutoCommit" is on, then calling "commit" will issue a "commit ineffective with AutoCommit"
           warning.

           See also "Transactions" in the "FURTHER INFORMATION" section below.

       "rollback"
             $rc  = $dbh-&gt;rollback   or die $dbh-&gt;errstr;

           Rollback (undo) the most recent series of uncommitted database changes if the database supports
           transactions and AutoCommit is off.

           If "AutoCommit" is on, then calling "rollback" will issue a "rollback ineffective with
           AutoCommit" warning.

           See also "Transactions" in the "FURTHER INFORMATION" section below.

       "begin_work"
             $rc  = $dbh-&gt;begin_work   or die $dbh-&gt;errstr;

           Enable transactions (by turning "AutoCommit" off) until the next call to "commit" or "rollback".
           After the next "commit" or "rollback", "AutoCommit" will automatically be turned on again.

           If "AutoCommit" is already off when "begin_work" is called then it does nothing except return an
           error. If the driver does not support transactions then when "begin_work" attempts to set
           "AutoCommit" off the driver will trigger a fatal error.

           See also "Transactions" in the "FURTHER INFORMATION" section below.

       "disconnect"
             $rc = $dbh-&gt;disconnect  or warn $dbh-&gt;errstr;

           Disconnects the database from the database handle. "disconnect" is typically only used before
           exiting the program. The handle is of little use after disconnecting.

           The transaction behaviour of the "disconnect" method is, sadly, undefined.  Some database systems
           (such as Oracle and Ingres) will automatically commit any outstanding changes, but others (such
           as Informix) will rollback any outstanding changes.  Applications not using "AutoCommit" should
           explicitly call "commit" or "rollback" before calling "disconnect".

           The database is automatically disconnected by the "DESTROY" method if still connected when there
           are no longer any references to the handle.  The "DESTROY" method for each driver should
           implicitly call "rollback" to undo any uncommitted changes. This is vital behaviour to ensure
           that incomplete transactions don't get committed simply because Perl calls "DESTROY" on every
           object before exiting. Also, do not rely on the order of object destruction during "global
           destruction", as it is undefined.

           Generally, if you want your changes to be commited or rolled back when you disconnect, then you
           should explicitly call "commit" or "rollback" before disconnecting.

           If you disconnect from a database while you still have active statement handles (e.g., SELECT
           statement handles that may have more data to fetch), you will get a warning. The warning may
           indicate that a fetch loop terminated early, perhaps due to an uncaught error.  To avoid the
           warning call the "finish" method on the active handles.

       "ping"
             $rc = $dbh-&gt;ping;

           Attempts to determine, in a reasonably efficient way, if the database server is still running and
           the connection to it is still working.  Individual drivers should implement this function in the
           most suitable manner for their database engine.

           The current <u>default</u> implementation always returns true without actually doing anything. Actually,
           it returns ""0 but true"" which is true but zero. That way you can tell if the return value is
           genuine or just the default. Drivers should override this method with one that does the right
           thing for their type of database.

           Few applications would have direct use for this method. See the specialized Apache::DBI module
           for one example usage.

       "get_info"
             $value = $dbh-&gt;get_info( $info_type );

           Returns information about the implementation, i.e. driver and data source capabilities,
           restrictions etc. It returns "undef" for unknown or unimplemented information types. For example:

             $database_version  = $dbh-&gt;get_info(  18 ); # SQL_DBMS_VER
             $max_select_tables = $dbh-&gt;get_info( 106 ); # SQL_MAXIMUM_TABLES_IN_SELECT

           See "Standards Reference Information" for more detailed information about the information types
           and their meanings and possible return values.

           The DBI::Const::GetInfoType module exports a %GetInfoType hash that can be used to map info type
           names to numbers. For example:

             $database_version = $dbh-&gt;get_info( $GetInfoType{SQL_DBMS_VER} );

           The names are a merging of the ANSI and ODBC standards (which differ in some cases). See
           DBI::Const::GetInfoType for more details.

           Because some DBI methods make use of <u>get</u><b>_</b><u>info()</u>, drivers are strongly encouraged to support <u>at</u>
           <u>least</u> the following very minimal set of information types to ensure the DBI itself works
           properly:

            Type  Name                        Example A     Example B
            ----  --------------------------  ------------  ----------------<font color="#ffffff" class="whiteout">17&nbsp;---------------17</font>
              17  SQL_DBMS_NAME               'ACCESS'      'Oracle'
              18  SQL_DBMS_VER                '03.50.0000'  '08.01.0721 ...'
              29  SQL_IDENTIFIER_QUOTE_CHAR   '`'           '"'
              41  SQL_CATALOG_NAME_SEPARATOR  '.'           '@'
             114  SQL_CATALOG_LOCATION        1             2

       "table_info"
             $sth = $dbh-&gt;table_info( $catalog, $schema, $table, $type );
             $sth = $dbh-&gt;table_info( $catalog, $schema, $table, $type, \%attr );

           Returns an active statement handle that can be used to fetch information about tables and views
           that exist in the database.

           The arguments $catalog, $schema and $table may accept search patterns according to the
           database/driver, for example: $table = '%FOO%'; Remember that the underscore character ('"_"') is
           a search pattern that means match any character, so 'FOO_%' is the same as 'FOO%' and 'FOO_BAR%'
           will match names like 'FOO1BAR'.

           The value of $type is a comma-separated list of one or more types of tables to be returned in the
           result set. Each value may optionally be quoted, e.g.:

             $type = "TABLE";
             $type = "'TABLE','VIEW'";

           In addition the following special cases may also be supported by some drivers:

              If the value of $catalog is '%' and $schema and $table name are empty strings, the result set
               contains a list of catalog names.  For example:

                 $sth = $dbh-&gt;table_info('%', '', '');

              If the value of $schema is '%' and $catalog and $table are empty strings, the result set
               contains a list of schema names.

              If the value of $type is '%' and $catalog, $schema, and $table are all empty strings, the
               result set contains a list of table types.

           If your driver doesn't support one or more of the selection filter parameters then you may get
           back more than you asked for and can do the filtering yourself.

           This method can be expensive, and can return a large amount of data.  (For example, small Oracle
           installation returns over 2000 rows.)  So it's a good idea to use the filters to limit the data
           as much as possible.

           The statement handle returned has at least the following fields in the order show below. Other
           fields, after these, may also be present.

           <b>TABLE_CAT</b>: Table catalog identifier. This field is NULL ("undef") if not applicable to the data
           source, which is usually the case. This field is empty if not applicable to the table.

           <b>TABLE_SCHEM</b>: The name of the schema containing the TABLE_NAME value.  This field is NULL
           ("undef") if not applicable to data source, and empty if not applicable to the table.

           <b>TABLE_NAME</b>: Name of the table (or view, synonym, etc).

           <b>TABLE_TYPE</b>: One of the following: "TABLE", "VIEW", "SYSTEM TABLE", "GLOBAL TEMPORARY", "LOCAL
           TEMPORARY", "ALIAS", "SYNONYM" or a type identifier that is specific to the data source.

           <b>REMARKS</b>: A description of the table. May be NULL ("undef").

           Note that "table_info" might not return records for all tables.  Applications can use any valid
           table regardless of whether it's returned by "table_info".

           See also "tables", "Catalog Methods" and "Standards Reference Information".

       "column_info"
             $sth = $dbh-&gt;column_info( $catalog, $schema, $table, $column );

           Returns an active statement handle that can be used to fetch information about columns in
           specified tables.

           The arguments $schema, $table and $column may accept search patterns according to the
           database/driver, for example: $table = '%FOO%';

           Note: The support for the selection criteria is driver specific. If the driver doesn't support
           one or more of them then you may get back more than you asked for and can do the filtering
           yourself.

           The statement handle returned has at least the following fields in the order shown below. Other
           fields, after these, may also be present.

           <b>TABLE_CAT</b>: The catalog identifier.  This field is NULL ("undef") if not applicable to the data
           source, which is often the case.  This field is empty if not applicable to the table.

           <b>TABLE_SCHEM</b>: The schema identifier.  This field is NULL ("undef") if not applicable to the data
           source, and empty if not applicable to the table.

           <b>TABLE_NAME</b>: The table identifier.  Note: A driver may provide column metadata not only for base
           tables, but also for derived objects like SYNONYMS etc.

           <b>COLUMN_NAME</b>: The column identifier.

           <b>DATA_TYPE</b>: The concise data type code.

           <b>TYPE_NAME</b>: A data source dependent data type name.

           <b>COLUMN_SIZE</b>: The column size.  This is the maximum length in characters for character data types,
           the number of digits or bits for numeric data types or the length in the representation of
           temporal types.  See the relevant specifications for detailed information.

           <b>BUFFER_LENGTH</b>: The length in bytes of transferred data.

           <b>DECIMAL_DIGITS</b>: The total number of significant digits to the right of the decimal point.

           <b>NUM_PREC_RADIX</b>: The radix for numeric precision.  The value is 10 or 2 for numeric data types and
           NULL ("undef") if not applicable.

           <b>NULLABLE</b>: Indicates if a column can accept NULLs.  The following values are defined:

             SQL_NO_NULLS          0
             SQL_NULLABLE          1
             SQL_NULLABLE_UNKNOWN  2

           <b>REMARKS</b>: A description of the column.

           <b>COLUMN_DEF</b>: The default value of the column.

           <b>SQL_DATA_TYPE</b>: The SQL data type.

           <b>SQL_DATETIME_SUB</b>: The subtype code for datetime and interval data types.

           <b>CHAR_OCTET_LENGTH</b>: The maximum length in bytes of a character or binary data type column.

           <b>ORDINAL_POSITION</b>: The column sequence number (starting with 1).

           <b>IS_NULLABLE</b>: Indicates if the column can accept NULLs.  Possible values are: 'NO', 'YES' and ''.

           SQL/CLI defines the following additional columns:

             CHAR_SET_CAT
             CHAR_SET_SCHEM
             CHAR_SET_NAME
             COLLATION_CAT
             COLLATION_SCHEM
             COLLATION_NAME
             UDT_CAT
             UDT_SCHEM
             UDT_NAME
             DOMAIN_CAT
             DOMAIN_SCHEM
             DOMAIN_NAME
             SCOPE_CAT
             SCOPE_SCHEM
             SCOPE_NAME
             MAX_CARDINALITY
             DTD_IDENTIFIER
             IS_SELF_REF

           Drivers capable of supplying any of those values should do so in the corresponding column and
           supply undef values for the others.

           Drivers wishing to provide extra database/driver specific information should do so in extra
           columns beyond all those listed above, and use lowercase field names with the driver-specific
           prefix (i.e., 'ora_...'). Applications accessing such fields should do so by name and not by
           column number.

           The result set is ordered by TABLE_CAT, TABLE_SCHEM, TABLE_NAME and ORDINAL_POSITION.

           Note: There is some overlap with statement attributes (in perl) and SQLDescribeCol (in ODBC).
           However, SQLColumns provides more metadata.

           See also "Catalog Methods" and "Standards Reference Information".

       "primary_key_info"
             $sth = $dbh-&gt;primary_key_info( $catalog, $schema, $table );

           Returns an active statement handle that can be used to fetch information about columns that make
           up the primary key for a table.  The arguments don't accept search patterns (unlike
           <u>table</u><b>_</b><u>info()</u>).

           For example:

             $sth = $dbh-&gt;primary_key_info( undef, $user, 'foo' );
             $data = $sth-&gt;fetchall_arrayref;

           The statement handle will return one row per column, ordered by TABLE_CAT, TABLE_SCHEM,
           TABLE_NAME, and KEY_SEQ.  If there is no primary key then the statement handle will fetch no
           rows.

           Note: The support for the selection criteria, such as $catalog, is driver specific.  If the
           driver doesn't support catalogs and/or schemas, it may ignore these criteria.

           The statement handle returned has at least the following fields in the order shown below. Other
           fields, after these, may also be present.

           <b>TABLE_CAT</b>: The catalog identifier.  This field is NULL ("undef") if not applicable to the data
           source, which is often the case.  This field is empty if not applicable to the table.

           <b>TABLE_SCHEM</b>: The schema identifier.  This field is NULL ("undef") if not applicable to the data
           source, and empty if not applicable to the table.

           <b>TABLE_NAME</b>: The table identifier.

           <b>COLUMN_NAME</b>: The column identifier.

           <b>KEY_SEQ</b>: The column sequence number (starting with 1).  Note: This field is named
           <b>ORDINAL_POSITION</b> in SQL/CLI.

           <b>PK_NAME</b>: The primary key constraint identifier.  This field is NULL ("undef") if not applicable
           to the data source.

           See also "Catalog Methods" and "Standards Reference Information".

       "primary_key"
             @key_column_names = $dbh-&gt;primary_key( $catalog, $schema, $table );

           Simple interface to the <u>primary</u><b>_</b><u>key</u><b>_</b><u>info()</u> method. Returns a list of the column names that
           comprise the primary key of the specified table.  The list is in primary key column sequence
           order.  If there is no primary key then an empty list is returned.

       "foreign_key_info"
             $sth = $dbh-&gt;foreign_key_info( $pk_catalog, $pk_schema, $pk_table
                                          , $fk_catalog, $fk_schema, $fk_table );

             $sth = $dbh-&gt;foreign_key_info( $pk_catalog, $pk_schema, $pk_table
                                          , $fk_catalog, $fk_schema, $fk_table
                                          , \%attr );

           Returns an active statement handle that can be used to fetch information about foreign keys in
           and/or referencing the specified <!-- a -->table(s)<!-- /a -->.  The arguments don't accept search patterns (unlike
           <u>table</u><b>_</b><u>info()</u>).

           $pk_catalog, $pk_schema, $pk_table identify the primary (unique) key table (<b>PKT</b>).

           $fk_catalog, $fk_schema, $fk_table identify the foreign key table (<b>FKT</b>).

           If both <b>PKT</b> and <b>FKT</b> are given, the function returns the foreign key, if any, in table <b>FKT</b> that
           refers to the primary (unique) key of table <b>PKT</b>.  (Note: In SQL/CLI, the result is
           implementation-defined.)

           If only <b>PKT</b> is given, then the result set contains the primary key of that table and all foreign
           keys that refer to it.

           If only <b>FKT</b> is given, then the result set contains all foreign keys in that table and the primary
           keys to which they refer.  (Note: In SQL/CLI, the result includes unique keys too.)

           For example:

             $sth = $dbh-&gt;foreign_key_info( undef, $user, 'master');
             $sth = $dbh-&gt;foreign_key_info( undef, undef,   undef , undef, $user, 'detail');
             $sth = $dbh-&gt;foreign_key_info( undef, $user, 'master', undef, $user, 'detail');

           Note: The support for the selection criteria, such as $catalog, is driver specific.  If the
           driver doesn't support catalogs and/or schemas, it may ignore these criteria.

           The statement handle returned has the following fields in the order shown below.  Because ODBC
           never includes unique keys, they define different columns in the result set than SQL/CLI. SQL/CLI
           column names are shown in parentheses.

           <b>PKTABLE_CAT</b>    <b>(</b> <b>UK_TABLE_CAT</b>      <b>)</b>: The primary (unique) key table catalog identifier.  This
           field is NULL ("undef") if not applicable to the data source, which is often the case.  This
           field is empty if not applicable to the table.

           <b>PKTABLE_SCHEM</b>  <b>(</b> <b>UK_TABLE_SCHEM</b>    <b>)</b>: The primary (unique) key table schema identifier.  This
           field is NULL ("undef") if not applicable to the data source, and empty if not applicable to the
           table.

           <b>PKTABLE_NAME</b>   <b>(</b> <b>UK_TABLE_NAME</b>     <b>)</b>: The primary (unique) key table identifier.

           <b>PKCOLUMN_NAME</b>  <b>(UK_COLUMN_NAME</b>    <b>)</b>: The primary (unique) key column identifier.

           <b>FKTABLE_CAT</b>    <b>(</b> <b>FK_TABLE_CAT</b>      <b>)</b>: The foreign key table catalog identifier.  This field is
           NULL ("undef") if not applicable to the data source, which is often the case.  This field is
           empty if not applicable to the table.

           <b>FKTABLE_SCHEM</b>  <b>(</b> <b>FK_TABLE_SCHEM</b>    <b>)</b>: The foreign key table schema identifier.  This field is
           NULL ("undef") if not applicable to the data source, and empty if not applicable to the table.

           <b>FKTABLE_NAME</b>   <b>(</b> <b>FK_TABLE_NAME</b>     <b>)</b>: The foreign key table identifier.

           <b>FKCOLUMN_NAME</b>  <b>(</b> <b>FK_COLUMN_NAME</b>    <b>)</b>: The foreign key column identifier.

           <b>KEY_SEQ</b>        <b>(</b> <b>ORDINAL_POSITION</b>  <b>)</b>: The column sequence number (starting with 1).

           <b>UPDATE_RULE</b>    <b>(</b> <b>UPDATE_RULE</b>       <b>)</b>: The referential action for the UPDATE rule.  The following
           codes are defined:

             CASCADE              0
             RESTRICT             1
             SET NULL             2
             NO ACTION            3
             SET DEFAULT          4

           <b>DELETE_RULE</b>    <b>(</b> <b>DELETE_RULE</b>       <b>)</b>: The referential action for the DELETE rule.  The codes are
           the same as for UPDATE_RULE.

           <b>FK_NAME</b>        <b>(</b> <b>FK_NAME</b>           <b>)</b>: The foreign key name.

           <b>PK_NAME</b>        <b>(</b> <b>UK_NAME</b>           <b>)</b>: The primary (unique) key name.

           <b>DEFERRABILITY</b>  <b>(</b> <b>DEFERABILITY</b>      <b>)</b>: The deferrability of the foreign key constraint.  The
           following codes are defined:

             INITIALLY DEFERRED   5
             INITIALLY IMMEDIATE  6
             NOT DEFERRABLE       7

                          <b>(</b> <b>UNIQUE_OR_PRIMARY</b> <b>)</b>: This column is necessary if a driver includes all candidate
           (i.e. primary and alternate) keys in the result set (as specified by SQL/CLI).  The value of this
           column is UNIQUE if the foreign key references an alternate key and PRIMARY if the foreign key
           references a primary key, or it may be undefined if the driver doesn't have access to the
           information.

           See also "Catalog Methods" and "Standards Reference Information".

       "statistics_info"
           <b>Warning:</b> This method is experimental and may change.

             $sth = $dbh-&gt;statistics_info( $catalog, $schema, $table, $unique_only, $quick );

           Returns an active statement handle that can be used to fetch statistical information about a
           table and its indexes.

           The arguments don't accept search patterns (unlike "table_info").

           If the boolean argument $unique_only is true, only UNIQUE indexes will be returned in the result
           set, otherwise all indexes will be returned.

           If the boolean argument $quick is set, the actual statistical information columns (CARDINALITY
           and PAGES) will only be returned if they are readily available from the server, and might not be
           current.  Some databases may return stale statistics or no statistics at all with this flag set.

           For example:

             $sth = $dbh-&gt;statistics_info( undef, $user, 'foo', 1, 1 );
             $data = $sth-&gt;fetchall_arrayref;

           The statement handle will return at most one row per column name per index, plus at most one row
           for the entire table itself, ordered by NON_UNIQUE, TYPE, INDEX_QUALIFIER, INDEX_NAME, and
           ORDINAL_POSITION.

           Note: The support for the selection criteria, such as $catalog, is driver specific.  If the
           driver doesn't support catalogs and/or schemas, it may ignore these criteria.

           The statement handle returned has at least the following fields in the order shown below. Other
           fields, after these, may also be present.

           <b>TABLE_CAT</b>: The catalog identifier.  This field is NULL ("undef") if not applicable to the data
           source, which is often the case.  This field is empty if not applicable to the table.

           <b>TABLE_SCHEM</b>: The schema identifier.  This field is NULL ("undef") if not applicable to the data
           source, and empty if not applicable to the table.

           <b>TABLE_NAME</b>: The table identifier.

           <b>NON_UNIQUE</b>: Unique index indicator.  Returns 0 for unique indexes, 1 for non-unique indexes

           <b>INDEX_QUALIFIER</b>: Index qualifier identifier.  The identifier that is used to qualify the index
           name when doing a "DROP INDEX"; NULL ("undef") is returned if an index qualifier is not supported
           by the data source.  If a non-NULL (defined) value is returned in this column, it must be used to
           qualify the index name on a "DROP INDEX" statement; otherwise, the TABLE_SCHEM should be used to
           qualify the index name.

           <b>INDEX_NAME</b>: The index identifier.

           <b>TYPE</b>: The type of information being returned.  Can be any of the following values: 'table',
           'btree', 'clustered', 'content', 'hashed', or 'other'.

           In the case that this field is 'table', all fields other than TABLE_CAT, TABLE_SCHEM, TABLE_NAME,
           TYPE, CARDINALITY, and PAGES will be NULL ("undef").

           <b>ORDINAL_POSITION</b>: Column sequence number (starting with 1).

           <b>COLUMN_NAME</b>: The column identifier.

           <b>ASC_OR_DESC</b>: Column sort sequence.  "A" for Ascending, "D" for Descending, or NULL ("undef") if
           not supported for this index.

           <b>CARDINALITY</b>: Cardinality of the table or index.  For indexes, this is the number of unique values
           in the index.  For tables, this is the number of rows in the table.  If not supported, the value
           will be NULL ("undef").

           <b>PAGES</b>: Number of storage pages used by this table or index.  If not supported, the value will be
           NULL ("undef").

           <b>FILTER_CONDITION</b>: The index filter condition as a string.  If the index is not a filtered index,
           or it cannot be determined whether the index is a filtered index, this value is NULL ("undef").
           If the index is a filtered index, but the filter condition cannot be determined, this value is
           the empty string ''.  Otherwise it will be the literal filter condition as a string, such as
           "SALARY &lt;= 4500".

           See also "Catalog Methods" and "Standards Reference Information".

       "tables"
             @names = $dbh-&gt;tables( $catalog, $schema, $table, $type );
             @names = $dbh-&gt;tables;        # deprecated

           Simple interface to <u>table</u><b>_</b><u>info()</u>. Returns a list of matching table names, possibly including a
           catalog/schema prefix.

           See "table_info" for a description of the parameters.

           If "$dbh-&gt;get_info(29)" returns true (29 is SQL_IDENTIFIER_QUOTE_CHAR) then the table names are
           constructed and quoted by "quote_identifier" to ensure they are usable even if they contain
           whitespace or reserved words etc. This means that the table names returned will include quote
           characters.

       "type_info_all"
             $type_info_all = $dbh-&gt;type_info_all;

           Returns a reference to an array which holds information about each data type variant supported by
           the database and driver. The array and its contents should be treated as read-only.

           The first item is a reference to an 'index' hash of "Name ="&gt; "Index" pairs.  The items following
           that are references to arrays, one per supported data type variant. The leading index hash
           defines the names and order of the fields within the arrays that follow it.  For example:

             $type_info_all = [
               {   TYPE_NAME         =&gt; 0,
                   DATA_TYPE         =&gt; 1,
                   COLUMN_SIZE       =&gt; 2,     # was PRECISION originally
                   LITERAL_PREFIX    =&gt; 3,
                   LITERAL_SUFFIX    =&gt; 4,
                   CREATE_PARAMS     =&gt; 5,
                   NULLABLE          =&gt; 6,
                   CASE_SENSITIVE    =&gt; 7,
                   SEARCHABLE        =&gt; 8,
                   UNSIGNED_ATTRIBUTE=&gt; 9,
                   FIXED_PREC_SCALE  =&gt; 10,    # was MONEY originally
                   AUTO_UNIQUE_VALUE =&gt; 11,    # was AUTO_INCREMENT originally
                   LOCAL_TYPE_NAME   =&gt; 12,
                   MINIMUM_SCALE     =&gt; 13,
                   MAXIMUM_SCALE     =&gt; 14,
                   SQL_DATA_TYPE     =&gt; 15,
                   SQL_DATETIME_SUB  =&gt; 16,
                   NUM_PREC_RADIX    =&gt; 17,
                   INTERVAL_PRECISION=&gt; 18,
               },
               [ 'VARCHAR', SQL_VARCHAR,
                   undef, "'","'", undef,0, 1,1,0,0,0,undef,1,255, undef
               ],
               [ 'INTEGER', SQL_INTEGER,
                   undef,  "", "", undef,0, 0,1,0,0,0,undef,0,  0, 10
               ],
             ];

           More than one row may have the same value in the "DATA_TYPE" field if there are different ways to
           spell the type name and/or there are variants of the type with different attributes (e.g., with
           and without "AUTO_UNIQUE_VALUE" set, with and without "UNSIGNED_ATTRIBUTE", etc).

           The rows are ordered by "DATA_TYPE" first and then by how closely each type maps to the
           corresponding ODBC SQL data type, closest first.

           The meaning of the fields is described in the documentation for the "type_info" method.

           An 'index' hash is provided so you don't need to rely on index values defined above.  However,
           using DBD::ODBC with some old ODBC drivers may return older names, shown as comments in the
           example above.  Another issue with the index hash is that the lettercase of the keys is not
           defined. It is usually uppercase, as show here, but drivers may return names with any lettercase.

           Drivers are also free to return extra driver-specific columns of information - though it's
           recommended that they start at column index 50 to leave room for expansion of the DBI/ODBC
           specification.

           The <u>type</u><b>_</b><u>info</u><b>_</b><u>all()</u> method is not normally used directly.  The "type_info" method provides a more
           usable and useful interface to the data.

       "type_info"
             @type_info = $dbh-&gt;type_info($data_type);

           Returns a list of hash references holding information about one or more variants of $data_type.
           The list is ordered by "DATA_TYPE" first and then by how closely each type maps to the
           corresponding ODBC SQL data type, closest first.  If called in a scalar context then only the
           first (best) element is returned.

           If $data_type is undefined or "SQL_ALL_TYPES", then the list will contain hashes for all data
           type variants supported by the database and driver.

           If $data_type is an array reference then "type_info" returns the information for the <u>first</u> type
           in the array that has any matches.

           The keys of the hash follow the same letter case conventions as the rest of the DBI (see "Naming
           Conventions and Name Space"). The following uppercase items should always exist, though may be
           undef:

           TYPE_NAME (string)
               Data type name for use in CREATE TABLE statements etc.

           DATA_TYPE (integer)
               SQL data type number.

           COLUMN_SIZE (integer)
               For numeric types, this is either the total number of digits (if the NUM_PREC_RADIX value is
               10) or the total number of bits allowed in the column (if NUM_PREC_RADIX is 2).

               For string types, this is the maximum size of the string in characters.

               For date and interval types, this is the maximum number of characters needed to display the
               value.

           LITERAL_PREFIX (string)
               Characters used to prefix a literal. A typical prefix is ""'"" for characters, or possibly
               ""0x"" for binary values passed as hexadecimal.  NULL ("undef") is returned for data types
               for which this is not applicable.

           LITERAL_SUFFIX (string)
               Characters used to suffix a literal. Typically ""'"" for characters.  NULL ("undef") is
               returned for data types where this is not applicable.

           CREATE_PARAMS (string)
               Parameter names for data type definition. For example, "CREATE_PARAMS" for a "DECIMAL" would
               be ""precision,scale"" if the DECIMAL type should be declared as "DECIMAL("<u>precision,scale</u>")"
               where <u>precision</u> and <u>scale</u> are integer values.  For a "VARCHAR" it would be ""max length"".
               NULL ("undef") is returned for data types for which this is not applicable.

           NULLABLE (integer)
               Indicates whether the data type accepts a NULL value: 0 or an empty string = no, 1 = yes, 2 =
               unknown.

           CASE_SENSITIVE (boolean)
               Indicates whether the data type is case sensitive in collations and comparisons.

           SEARCHABLE (integer)
               Indicates how the data type can be used in a WHERE clause, as follows:

                 0 - Cannot be used in a WHERE clause
                 1 - Only with a LIKE predicate
                 2 - All comparison operators except LIKE
                 3 - Can be used in a WHERE clause with any comparison operator

           UNSIGNED_ATTRIBUTE (boolean)
               Indicates whether the data type is unsigned.  NULL ("undef") is returned for data types for
               which this is not applicable.

           FIXED_PREC_SCALE (boolean)
               Indicates whether the data type always has the same precision and scale (such as a money
               type).  NULL ("undef") is returned for data types for which this is not applicable.

           AUTO_UNIQUE_VALUE (boolean)
               Indicates whether a column of this data type is automatically set to a unique value whenever
               a new row is inserted.  NULL ("undef") is returned for data types for which this is not
               applicable.

           LOCAL_TYPE_NAME (string)
               Localized version of the "TYPE_NAME" for use in dialog with users.  NULL ("undef") is
               returned if a localized name is not available (in which case "TYPE_NAME" should be used).

           MINIMUM_SCALE (integer)
               The minimum scale of the data type. If a data type has a fixed scale, then "MAXIMUM_SCALE"
               holds the same value.  NULL ("undef") is returned for data types for which this is not
               applicable.

           MAXIMUM_SCALE (integer)
               The maximum scale of the data type. If a data type has a fixed scale, then "MINIMUM_SCALE"
               holds the same value.  NULL ("undef") is returned for data types for which this is not
               applicable.

           SQL_DATA_TYPE (integer)
               This column is the same as the "DATA_TYPE" column, except for interval and datetime data
               types.  For interval and datetime data types, the "SQL_DATA_TYPE" field will return
               "SQL_INTERVAL" or "SQL_DATETIME", and the "SQL_DATETIME_SUB" field below will return the
               subcode for the specific interval or datetime data type. If this field is NULL, then the
               driver does not support or report on interval or datetime subtypes.

           SQL_DATETIME_SUB (integer)
               For interval or datetime data types, where the "SQL_DATA_TYPE" field above is "SQL_INTERVAL"
               or "SQL_DATETIME", this field will hold the <u>subcode</u> for the specific interval or datetime
               data type.  Otherwise it will be NULL ("undef").

               Although not mentioned explicitly in the standards, it seems there is a simple relationship
               between these values:

                 DATA_TYPE == (10 * SQL_DATA_TYPE) + SQL_DATETIME_SUB

           NUM_PREC_RADIX (integer)
               The radix value of the data type. For approximate numeric types, "NUM_PREC_RADIX" contains
               the value 2 and "COLUMN_SIZE" holds the number of bits. For exact numeric types,
               "NUM_PREC_RADIX" contains the value 10 and "COLUMN_SIZE" holds the number of decimal digits.
               NULL ("undef") is returned either for data types for which this is not applicable or if the
               driver cannot report this information.

           INTERVAL_PRECISION (integer)
               The interval leading precision for interval types. NULL is returned either for data types for
               which this is not applicable or if the driver cannot report this information.

           For example, to find the type name for the fields in a select statement you can do:

             @names = map { scalar $dbh-&gt;type_info($_)-&gt;{TYPE_NAME} } @{ $sth-&gt;{TYPE} }

           Since DBI and ODBC drivers vary in how they map their types into the ISO standard types you may
           need to search for more than one type.  Here's an example looking for a usable type to store a
           date:

             $my_date_type = $dbh-&gt;type_info( [ SQL_DATE, SQL_TIMESTAMP ] );

           Similarly, to more reliably find a type to store small integers, you could use a list starting
           with "SQL_SMALLINT", "SQL_INTEGER", "SQL_DECIMAL", etc.

           See also "Standards Reference Information".

       "quote"
             $sql = $dbh-&gt;quote($value);
             $sql = $dbh-&gt;quote($value, $data_type);

           Quote a string literal for use as a literal value in an SQL statement, by escaping any special
           characters (such as quotation marks) contained within the string and adding the required type of
           outer quotation marks.

             $sql = sprintf "SELECT foo FROM bar WHERE baz = %s",
                           $dbh-&gt;quote("Don't");

           For most database types, quote would return 'Don''t' (including the outer quotation marks).

           An undefined $value value will be returned as the string "NULL" (without single quotation marks)
           to match how NULLs are represented in SQL.

           If $data_type is supplied, it is used to try to determine the required quoting behaviour by using
           the information returned by "type_info".  As a special case, the standard numeric types are
           optimized to return $value without calling "type_info".

           Quote will probably <u>not</u> be able to deal with all possible input (such as binary data or data
           containing newlines), and is not related in any way with escaping or quoting shell meta-<font color="#ffffff" class="whiteout">characters.&nbsp;metacharacters.</font>
           characters.

           It is valid for the <u>quote()</u> method to return an SQL expression that evaluates to the desired
           string. For example:

             $quoted = $dbh-&gt;quote("one\ntwo\0three")

           may return something like:

             CONCAT('one', <!-- a -->CHAR(12)<!-- /a -->, 'two', CHAR(0), 'three')

           The <u>quote()</u> method should <u>not</u> be used with "Placeholders and Bind Values".

       "quote_identifier"
             $sql = $dbh-&gt;quote_identifier( $name );
             $sql = $dbh-&gt;quote_identifier( $catalog, $schema, $table, \%attr );

           Quote an identifier (table name etc.) for use in an SQL statement, by escaping any special
           characters (such as double quotation marks) it contains and adding the required type of outer
           quotation marks.

           Undefined names are ignored and the remainder are quoted and then joined together, typically with
           a dot (".") character. For example:

             $id = $dbh-&gt;quote_identifier( undef, 'Her schema', 'My table' );

           would, for most database types, return "Her schema"."My table" (including all the double
           quotation marks).

           If three names are supplied then the first is assumed to be a catalog name and special rules may
           be applied based on what "get_info" returns for SQL_CATALOG_NAME_SEPARATOR (41) and
           SQL_CATALOG_LOCATION (114).  For example, for Oracle:

             $id = $dbh-&gt;quote_identifier( 'link', 'schema', 'table' );

           would return "schema"."table"@"link".

       "take_imp_data"
             $imp_data = $dbh-&gt;take_imp_data;

           Leaves the $dbh in an almost dead, zombie-like, state and returns a binary string of raw
           implementation data from the driver which describes the current database connection. Effectively
           it detaches the underlying database API connection data from the DBI handle.  After calling
           <u>take</u><b>_</b><u>imp</u><b>_</b><u>data()</u>, all other methods except "DESTROY" will generate a warning and return undef.

           Why would you want to do this? You don't, forget I even mentioned it.  Unless, that is, you're
           implementing something advanced like a multi-threaded connection pool. See DBI::Pool.

           The returned $imp_data can be passed as a "dbi_imp_data" attribute to a later <u>connect()</u> call,
           even in a separate thread in the same process, where the driver can use it to 'adopt' the
           existing connection that the implementation data was taken from.

           Some things to keep in mind...

           <b>*</b> the $imp_data holds the only reference to the underlying database API connection data. That
           connection is still 'live' and won't be cleaned up properly unless the $imp_data is used to
           create a new $dbh which is then allowed to <u>disconnect()</u> normally.

           <b>*</b> using the same $imp_data to create more than one other new $dbh at a time may well lead to
           unpleasant problems. Don't do that.

           Any child statement handles are effectively destroyed when <u>take</u><b>_</b><u>imp</u><b>_</b><u>data()</u> is called.

           The "take_imp_data" method was added in DBI 1.36 but wasn't useful till 1.49.

       <b>Database</b> <b>Handle</b> <b>Attributes</b>

       This section describes attributes specific to database handles.

       Changes to these database handle attributes do not affect any other existing or future database
       handles.

       Attempting to set or get the value of an unknown attribute generates a warning, except for private
       driver-specific attributes (which all have names starting with a lowercase letter).

       Example:

         $h-&gt;{AutoCommit} = ...;       # set/write
         ... = $h-&gt;{AutoCommit};       # get/read

       "AutoCommit"  (boolean)
           If true, then database changes cannot be rolled-back (undone).  If false, then database changes
           automatically occur within a "transaction", which must either be committed or rolled back using
           the "commit" or "rollback" methods.

           Drivers should always default to "AutoCommit" mode (an unfortunate choice largely forced on the
           DBI by ODBC and JDBC conventions.)

           Attempting to set "AutoCommit" to an unsupported value is a fatal error.  This is an important
           feature of the DBI. Applications that need full transaction behaviour can set "$dbh-&gt;{AutoCommit}
           = 0" (or set "AutoCommit" to 0 via "connect") without having to check that the value was assigned
           successfully.

           For the purposes of this description, we can divide databases into three categories:

             Databases which don't support transactions at all.
             Databases in which a transaction is always active.
             Databases in which a transaction must be explicitly started (C&lt;'BEGIN WORK'&gt;).

           <b>*</b> <b>Databases</b> <b>which</b> <b>don't</b> <b>support</b> <b>transactions</b> <b>at</b> <b>all</b>

           For these databases, attempting to turn "AutoCommit" off is a fatal error.  "commit" and
           "rollback" both issue warnings about being ineffective while "AutoCommit" is in effect.

           <b>*</b> <b>Databases</b> <b>in</b> <b>which</b> <b>a</b> <b>transaction</b> <b>is</b> <b>always</b> <b>active</b>

           These are typically mainstream commercial relational databases with "ANSI standard" transaction
           behaviour.  If "AutoCommit" is off, then changes to the database won't have any lasting effect
           unless "commit" is called (but see also "disconnect"). If "rollback" is called then any changes
           since the last commit are undone.

           If "AutoCommit" is on, then the effect is the same as if the DBI called "commit" automatically
           after every successful database operation. So calling "commit" or "rollback" explicitly while
           "AutoCommit" is on would be ineffective because the changes would have already been commited.

           Changing "AutoCommit" from off to on will trigger a "commit".

           For databases which don't support a specific auto-commit mode, the driver has to commit each
           statement automatically using an explicit "COMMIT" after it completes successfully (and roll it
           back using an explicit "ROLLBACK" if it fails).  The error information reported to the
           application will correspond to the statement which was executed, unless it succeeded and the
           commit or rollback failed.

           <b>*</b> <b>Databases</b> <b>in</b> <b>which</b> <b>a</b> <b>transaction</b> <b>must</b> <b>be</b> <b>explicitly</b> <b>started</b>

           For these databases, the intention is to have them act like databases in which a transaction is
           always active (as described above).

           To do this, the driver will automatically begin an explicit transaction when "AutoCommit" is
           turned off, or after a "commit" or "rollback" (or when the application issues the next database
           operation after one of those events).

           In this way, the application does not have to treat these databases as a special case.

           See "commit", "disconnect" and "Transactions" for other important notes about transactions.

       "Driver"  (handle)
           Holds the handle of the parent driver. The only recommended use for this is to find the name of
           the driver using:

             $dbh-&gt;{Driver}-&gt;{Name}

       "Name"  (string)
           Holds the "name" of the database. Usually (and recommended to be) the same as the
           ""dbi:DriverName:..."" string used to connect to the database, but with the leading
           ""dbi:DriverName:"" removed.

       "Statement"  (string, read-only)
           Returns the statement string passed to the most recent "prepare" method called in this database
           handle, even if that method failed. This is especially useful where "RaiseError" is enabled and
           the exception handler checks $@ and sees that a 'prepare' method call failed.

       "RowCacheSize"  (integer)
           A hint to the driver indicating the size of the local row cache that the application would like
           the driver to use for future "SELECT" statements.  If a row cache is not implemented, then
           setting "RowCacheSize" is ignored and getting the value returns "undef".

           Some "RowCacheSize" values have special meaning, as follows:

             0 - Automatically determine a reasonable cache size for each C&lt;SELECT&gt;
             1 - Disable the local row cache
            &gt;1 - Cache this many rows
            &lt;0 - Cache as many rows that will fit into this much memory for each C&lt;SELECT&gt;.

           Note that large cache sizes may require a very large amount of memory (<u>cached</u> <u>rows</u> <u>*</u> <u>maximum</u> <u>size</u>
           <u>of</u> <u>row</u>). Also, a large cache will cause a longer delay not only for the first fetch, but also
           whenever the cache needs refilling.

           See also the "RowsInCache" statement handle attribute.

       "Username"  (string)
           Returns the username used to connect to the database.

<b>DBI</b> <b>STATEMENT</b> <b>HANDLE</b> <b>OBJECTS</b>
       This section lists the methods and attributes associated with DBI statement handles.

       <b>Statement</b> <b>Handle</b> <b>Methods</b>

       The DBI defines the following methods for use on DBI statement handles:

       "bind_param"
             $sth-&gt;bind_param($p_num, $bind_value)
             $sth-&gt;bind_param($p_num, $bind_value, \%attr)
             $sth-&gt;bind_param($p_num, $bind_value, $bind_type)

           The "bind_param" method takes a copy of $bind_value and associates it (binds it) with a
           placeholder, identified by $p_num, embedded in the prepared statement. Placeholders are indicated
           with question mark character ("?"). For example:

             $dbh-&gt;{RaiseError} = 1;        # save having to check each method call
             $sth = $dbh-&gt;prepare("SELECT name, age FROM people WHERE name LIKE ?");
             $sth-&gt;bind_param(1, "John%");  # placeholders are numbered from 1
             $sth-&gt;execute;
             DBI::dump_results($sth);

           See "Placeholders and Bind Values" for more information.

           <b>Data</b> <b>Types</b> <b>for</b> <b>Placeholders</b>

           The "\%attr" parameter can be used to hint at the data type the placeholder should have. This is
           rarely needed. Typically, the driver is only interested in knowing if the placeholder should be
           bound as a number or a string.

             $sth-&gt;bind_param(1, $value, { TYPE =&gt; SQL_INTEGER });

           As a short-cut for the common case, the data type can be passed directly, in place of the
           "\%attr" hash reference. This example is equivalent to the one above:

             $sth-&gt;bind_param(1, $value, SQL_INTEGER);

           The "TYPE" value indicates the standard (non-driver-specific) type for this parameter. To specify
           the driver-specific type, the driver may support a driver-specific attribute, such as "{ ora_type
           =&gt; 97 }".

           The SQL_INTEGER and other related constants can be imported using

             use DBI qw(:sql_types);

           See "DBI Constants" for more information.

           The data type for a placeholder cannot be changed after the first "bind_param" call. In fact the
           whole \%attr parameter is 'sticky' in the sense that a driver only needs to consider the \%attr
           parameter for the first call, for a given $sth and parameter. After that the driver may ignore
           the \%attr parameter for that placeholder.

           Perl only has string and number scalar data types. All database types that aren't numbers are
           bound as strings and must be in a format the database will understand except where the
           <u>bind</u><b>_</b><u>param()</u> TYPE attribute specifies a type that implies a particular format. For example,
           given:

             $sth-&gt;bind_param(1, $value, SQL_DATETIME);

           the driver should expect $value to be in the ODBC standard SQL_DATETIME format, which is
           'YYYY-MM-DD HH:MM:SS'. Similarly for SQL_DATE, SQL_TIME etc.

           As an alternative to specifying the data type in the "bind_param" call, you can let the driver
           pass the value as the default type ("VARCHAR").  You can then use an SQL function to convert the
           type within the statement.  For example:

             INSERT INTO price(code, price) VALUES (?, CONVERT(MONEY,?))

           The "CONVERT" function used here is just an example. The actual function and syntax will vary
           between different databases and is non-portable.

           See also "Placeholders and Bind Values" for more information.

       "bind_param_inout"
             $rc = $sth-&gt;bind_param_inout($p_num, \$bind_value, $max_len)  or die $sth-&gt;errstr;
             $rv = $sth-&gt;bind_param_inout($p_num, \$bind_value, $max_len, \%attr)     or ...
             $rv = $sth-&gt;bind_param_inout($p_num, \$bind_value, $max_len, $bind_type) or ...

           This method acts like "bind_param", but also enables values to be updated by the statement. The
           statement is typically a call to a stored procedure. The $bind_value must be passed as a
           reference to the actual value to be used.

           Note that unlike "bind_param", the $bind_value variable is not copied when "bind_param_inout" is
           called. Instead, the value in the variable is read at the time "execute" is called.

           The additional $max_len parameter specifies the minimum amount of memory to allocate to
           $bind_value for the new value. If the value returned from the database is too big to fit, then
           the execution should fail. If unsure what value to use, pick a generous length, i.e., a length
           larger than the longest value that would ever be returned.  The only cost of using a larger value
           than needed is wasted memory.

           Undefined values or "undef" are used to indicate null values.  See also "Placeholders and Bind
           Values" for more information.

       "bind_param_array"
             $rc = $sth-&gt;bind_param_array($p_num, $array_ref_or_value)
             $rc = $sth-&gt;bind_param_array($p_num, $array_ref_or_value, \%attr)
             $rc = $sth-&gt;bind_param_array($p_num, $array_ref_or_value, $bind_type)

           The "bind_param_array" method is used to bind an array of values to a placeholder embedded in the
           prepared statement which is to be executed with "execute_array". For example:

             $dbh-&gt;{RaiseError} = 1;        # save having to check each method call
             $sth = $dbh-&gt;prepare("INSERT INTO staff (first_name, last_name, dept) VALUES(?, ?, ?)");
             $sth-&gt;bind_param_array(1, [ 'John', 'Mary', 'Tim' ]);
             $sth-&gt;bind_param_array(2, [ 'Booth', 'Todd', 'Robinson' ]);
             $sth-&gt;bind_param_array(3, "SALES"); # scalar will be reused for each row
             $sth-&gt;execute_array( { ArrayTupleStatus =&gt; \my @tuple_status } );

           The %attr ($bind_type) argument is the same as defined for "bind_param".  Refer to "bind_param"
           for general details on using placeholders.

           (Note that <u>bind</u><b>_</b><u>param</u><b>_</b><u>array()</u> can <u>not</u> be used to expand a placeholder into a list of values for a
           statement like "SELECT foo WHERE bar IN (?)".  A placeholder can only ever represent one value
           per execution.)

           Scalar values, including "undef", may also be bound by "bind_param_array". In which case the same
           value will be used for each "execute" call. Driver-specific implementations may behave
           differently, e.g., when binding to a stored procedure call, some databases may permit mixing
           scalars and arrays as arguments.

           The default implementation provided by DBI (for drivers that have not implemented array binding)
           is to iteratively call "execute" for each parameter tuple provided in the bound arrays.  Drivers
           may provide more optimized implementations using whatever bulk operation support the database API
           provides. The default driver behaviour should match the default DBI behaviour, but always consult
           your driver documentation as there may be driver specific issues to consider.

           Note that the default implementation currently only supports non-data returning statements
           (INSERT, UPDATE, but not SELECT). Also, "bind_param_array" and "bind_param" cannot be mixed in
           the same statement execution, and "bind_param_array" must be used with "execute_array"; using
           "bind_param_array" will have no effect for "execute".

           The "bind_param_array" method was added in DBI 1.22.

       "execute"
             $rv = $sth-&gt;execute                or die $sth-&gt;errstr;
             $rv = $sth-&gt;execute(@bind_values)  or die $sth-&gt;errstr;

           Perform whatever processing is necessary to execute the prepared statement.  An "undef" is
           returned if an error occurs.  A successful "execute" always returns true regardless of the number
           of rows affected, even if it's zero (see below). It is always important to check the return
           status of "execute" (and most other DBI methods) for errors if you're not using "RaiseError".

           For a <u>non</u>-"SELECT" statement, "execute" returns the number of rows affected, if known. If no rows
           were affected, then "execute" returns "0E0", which Perl will treat as 0 but will regard as true.
           Note that it is <u>not</u> an error for no rows to be affected by a statement. If the number of rows
           affected is not known, then "execute" returns -1.

           For "SELECT" statements, execute simply "starts" the query within the database engine. Use one of
           the fetch methods to retrieve the data after calling "execute".  The "execute" method does <u>not</u>
           return the number of rows that will be returned by the query (because most databases can't tell
           in advance), it simply returns a true value.

           You can tell if the statement was a "SELECT" statement by checking if "$sth-&gt;{NUM_OF_FIELDS}" is
           greater than zero after calling "execute".

           If any arguments are given, then "execute" will effectively call "bind_param" for each value
           before executing the statement.  Values bound in this way are usually treated as "SQL_VARCHAR"
           types unless the driver can determine the correct type (which is rare), or unless "bind_param"
           (or "bind_param_inout") has already been used to specify the type.

           If <u>execute()</u> is called on a statement handle that's still active ($sth-&gt;{Active} is true) then it
           should effectively call <u>finish()</u> to tidy up the previous execution results before starting this
           new execution.

       "execute_array"
             $rv = $sth-&gt;execute_array(\%attr) or die $sth-&gt;errstr;
             $rv = $sth-&gt;execute_array(\%attr, @bind_values) or die $sth-&gt;errstr;

           Execute the prepared statement once for each parameter tuple (group of values) provided either in
           the @bind_values, or by prior calls to "bind_param_array", or via a reference passed in \%attr.

           The <u>execute</u><b>_</b><u>array()</u> method returns the number of tuples executed, or "undef" if an error occured.
           Like <u>execute()</u>, a successful <u>execute</u><b>_</b><u>array()</u> always returns true regardless of the number of
           tuples executed, even if it's zero.  See the "ArrayTupleStatus" attribute below for how to
           determine the execution status for each tuple.

           Bind values for the tuples to be executed may be supplied row-wise by an "ArrayTupleFetch"
           attribute, or else column-wise in the @bind_values argument, or else column-wise by prior calls
           to "bind_param_array".

           Where column-wise binding is used (via the @bind_values argument or calls to <u>bind</u><b>_</b><u>param</u><b>_</b><u>array()</u>)
           the maximum number of elements in any one of the bound value arrays determines the number of
           tuples executed. Placeholders with fewer values in their parameter arrays are treated as if
           padded with undef (NULL) values.

           If a scalar value is bound, instead of an array reference, it is treated as a <u>variable</u> length
           array with all elements having the same value. It's does not influence the number of tuples
           executed, so if all bound arrays have zero elements then zero tuples will be executed. If <u>all</u>
           bound values are scalars then one tuple will be executed, making <u>execute</u><b>_</b><u>array()</u> act just like
           <u>execute()</u>.

           The "ArrayTupleFetch" attribute can be used to specify a reference to a subroutine that will be
           called to provide the bind values for each tuple execution. The subroutine should return an
           reference to an array which contains the appropriate number of bind values, or return an undef if
           there is no more data to execute.

           As a convienience, the "ArrayTupleFetch" attribute can also be used to specify a statement
           handle. In which case the <u>fetchrow</u><b>_</b><u>arrayref()</u> method will be called on the given statement handle
           in order to provide the bind values for each tuple execution.

           The values specified via <u>bind</u><b>_</b><u>param</u><b>_</b><u>array()</u> or the @bind_values parameter may be either scalars,
           or arrayrefs.  If any @bind_values are given, then "execute_array" will effectively call
           "bind_param_array" for each value before executing the statement.  Values bound in this way are
           usually treated as "SQL_VARCHAR" types unless the driver can determine the correct type (which is
           rare), or unless "bind_param", "bind_param_inout", "bind_param_array", or
           "bind_param_inout_array" has already been used to specify the type.  See "bind_param_array" for
           details.

           The "ArrayTupleStatus" attribute can be used to specify a reference to an array which will
           receive the execute status of each executed parameter tuple. Note the "ArrayTupleStatus"
           attribute was mandatory until DBI 1.38.

           For tuples which are successfully executed, the element at the same ordinal position in the
           status array is the resulting rowcount.  If the execution of a tuple causes an error, then the
           corresponding status array element will be set to a reference to an array containing the error
           code and error string set by the failed execution.

           If <b>any</b> tuple execution returns an error, "execute_array" will return "undef". In that case, the
           application should inspect the status array to determine which parameter tuples failed.  Some
           databases may not continue executing tuples beyond the first failure. In this case the status
           array will either hold fewer elements, or the elements beyond the failure will be undef.

           If all parameter tuples are successfully executed, "execute_array" returns the number tuples
           executed.  If no tuples were executed, then <u>execute</u><b>_</b><u>array()</u> returns "0E0", just like <u>execute()</u>
           does, which Perl will treat as 0 but will regard as true.

           For example:

             $sth = $dbh-&gt;prepare("INSERT INTO staff (first_name, last_name) VALUES (?, ?)");
             my $tuples = $sth-&gt;execute_array(
                 { ArrayTupleStatus =&gt; \my @tuple_status },
                 \@first_names,
                 \@last_names,
             );
             if ($tuples) {
                 print "Successfully inserted $tuples records\n";
             }
             else {
                 for my $tuple (0..@last_names-1) {
                     my $status = $tuple_status[$tuple];
                     $status = [0, "Skipped"] unless defined $status;
                     next unless ref $status;
                     printf "Failed to insert (%s, %s): %s\n",
                         $first_names[$tuple], $last_names[$tuple], $status-&gt;[1];
                 }
             }

           Support for data returning statements such as SELECT is driver-specific and subject to change. At
           present, the default implementation provided by DBI only supports non-data returning statements.

           Transaction semantics when using array binding are driver and database specific.  If "AutoCommit"
           is on, the default DBI implementation will cause each parameter tuple to be inidividually
           committed (or rolled back in the event of an error). If "AutoCommit" is off, the application is
           responsible for explicitly committing the entire set of bound parameter tuples.  Note that
           different drivers and databases may have different behaviours when some parameter tuples cause
           failures. In some cases, the driver or database may automatically rollback the effect of all
           prior parameter tuples that succeeded in the transaction; other drivers or databases may retain
           the effect of prior successfully executed parameter tuples. Be sure to check your driver and
           database for its specific behaviour.

           Note that, in general, performance will usually be better with "AutoCommit" turned off, and using
           explicit "commit" after each "execute_array" call.

           The "execute_array" method was added in DBI 1.22, and ArrayTupleFetch was added in 1.36.

       "execute_for_fetch"
             $rc = $sth-&gt;execute_for_fetch($fetch_tuple_sub);
             $rc = $sth-&gt;execute_for_fetch($fetch_tuple_sub, \@tuple_status);

           The <u>execute</u><b>_</b><u>for</u><b>_</b><u>fetch()</u> method is used to perform bulk operations and is most often used via the
           <u>execute</u><b>_</b><u>array()</u> method, not directly.

           The fetch subroutine, referenced by $fetch_tuple_sub, is expected to return a reference to an
           array (known as a 'tuple') or undef.

           The <u>execute</u><b>_</b><u>for</u><b>_</b><u>fetch()</u> method calls $fetch_tuple_sub, without any parameters, until it returns a
           false value. Each tuple returned is used to provide bind values for an $sth-&gt;execute(@$tuple)
           call.

           If there were any errors then "undef" is returned and the @tuple_status array can be used to
           discover which tuples failed and with what errors.  If there were no errors then
           <u>execute</u><b>_</b><u>for</u><b>_</b><u>fetch()</u> returns the number of tuples executed. Like <u>execute()</u> and <u>execute</u><b>_</b><u>array()</u> a
           zero is returned as "0E0" so <u>execute</u><b>_</b><u>for</u><b>_</b><u>fetch()</u> is only false on error.

           If \@tuple_status is passed then the execute_for_fetch method uses it to return status
           information. The tuple_status array holds one element per tuple. If the corresponding <u>execute()</u>
           did not fail then the element holds the return value from <u>execute()</u>, which is typically a row
           count. If the <u>execute()</u> did fail then the element holds a reference to an array containing
           ($sth-&gt;err, $sth-&gt;errstr, $sth-&gt;state).

           Although each tuple returned by $fetch_tuple_sub is effectively used to call
           $sth-&gt;execute(@$tuple_array_ref) the exact timing may vary.  Drivers are free to accumulate sets
           of tuples to pass to the database server in bulk group operations for more efficient execution.
           However, the $fetch_tuple_sub is specifically allowed to return the same array reference each
           time (which is what <u>fetchrow</u><b>_</b><u>arrayref()</u> usually does).

           For example:

             my $sel = $dbh1-&gt;prepare("select foo, bar from table1");
             $sel-&gt;execute;

             my $ins = $dbh2-&gt;prepare("insert into table2 (foo, bar) values (?,?)");
             my $fetch_tuple_sub = sub { $sel-&gt;fetchrow_arrayref };

             my @tuple_status;
             $rc = $ins-&gt;execute_for_fetch($fetch_tuple_sub, \@tuple_status);
             my @errors = grep { ref $_ } @tuple_status;

           Similarly, if you already have an array containing the data rows to be processed you'd use a
           subroutine to shift off and return each array ref in turn:

             $ins-&gt;execute_for_fetch( sub { shift @array_of_arrays }, \@tuple_status);

           The "execute_for_fetch" method was added in DBI 1.38.

       "fetchrow_arrayref"
             $ary_ref = $sth-&gt;fetchrow_arrayref;
             $ary_ref = $sth-&gt;fetch;    # alias

           Fetches the next row of data and returns a reference to an array holding the field values.  Null
           fields are returned as "undef" values in the array.  This is the fastest way to fetch data,
           particularly if used with "$sth-&gt;bind_columns".

           If there are no more rows or if an error occurs, then "fetchrow_arrayref" returns an "undef". You
           should check "$sth-&gt;err" afterwards (or use the "RaiseError" attribute) to discover if the
           "undef" returned was due to an error.

           Note that the same array reference is returned for each fetch, so don't store the reference and
           then use it after a later fetch.  Also, the elements of the array are also reused for each row,
           so take care if you want to take a reference to an element. See also "bind_columns".

       "fetchrow_array"
            @ary = $sth-&gt;fetchrow_array;

           An alternative to "fetchrow_arrayref". Fetches the next row of data and returns it as a list
           containing the field values.  Null fields are returned as "undef" values in the list.

           If there are no more rows or if an error occurs, then "fetchrow_array" returns an empty list. You
           should check "$sth-&gt;err" afterwards (or use the "RaiseError" attribute) to discover if the empty
           list returned was due to an error.

           If called in a scalar context for a statement handle that has more than one column, it is
           undefined whether the driver will return the value of the first column or the last. So don't do
           that.  Also, in a scalar context, an "undef" is returned if there are no more rows or if an error
           occurred. That "undef" can't be distinguished from an "undef" returned because the first field
           value was NULL.  For these reasons you should exercise some caution if you use "fetchrow_array"
           in a scalar context.

       "fetchrow_hashref"
            $hash_ref = $sth-&gt;fetchrow_hashref;
            $hash_ref = $sth-&gt;fetchrow_hashref($name);

           An alternative to "fetchrow_arrayref". Fetches the next row of data and returns it as a reference
           to a hash containing field name and field value pairs.  Null fields are returned as "undef"
           values in the hash.

           If there are no more rows or if an error occurs, then "fetchrow_hashref" returns an "undef". You
           should check "$sth-&gt;err" afterwards (or use the "RaiseError" attribute) to discover if the
           "undef" returned was due to an error.

           The optional $name parameter specifies the name of the statement handle attribute. For historical
           reasons it defaults to ""NAME"", however using either ""NAME_lc"" or ""NAME_uc"" is recomended
           for portability.

           The keys of the hash are the same names returned by "$sth-&gt;{$name}". If more than one field has
           the same name, there will only be one entry in the returned hash for those fields.

           Because of the extra work "fetchrow_hashref" and Perl have to perform, it is not as efficient as
           "fetchrow_arrayref" or "fetchrow_array".

           By default a reference to a new hash is returned for each row.  It is likely that a future
           version of the DBI will support an attribute which will enable the same hash to be reused for
           each row. This will give a significant performance boost, but it won't be enabled by default
           because of the risk of breaking old code.

       "fetchall_arrayref"
             $tbl_ary_ref = $sth-&gt;fetchall_arrayref;
             $tbl_ary_ref = $sth-&gt;fetchall_arrayref( $slice );
             $tbl_ary_ref = $sth-&gt;fetchall_arrayref( $slice, $max_rows  );

           The "fetchall_arrayref" method can be used to fetch all the data to be returned from a prepared
           and executed statement handle. It returns a reference to an array that contains one reference per
           row.

           If there are no rows to return, "fetchall_arrayref" returns a reference to an empty array. If an
           error occurs, "fetchall_arrayref" returns the data fetched thus far, which may be none.  You
           should check "$sth-&gt;err" afterwards (or use the "RaiseError" attribute) to discover if the data
           is complete or was truncated due to an error.

           If $slice is an array reference, "fetchall_arrayref" uses "fetchrow_arrayref" to fetch each row
           as an array ref. If the $slice array is not empty then it is used as a slice to select individual
           columns by perl array index number (starting at 0, unlike column and parameter numbers which
           start at 1).

           With no parameters, or if $slice is undefined, "fetchall_arrayref" acts as if passed an empty
           array ref.

           If $slice is a hash reference, "fetchall_arrayref" uses "fetchrow_hashref" to fetch each row as a
           hash reference. If the $slice hash is empty then <u>fetchrow</u><b>_</b><u>hashref()</u> is simply called in a tight
           loop and the keys in the hashes have whatever name lettercase is returned by default from
           fetchrow_hashref.  (See "FetchHashKeyName" attribute.) If the $slice hash is not empty, then it
           is used as a slice to select individual columns by name.  The values of the hash should be set to
           1.  The key names of the returned hashes match the letter case of the names in the parameter
           hash, regardless of the "FetchHashKeyName" attribute.

           For example, to fetch just the first column of every row:

             $tbl_ary_ref = $sth-&gt;fetchall_arrayref([0]);

           To fetch the second to last and last column of every row:

             $tbl_ary_ref = $sth-&gt;fetchall_arrayref([-2,-1]);

           To fetch all fields of every row as a hash ref:

             $tbl_ary_ref = $sth-&gt;fetchall_arrayref({});

           To fetch only the fields called "foo" and "bar" of every row as a hash ref (with keys named "foo"
           and "BAR"):

             $tbl_ary_ref = $sth-&gt;fetchall_arrayref({ foo=&gt;1, BAR=&gt;1 });

           The first two examples return a reference to an array of array refs.  The third and forth return
           a reference to an array of hash refs.

           If $max_rows is defined and greater than or equal to zero then it is used to limit the number of
           rows fetched before returning.  <u>fetchall</u><b>_</b><u>arrayref()</u> can then be called again to fetch more rows.
           This is especially useful when you need the better performance of <u>fetchall</u><b>_</b><u>arrayref()</u> but don't
           have enough memory to fetch and return all the rows in one go. Here's an example:

             my $rows = []; # cache for batches of rows
             while( my $row = ( shift(@$rows) || # get row from cache, or reload cache:
                                shift(@{$rows=$sth-&gt;fetchall_arrayref(undef,10_000)||[]}) )
             ) {
               ...
             }

           That can be the fastest way to fetch and process lots of rows using the DBI, but it depends on
           the relative cost of method calls vs memory allocation.

           A standard "while" loop with column binding is often faster because the cost of allocating memory
           for the batch of rows is greater than the saving by reducing method calls. It's possible that the
           DBI may provide a way to reuse the memory of a previous batch in future, which would then shift
           the balance back towards <u>fetchall</u><b>_</b><u>arrayref()</u>.

       "fetchall_hashref"
             $hash_ref = $sth-&gt;fetchall_hashref($key_field);

           The "fetchall_hashref" method can be used to fetch all the data to be returned from a prepared
           and executed statement handle. It returns a reference to a hash containing a key for each
           distinct value of the $key_field column that was fetched. For each key the corresponding value is
           a reference to a hash containing all the selected columns and their values, as returned by
           <u>fetchrow</u><b>_</b><u>hashref()</u>.

           If there are no rows to return, "fetchall_hashref" returns a reference to an empty hash. If an
           error occurs, "fetchall_hashref" returns the data fetched thus far, which may be none.  You
           should check "$sth-&gt;err" afterwards (or use the "RaiseError" attribute) to discover if the data
           is complete or was truncated due to an error.

           The $key_field parameter provides the name of the field that holds the value to be used for the
           key for the returned hash.  For example:

             $dbh-&gt;{FetchHashKeyName} = 'NAME_lc';
             $sth = $dbh-&gt;prepare("SELECT FOO, BAR, ID, NAME, BAZ FROM TABLE");
             $sth-&gt;execute;
             $hash_ref = $sth-&gt;fetchall_hashref('id');
             print "Name for id 42 is $hash_ref-&gt;{42}-&gt;{name}\n";

           The $key_field parameter can also be specified as an integer column number (counting from 1).  If
           $key_field doesn't match any column in the statement, as a name first then as a number, then an
           error is returned.

           For queries returing more than one 'key' column, you can specify multiple column names by passing
           $key_field as a reference to an array containing one or more key column names (or index numbers).
           For example:

             $sth = $dbh-&gt;prepare("SELECT foo, bar, baz FROM table");
             $sth-&gt;execute;
             $hash_ref = $sth-&gt;fetchall_hashref( [ qw(foo bar) ] );
             print "For foo 42 and bar 38, baz is $hash_ref-&gt;{42}-&gt;{38}-&gt;{baz}\n";

           The <u>fetchall</u><b>_</b><u>hashref()</u> method is normally used only where the key fields values for each row are
           unique.  If multiple rows are returned with the same values for the key fields then later rows
           overwrite earlier ones.

       "finish"
             $rc  = $sth-&gt;finish;

           Indicate that no more data will be fetched from this statement handle before it is either
           executed again or destroyed.  The "finish" method is rarely needed, and frequently overused, but
           can sometimes be helpful in a few very specific situations to allow the server to free up
           resources (such as sort buffers).

           When all the data has been fetched from a "SELECT" statement, the driver should automatically
           call "finish" for you. So you should <u>not</u> normally need to call it explicitly <u>except</u> when you know
           that you've not fetched all the data from a statement handle.  The most common example is when
           you only want to fetch one row, but in that case the "selectrow_*" methods are usually better
           anyway.  Adding calls to "finish" after each fetch loop is a common mistake, don't do it, it can
           mask genuine problems like uncaught fetch errors.

           Consider a query like:

             SELECT foo FROM table WHERE bar=? ORDER BY foo

           where you want to select just the first (smallest) "foo" value from a very large table. When
           executed, the database server will have to use temporary buffer space to store the sorted rows.
           If, after executing the handle and selecting one row, the handle won't be re-executed for some
           time and won't be destroyed, the "finish" method can be used to tell the server that the buffer
           space can be freed.

           Calling "finish" resets the "Active" attribute for the statement.  It may also make some
           statement handle attributes (such as "NAME" and "TYPE") unavailable if they have not already been
           accessed (and thus cached).

           The "finish" method does not affect the transaction status of the database connection.  It has
           nothing to do with transactions. It's mostly an internal "housekeeping" method that is rarely
           needed.  See also "disconnect" and the "Active" attribute.

           The "finish" method should have been called "discard_pending_rows".

       "rows"
             $rv = $sth-&gt;rows;

           Returns the number of rows affected by the last row affecting command, or -1 if the number of
           rows is not known or not available.

           Generally, you can only rely on a row count after a <u>non</u>-"SELECT" "execute" (for some specific
           operations like "UPDATE" and "DELETE"), or after fetching all the rows of a "SELECT" statement.

           For "SELECT" statements, it is generally not possible to know how many rows will be returned
           except by fetching them all.  Some drivers will return the number of rows the application has
           fetched so far, but others may return -1 until all rows have been fetched.  So use of the "rows"
           method or $DBI::rows with "SELECT" statements is not recommended.

           One alternative method to get a row count for a "SELECT" is to execute a "SELECT COUNT(*) FROM
           ..." SQL statement with the same "..." as your query and then fetch the row count from that.

       "bind_col"
             $rc = $sth-&gt;bind_col($column_number, \$var_to_bind);
             $rc = $sth-&gt;bind_col($column_number, \$var_to_bind, \%attr );
             $rc = $sth-&gt;bind_col($column_number, \$var_to_bind, $bind_type );

           Binds a Perl variable and/or some attributes to an output column (field) of a "SELECT" statement.
           Column numbers count up from 1.  You do not need to bind output columns in order to fetch data.
           For maximum portability between drivers, <u>bind</u><b>_</b><u>col()</u> should be called after <u>execute()</u> and not
           before.  See also "bind_columns" for an example.

           The binding is performed at a low level using Perl aliasing.  Whenever a row is fetched from the
           database $var_to_bind appears to be automatically updated simply because it now refers to the
           same memory location as the corresponding column value.  This makes using bound variables very
           efficient.  Binding a tied variable doesn't work, currently.

           The "bind_param" method performs a similar, but opposite, function for input variables.

           <b>Data</b> <b>Types</b> <b>for</b> <b>Column</b> <b>Binding</b>

           The "\%attr" parameter can be used to hint at the data type formatting the column should have.
           For example, you can use:

             $sth-&gt;bind_col(1, undef, { TYPE =&gt; SQL_DATETIME });

           to specify that you'd like the column (which presumably is some kind of datetime type) to be
           returned in the standard format for SQL_DATETIME, which is 'YYYY-MM-DD HH:MM:SS', rather than the
           native formatting the database would normally use.

           There's no $var_to_bind in that example to emphasize the point that <u>bind</u><b>_</b><u>col()</u> works on the
           underlying column value and not just a particular bound variable.

           As a short-cut for the common case, the data type can be passed directly, in place of the
           "\%attr" hash reference. This example is equivalent to the one above:

             $sth-&gt;bind_col(1, undef, SQL_DATETIME);

           The "TYPE" value indicates the standard (non-driver-specific) type for this parameter. To specify
           the driver-specific type, the driver may support a driver-specific attribute, such as "{ ora_type
           =&gt; 97 }".

           The SQL_DATETIME and other related constants can be imported using

             use DBI qw(:sql_types);

           See "DBI Constants" for more information.

           The data type for a bind variable cannot be changed after the first "bind_col" call. In fact the
           whole \%attr parameter is 'sticky' in the sense that a driver only needs to consider the \%attr
           parameter for the first call for a given $sth and column.

           The TYPE attribute for <u>bind</u><b>_</b><u>col()</u> was first specified in DBI 1.41.

       "bind_columns"
             $rc = $sth-&gt;bind_columns(@list_of_refs_to_vars_to_bind);

           Calls "bind_col" for each column of the "SELECT" statement.

           The list of references should have the same number of elements as the number of columns in the
           "SELECT" statement. If it doesn't then "bind_columns" will bind the elements given, upto the
           number of columns, and then return an error.

           For maximum portability between drivers, <u>bind</u><b>_</b><u>columns()</u> should be called after <u>execute()</u> and not
           before.

           For example:

             $dbh-&gt;{RaiseError} = 1; # do this, or check every call for errors
             $sth = $dbh-&gt;prepare(q{ SELECT region, sales FROM sales_by_region });
             $sth-&gt;execute;
             my ($region, $sales);

             # Bind Perl variables to columns:
             $rv = $sth-&gt;bind_columns(\$region, \$sales);

             # you can also use Perl's \(...) syntax (see perlref docs):
             #     $sth-&gt;bind_columns(\($region, $sales));

             # Column binding is the most efficient way to fetch data
             while ($sth-&gt;fetch) {
                 print "$region: $sales\n";
             }

           For compatibility with old scripts, the first parameter will be ignored if it is "undef" or a
           hash reference.

           Here's a more fancy example that binds columns to the values <u>inside</u> a hash (thanks to H.Merijn
           Brand):

             $sth-&gt;execute;
             my %row;
             $sth-&gt;bind_columns( \( @row{ @{$sth-&gt;{NAME_lc} } } ));
             while ($sth-&gt;fetch) {
                 print "$row{region}: $row{sales}\n";
             }

       "dump_results"
             $rows = $sth-&gt;dump_results($maxlen, $lsep, $fsep, $fh);

           Fetches all the rows from $sth, calls "DBI::neat_list" for each row, and prints the results to
           $fh (defaults to "STDOUT") separated by $lsep (default "\n"). $fsep defaults to ", " and $maxlen
           defaults to 35.

           This method is designed as a handy utility for prototyping and testing queries. Since it uses
           "neat_list" to format and edit the string for reading by humans, it is not recomended for data
           transfer applications.

       <b>Statement</b> <b>Handle</b> <b>Attributes</b>

       This section describes attributes specific to statement handles. Most of these attributes are read-<font color="#ffffff" class="whiteout">only.&nbsp;readonly.</font>
       only.

       Changes to these statement handle attributes do not affect any other existing or future statement
       handles.

       Attempting to set or get the value of an unknown attribute generates a warning, except for private
       driver specific attributes (which all have names starting with a lowercase letter).

       Example:

         ... = $h-&gt;{NUM_OF_FIELDS};    # get/read

       Some drivers cannot provide valid values for some or all of these attributes until after
       "$sth-&gt;execute" has been successfully called. Typically the attribute will be "undef" in these
       situations.

       Some attributes, like NAME, are not appropriate to some types of statement, like SELECT. Typically
       the attribute will be "undef" in these situations.

       See also "finish" to learn more about the effect it may have on some attributes.

       "NUM_OF_FIELDS"  (integer, read-only)
           Number of fields (columns) in the data the prepared statement may return.  Statements that don't
           return rows of data, like "DELETE" and "CREATE" set "NUM_OF_FIELDS" to 0 (though it may be undef
           in some drivers).

       "NUM_OF_PARAMS"  (integer, read-only)
           The number of parameters (placeholders) in the prepared statement.  See SUBSTITUTION VARIABLES
           below for more details.

       "NAME"  (array-ref, read-only)
           Returns a reference to an array of field names for each column. The names may contain spaces but
           should not be truncated or have any trailing space. Note that the names have the letter case
           (upper, lower or mixed) as returned by the driver being used. Portable applications should use
           "NAME_lc" or "NAME_uc".

             print "First column name: $sth-&gt;{NAME}-&gt;[0]\n";

       "NAME_lc"  (array-ref, read-only)
           Like "NAME" but always returns lowercase names.

       "NAME_uc"  (array-ref, read-only)
           Like "NAME" but always returns uppercase names.

       "NAME_hash"  (hash-ref, read-only)
       "NAME_lc_hash"  (hash-ref, read-only)
       "NAME_uc_hash"  (hash-ref, read-only)
           The "NAME_hash", "NAME_lc_hash", and "NAME_uc_hash" attributes return column name information as
           a reference to a hash.

           The keys of the hash are the names of the columns.  The letter case of the keys corresponds to
           the letter case returned by the "NAME", "NAME_lc", and "NAME_uc" attributes respectively (as
           described above).

           The value of each hash entry is the perl index number of the corresponding column (counting from
           0). For example:

             $sth = $dbh-&gt;prepare("select Id, Name from table");
             $sth-&gt;execute;
             @row = $sth-&gt;fetchrow_array;
             print "Name $row[ $sth-&gt;{NAME_lc_hash}{name} ]\n";

       "TYPE"  (array-ref, read-only)
           Returns a reference to an array of integer values for each column. The value indicates the data
           type of the corresponding column.

           The values correspond to the international standards (ANSI X3.135 and ISO/IEC 9075) which, in
           general terms, means ODBC. Driver-specific types that don't exactly match standard types should
           generally return the same values as an ODBC driver supplied by the makers of the database. That
           might include private type numbers in ranges the vendor has officially registered with the ISO
           working group:

             <a href="ftp://sqlstandards.org/SC32/SQL_Registry/">ftp://sqlstandards.org/SC32/SQL_Registry/</a>

           Where there's no vendor-supplied ODBC driver to be compatible with, the DBI driver can use type
           numbers in the range that is now officially reserved for use by the DBI: -9999 to -9000.

           All possible values for "TYPE" should have at least one entry in the output of the
           "type_info_all" method (see "type_info_all").

       "PRECISION"  (array-ref, read-only)
           Returns a reference to an array of integer values for each column.

           For numeric columns, the value is the maximum number of digits (without considering a sign
           character or decimal point). Note that the "display size" for floating point types (REAL, FLOAT,
           DOUBLE) can be up to 7 characters greater than the precision (for the sign + decimal point + the
           letter E + a sign + 2 or 3 digits).

           For any character type column the value is the OCTET_LENGTH, in other words the number of bytes,
           not characters.

           (More recent standards refer to this as COLUMN_SIZE but we stick with PRECISION for backwards
           compatibility.)

       "SCALE"  (array-ref, read-only)
           Returns a reference to an array of integer values for each column.  NULL ("undef") values
           indicate columns where scale is not applicable.

       "NULLABLE"  (array-ref, read-only)
           Returns a reference to an array indicating the possibility of each column returning a null.
           Possible values are 0 (or an empty string) = no, 1 = yes, 2 = unknown.

             print "First column may return NULL\n" if $sth-&gt;{NULLABLE}-&gt;[0];

       "CursorName"  (string, read-only)
           Returns the name of the cursor associated with the statement handle, if available. If not
           available or if the database driver does not support the "where current of ..." SQL syntax, then
           it returns "undef".

       "Database"  (dbh, read-only)
           Returns the parent $dbh of the statement handle.

       "ParamValues"  (hash ref, read-only)
           Returns a reference to a hash containing the values currently bound to placeholders.  The keys of
           the hash are the 'names' of the placeholders, typically integers starting at 1.  Returns undef if
           not supported by the driver.

           See "ShowErrorStatement" for an example of how this is used.

           If the driver supports "ParamValues" but no values have been bound yet then the driver should
           return a hash with placeholders names in the keys but all the values undef, but some drivers may
           return a ref to an empty hash.

           It is possible that the values in the hash returned by "ParamValues" are not <u>exactly</u> the same as
           those passed to <u>bind</u><b>_</b><u>param()</u> or <u>execute()</u>.  The driver may have slightly modified values in some
           way based on the TYPE the value was bound with. For example a floating point value bound as an
           SQL_INTEGER type may be returned as an integer.  The values returned by "ParamValues" can be
           passed to another <u>bind</u><b>_</b><u>param()</u> method with the same TYPE and will be seen by the database as the
           same value.

           It is also possible that the keys in the hash returned by "ParamValues" are not exactly the same
           as those implied by the prepared statement.  For example, DBD::Oracle translates '"?"'
           placeholders into '":pN"' where N is a sequence number starting at 1.

           The "ParamValues" attribute was added in DBI 1.28.

       "ParamArrays"  (hash ref, read-only)
           Returns a reference to a hash containing the values currently bound to placeholders with
           "execute_array" or "bind_param_array".  The keys of the hash are the 'names' of the placeholders,
           typically integers starting at 1.  Returns undef if not supported by the driver or no arrays of
           parameters are bound.

           Each key value is an array reference containing a list of the bound parameters for that column.

           For example:

             $sth = $dbh-&gt;prepare("INSERT INTO staff (id, name) values (?,?)");
             $sth-&gt;execute_array({},[1,2], ['fred','dave']);
             if ($sth-&gt;{ParamArrays}) {
                 foreach $param (keys %{$sth-&gt;{ParamArrays}}) {
                     printf "Parameters for %s : %s\n", $param,
                     join(",", @{$sth-&gt;{ParamArrays}-&gt;{$param}});
                 }
             }

           It is possible that the values in the hash returned by "ParamArrays" are not <u>exactly</u> the same as
           those passed to "bind_param_array" or "execute_array".  The driver may have slightly modified
           values in some way based on the TYPE the value was bound with. For example a floating point value
           bound as an SQL_INTEGER type may be returned as an integer.

           It is also possible that the keys in the hash returned by "ParamArrays" are not exactly the same
           as those implied by the prepared statement.  For example, DBD::Oracle translates '"?"'
           placeholders into '":pN"' where N is a sequence number starting at 1.

       "ParamTypes"  (hash ref, read-only)
           Returns a reference to a hash containing the type information currently bound to placeholders.
           The keys of the hash are the 'names' of the placeholders: either integers starting at 1, or, for
           drivers that support named placeholders, the actual parameter name string. The hash values are
           hashrefs of type information in the same form as that provided to the various <u>bind</u><b>_</b><u>param()</u>
           methods (See "Data Types for Placeholders" for the format and values), plus anything else that
           was passed as the third argument to <u>bind</u><b>_</b><u>param()</u>.  Returns undef if not supported by the driver.

           If the driver supports "ParamTypes", but no values have been bound yet, then the driver should
           return a hash with the placeholder name keys, but all the values undef; however, some drivers may
           return a ref to an empty hash, or, alternately, may provide type information supplied by the
           database (only a few databases can do that).

           It is possible that the values in the hash returned by "ParamTypes" are not <u>exactly</u> the same as
           those passed to <u>bind</u><b>_</b><u>param()</u> or <u>execute()</u>.  The driver may have modified the type information in
           some way based on the bound values, other hints provided by the <u>prepare()</u>'d SQL statement, or
           alternate type mappings required by the driver or target database system.

           It is also possible that the keys in the hash returned by "ParamTypes" are not exactly the same
           as those implied by the prepared statement.  For example, DBD::Oracle translates '"?"'
           placeholders into '":pN"' where N is a sequence number starting at 1.

           The "ParamTypes" attribute was added in DBI 1.49. Implementation is the responsibility of
           individual drivers; the DBI layer default implementation simply returns undef.

       "Statement"  (string, read-only)
           Returns the statement string passed to the "prepare" method.

       "RowsInCache"  (integer, read-only)
           If the driver supports a local row cache for "SELECT" statements, then this attribute holds the
           number of un-fetched rows in the cache. If the driver doesn't, then it returns "undef". Note that
           some drivers pre-fetch rows on execute, whereas others wait till the first fetch.

           See also the "RowCacheSize" database handle attribute.

<b>OTHER</b> <b>METHODS</b>
       "install_method"
               DBD::Foo::db-&gt;install_method($method_name, \%attr);

           Installs the driver-private method named by $method_name into the DBI method dispatcher so it can
           be called directly, avoiding the need to use the <u>func()</u> method.

           It is called as a static method on the driver class to which the method belongs. The method name
           must begin with the corresponding registered driver-private prefix. For example, for DBD::Oracle
           $method_name must being with '"ora_"', and for DBD::AnyData it must begin with '"ad_"'.

           The attributes can be used to provide fine control over how the DBI dispatcher handles the
           dispatching of the method. However, at this point, it's undocumented and very liable to change.
           (Volunteers to polish up and document the interface are very welcome to get in touch via
           dbi-dev@perl.org)

           Methods installed using install_method default to the standard error handling behaviour for DBI
           methods: clearing err and errstr before calling the method, and checking for errors to trigger
           RaiseError etc. on return. This differs from the default behaviour of <u>func()</u>.

           Note for driver authors: The DBD::Foo::xx-&gt;install_method call won't work until the class-
           hierarchy has been setup. Normally the DBI looks after that just after the driver is loaded. This
           means <u>install</u><b>_</b><u>method()</u> can't be called at the time the driver is loaded unless the class-
           hierarchy is set up first. The way to do that is to call the <u>setup</u><b>_</b><u>driver()</u> method:

               DBI-&gt;setup_driver('DBD::Foo');

           before using <u>install</u><b>_</b><u>method()</u>.

<b>FURTHER</b> <b>INFORMATION</b>
       <b>Catalog</b> <b>Methods</b>

       An application can retrieve metadata information from the DBMS by issuing appropriate queries on the
       views of the Information Schema. Unfortunately, "INFORMATION_SCHEMA" views are seldom supported by
       the DBMS.  Special methods (catalog methods) are available to return result sets for a small but
       important portion of that metadata:

         column_info
         foreign_key_info
         primary_key_info
         table_info
         statistics_info

       All catalog methods accept arguments in order to restrict the result sets.  Passing "undef" to an
       optional argument does not constrain the search for that argument.  However, an empty string ('') is
       treated as a regular search criteria and will only match an empty value.

       <b>Note</b>: SQL/CLI and ODBC differ in the handling of empty strings. An empty string will not restrict the
       result set in SQL/CLI.

       Most arguments in the catalog methods accept only <u>ordinary</u> <u>values</u>, e.g.  the arguments of
       "primary_key_info()".  Such arguments are treated as a literal string, i.e. the case is significant
       and quote characters are taken literally.

       Some arguments in the catalog methods accept <u>search</u> <u>patterns</u> (strings containing '_' and/or '%'),
       e.g. the $table argument of "column_info()".  Passing '%' is equivalent to leaving the argument
       "undef".

       <b>Caveat</b>: The underscore ('_') is valid and often used in SQL identifiers.  Passing such a value to a
       search pattern argument may return more rows than expected!  To include pattern characters as
       literals, they must be preceded by an escape character which can be achieved with

         $esc = $dbh-&gt;get_info( 14 );  # SQL_SEARCH_PATTERN_ESCAPE
         $search_pattern =~ s/([_%])/$esc$1/g;

       The ODBC and SQL/CLI specifications define a way to change the default behaviour described above: All
       arguments (except <u>list</u> <u>value</u> <u>arguments</u>) are treated as <u>identifier</u> if the "SQL_ATTR_METADATA_ID"
       attribute is set to "SQL_TRUE".  <u>Quoted</u> <u>identifiers</u> are very similar to <u>ordinary</u> <u>values</u>, i.e. their
       body (the string within the quotes) is interpreted literally.  <u>Unquoted</u> <u>identifiers</u> are compared in
       UPPERCASE.

       The DBI (currently) does not support the "SQL_ATTR_METADATA_ID" attribute, i.e. it behaves like an
       ODBC driver where "SQL_ATTR_METADATA_ID" is set to "SQL_FALSE".

       <b>Transactions</b>

       Transactions are a fundamental part of any robust database system. They protect against errors and
       database corruption by ensuring that sets of related changes to the database take place in atomic
       (indivisible, all-or-nothing) units.

       This section applies to databases that support transactions and where "AutoCommit" is off.  See
       "AutoCommit" for details of using "AutoCommit" with various types of databases.

       The recommended way to implement robust transactions in Perl applications is to use "RaiseError" and
       "eval { ... }" (which is very fast, unlike "eval "...""). For example:

         $dbh-&gt;{AutoCommit} = 0;  # enable transactions, if possible
         $dbh-&gt;{RaiseError} = 1;
         eval {
             foo(...)        # do lots of work here
             bar(...)        # including inserts
             baz(...)        # and updates
             $dbh-&gt;commit;   # commit the changes if we get this far
         };
         if ($@) {
             warn "Transaction aborted because $@";
             # now rollback to undo the incomplete changes
             # but do it in an eval{} as it may also fail
             eval { $dbh-&gt;rollback };
             # add other application on-error-clean-up code here
         }

       If the "RaiseError" attribute is not set, then DBI calls would need to be manually checked for
       errors, typically like this:

         $h-&gt;method(@args) or die $h-&gt;errstr;

       With "RaiseError" set, the DBI will automatically "die" if any DBI method call on that handle (or a
       child handle) fails, so you don't have to test the return value of each method call. See "RaiseError"
       for more details.

       A major advantage of the "eval" approach is that the transaction will be properly rolled back if <u>any</u>
       code (not just DBI calls) in the inner application dies for any reason. The major advantage of using
       the "$h-&gt;{RaiseError}" attribute is that all DBI calls will be checked automatically. Both techniques
       are strongly recommended.

       After calling "commit" or "rollback" many drivers will not let you fetch from a previously active
       "SELECT" statement handle that's a child of the same database handle. A typical way round this is to
       connect the the database twice and use one connection for "SELECT" statements.

       See "AutoCommit" and "disconnect" for other important information about transactions.

       <b>Handling</b> <b>BLOB</b> <b>/</b> <b>LONG</b> <b>/</b> <b>Memo</b> <b>Fields</b>

       Many databases support "blob" (binary large objects), "long", or similar datatypes for holding very
       long strings or large amounts of binary data in a single field. Some databases support variable
       length long values over 2,000,000,000 bytes in length.

       Since values of that size can't usually be held in memory, and because databases can't usually know
       in advance the length of the longest long that will be returned from a "SELECT" statement (unlike
       other data types), some special handling is required.

       In this situation, the value of the "$h-&gt;{LongReadLen}" attribute is used to determine how much
       buffer space to allocate when fetching such fields.  The "$h-&gt;{LongTruncOk}" attribute is used to
       determine how to behave if a fetched value can't fit into the buffer.

       See the description of "LongReadLen" for more information.

       When trying to insert long or binary values, placeholders should be used since there are often limits
       on the maximum size of an "INSERT" statement and the "quote" method generally can't cope with binary
       data.  See "Placeholders and Bind Values".

       <b>Simple</b> <b>Examples</b>

       Here's a complete example program to select and fetch some data:

         my $data_source = "dbi::DriverName:db_name";
         my $dbh = DBI-&gt;connect($data_source, $user, $password)
             or die "Can't connect to $data_source: $DBI::errstr";

         my $sth = $dbh-&gt;prepare( q{
                 SELECT name, phone
                 FROM mytelbook
         }) or die "Can't prepare statement: $DBI::errstr";

         my $rc = $sth-&gt;execute
             or die "Can't execute statement: $DBI::errstr";

         print "Query will return $sth-&gt;{NUM_OF_FIELDS} fields.\n\n";
         print "Field names: @{ $sth-&gt;{NAME} }\n";

         while (($name, $phone) = $sth-&gt;fetchrow_array) {
             print "$name: $phone\n";
         }
         # check for problems which may have terminated the fetch early
         die $sth-&gt;errstr if $sth-&gt;err;

         $dbh-&gt;disconnect;

       Here's a complete example program to insert some data from a file.  (This example uses "RaiseError"
       to avoid needing to check each call).

         my $dbh = DBI-&gt;connect("dbi:DriverName:db_name", $user, $password, {
             RaiseError =&gt; 1, AutoCommit =&gt; 0
         });

         my $sth = $dbh-&gt;prepare( q{
             INSERT INTO table (name, phone) VALUES (?, ?)
         });

         open FH, "&lt;phone.csv" or die "Unable to open phone.csv: $!";
         while (&lt;FH&gt;) {
             chomp;
             my ($name, $phone) = split /,/;
             $sth-&gt;execute($name, $phone);
         }
         close FH;

         $dbh-&gt;commit;
         $dbh-&gt;disconnect;

       Here's how to convert fetched NULLs (undefined values) into empty strings:

         while($row = $sth-&gt;fetchrow_arrayref) {
           # this is a fast and simple way to deal with nulls:
           foreach (@$row) { $_ = '' unless defined }
           print "@$row\n";
         }

       The "q{...}" style quoting used in these examples avoids clashing with quotes that may be used in the
       SQL statement. Use the double-quote like "qq{...}" operator if you want to interpolate variables into
       the string.  See "Quote and Quote-like Operators" in perlop for more details.

       <b>Threads</b> <b>and</b> <b>Thread</b> <b>Safety</b>

       Perl 5.7 and later support a new threading model called iThreads.  (The old "5.005 style" threads are
       not supported by the DBI.)

       In the iThreads model each thread has it's own copy of the perl interpreter.  When a new thread is
       created the original perl interpreter is 'cloned' to create a new copy for the new thread.

       If the DBI and drivers are loaded and handles created before the thread is created then it will get a
       cloned copy of the DBI, the drivers and the handles.

       However, the internal pointer data within the handles will refer to the DBI and drivers in the
       original interpreter. Using those handles in the new interpreter thread is not safe, so the DBI
       detects this and croaks on any method call using handles that don't belong to the current thread
       (except for DESTROY).

       Because of this (possibly temporary) restriction, newly created threads must make their own
       connctions to the database. Handles can't be shared across threads.

       But BEWARE, some underlying database APIs (the code the DBD driver uses to talk to the database,
       often supplied by the database vendor) are not thread safe. If it's not thread safe, then allowing
       more than one thread to enter the code at the same time may cause subtle/serious problems. In some
       cases allowing more than one thread to enter the code, even if <u>not</u> at the same time, can cause
       problems. You have been warned.

       Using DBI with perl threads is not yet recommended for production environments. For more information
       see &lt;<a href="http://www.perlmonks.org/index.pl?node_id=288022">http://www.perlmonks.org/index.pl?node_id=288022</a>

       Note: There is a bug in perl 5.8.2 when configured with threads and debugging enabled (bug #24463)
       which causes a DBI test to fail.

       <b>Signal</b> <b>Handling</b> <b>and</b> <b>Canceling</b> <b>Operations</b>

       [The following only applies to systems with unix-like signal handling.  I'd welcome additions for
       other systems, especially Windows.]

       The first thing to say is that signal handling in Perl versions less than 5.8 is <u>not</u> safe. There is
       always a small risk of Perl crashing and/or core dumping when, or after, handling a signal because
       the signal could arrive and be handled while internal data structures are being changed. If the
       signal handling code used those same internal data structures it could cause all manner of subtle and
       not-so-subtle problems.  The risk was reduced with 5.4.4 but was still present in all perls up
       through 5.8.0.

       Beginning in perl 5.8.0 perl implements 'safe' signal handling if your system has the POSIX
       <u>sigaction()</u> routine. Now when a signal is delivered perl just makes a note of it but does <u>not</u> run the
       %SIG handler. The handling is 'defered' until a 'safe' moment.

       Although this change made signal handling safe, it also lead to a problem with signals being defered
       for longer than you'd like.  If a signal arrived while executing a system call, such as waiting for
       data on a network connection, the signal is noted and then the system call that was executing returns
       with an EINTR error code to indicate that it was interrupted. All fine so far.

       The problem comes when the code that made the system call sees the EINTR code and decides it's going
       to call it again. Perl doesn't do that, but database code sometimes does. If that happens then the
       signal handler doesn't get called untill later. Maybe much later.

       Fortunately there are ways around this which we'll discuss below.  Unfortunately they make signals
       unsafe again.

       The two most common uses of signals in relation to the DBI are for canceling operations when the user
       types Ctrl-C (interrupt), and for implementing a timeout using "alarm()" and $SIG{ALRM}.

       Cancel
           The DBI provides a "cancel" method for statement handles. The "cancel" method should abort the
           current operation and is designed to be called from a signal handler.  For example:

             $SIG{INT} = sub { $sth-&gt;cancel };

           However, few drivers implement this (the DBI provides a default method that just returns "undef")
           and, even if implemented, there is still a possibility that the statement handle, and even the
           parent database handle, will not be usable afterwards.

           If "cancel" returns true, then it has successfully invoked the database engine's own cancel
           function.  If it returns false, then "cancel" failed. If it returns "undef", then the database
           driver does not have cancel implemented.

       Timeout
           The traditional way to implement a timeout is to set $SIG{ALRM} to refer to some code that will
           be executed when an ALRM signal arrives and then to call alarm($seconds) to schedule an ALRM
           signal to be delivered $seconds in the future. For example:

             eval {
               local $SIG{ALRM} = sub { die "TIMEOUT\n" };
               alarm($seconds);
               ... code to execute with timeout here ...
               alarm(0);  # cancel alarm (if code ran fast)
             };
             alarm(0);    # cancel alarm (if eval failed)
             if ( $@ eq "TIMEOUT" ) { ... }

           Unfortunately, as described above, this won't always work as expected, depending on your perl
           version and the underlying database code.

           With Oracle for instance (DBD::Oracle), if the system which hosts the database is down the
           DBI-&gt;<u>connect()</u> call will hang for several minutes before returning an error.

       The solution on these systems is to use the "POSIX::sigaction()" routine to gain low level access to
       how the signal handler is installed.

       The code would look something like this (for the DBD-Oracle <u>connect()</u>):

          use POSIX ':signal_h';

          my $mask = POSIX::SigSet-&gt;new( SIGALRM ); # signals to mask in the handler
          my $action = POSIX::SigAction-&gt;new(
              sub { die "connect timeout" },        # the handler code ref
              $mask,
              # not using (perl 5.8.2 and later) 'safe' switch or sa_flags
          );
          my $oldaction = POSIX::SigAction-&gt;new();
          sigaction( 'ALRM', $action, $oldaction );
          my $dbh;
          eval {
             <!-- a -->alarm(5)<!-- /a -->; # seconds before time out
             $dbh = DBI-&gt;connect("dbi:Oracle:$dsn" ... );
             alarm(0); # cancel alarm (if connect worked fast)
          };
          alarm(0);    # cancel alarm (if eval failed)
          sigaction( 'ALRM', $oldaction );  # restore original signal handler
          if ( $@ ) ....

       Similar techniques can be used for canceling statement execution.

       Unfortunately, this solution is somewhat messy, and it does <u>not</u> work with perl versions less than
       perl 5.8 where "POSIX::sigaction()" appears to be broken.

       For a cleaner implementation that works across perl versions, see Lincoln Baxter's Sys::SigAction
       module at &lt;<a href="http://search.cpan.org/~lbaxter/Sys-SigAction/">http://search.cpan.org/~lbaxter/Sys-SigAction/</a>.  The documentation for Sys::SigAction
       includes an longer discussion of this problem, and a DBD::Oracle test script.

       Be sure to read all the signal handling sections of the perlipc manual.

       And finally, two more points to keep firmly in mind. Firstly, remember that what we've done here is
       essentially revert to old style <u>unsafe</u> handling of these signals. So do as little as possible in the
       handler.  Ideally just <u>die()</u>. Secondly, the handles in use at the time the signal is handled may not
       be safe to use afterwards.

       <b>Subclassing</b> <b>the</b> <b>DBI</b>

       DBI can be subclassed and extended just like any other object oriented module.  Before we talk about
       how to do that, it's important to be clear about the various DBI classes and how they work together.

       By default "$dbh = DBI-&gt;connect(...)" returns a $dbh blessed into the "DBI::db" class.  And the
       "$dbh-&gt;prepare" method returns an $sth blessed into the "DBI::st" class (actually it simply changes
       the last four characters of the calling handle class to be "::st").

       The leading '"DBI"' is known as the 'root class' and the extra '"::db"' or '"::st"' are the 'handle
       type suffixes'. If you want to subclass the DBI you'll need to put your overriding methods into the
       appropriate classes.  For example, if you want to use a root class of "MySubDBI" and override the
       <u>do()</u>, <u>prepare()</u> and <u>execute()</u> methods, then your <u>do()</u> and <u>prepare()</u> methods should be in the
       "MySubDBI::db" class and the <u>execute()</u> method should be in the "MySubDBI::st" class.

       To setup the inheritance hierarchy the @ISA variable in "MySubDBI::db" should include "DBI::db" and
       the @ISA variable in "MySubDBI::st" should include "DBI::st".  The "MySubDBI" root class itself isn't
       currently used for anything visible and so, apart from setting @ISA to include "DBI", it can be left
       empty.

       So, having put your overriding methods into the right classes, and setup the inheritance hierarchy,
       how do you get the DBI to use them?  You have two choices, either a static method call using the name
       of your subclass:

         $dbh = MySubDBI-&gt;connect(...);

       or specifying a "RootClass" attribute:

         $dbh = DBI-&gt;connect(..., { RootClass =&gt; 'MySubDBI' });

       If both forms are used then the attribute takes precedence.

       The only differences between the two are that using an explicit RootClass attribute will a) make the
       DBI automatically attempt to load a module by that name if the class doesn't exist, and b) won't call
       your <u>MySubDBI::connect()</u> method, if you have one.

       When subclassing is being used then, after a successful new connect, the DBI-&gt;connect method
       automatically calls:

         $dbh-&gt;connected($dsn, $user, $pass, \%attr);

       The default method does nothing. The call is made just to simplify any post-connection setup that
       your subclass may want to perform.  The parameters are the same as passed to DBI-&gt;connect.  If your
       subclass supplies a connected method, it should be part of the MySubDBI::db package.

       One more thing to note: you must let the DBI do the handle creation.  If you want to override the
       <u>connect()</u> method in your *::dr class then it must still call SUPER::connect to get a $dbh to work
       with. Similarly, an overridden <u>prepare()</u> method in *::db must still call SUPER::prepare to get a
       $sth.  If you try to create your own handles using <u>bless()</u> then you'll find the DBI will reject them
       with an "is not a DBI handle (has no magic)" error.

       Here's a brief example of a DBI subclass.  A more thorough example can be found in <u>t/subclass.t</u> in
       the DBI distribution.

         package MySubDBI;

         use strict;

         use DBI;
         use vars qw(@ISA);
         @ISA = qw(DBI);

         package MySubDBI::db;
         use vars qw(@ISA);
         @ISA = qw(DBI::db);

         sub prepare {
           my ($dbh, @args) = @_;
           my $sth = $dbh-&gt;SUPER::prepare(@args)
               or return;
           $sth-&gt;{private_mysubdbi_info} = { foo =&gt; 'bar' };
           return $sth;
         }

         package MySubDBI::st;
         use vars qw(@ISA);
         @ISA = qw(DBI::st);

         sub fetch {
           my ($sth, @args) = @_;
           my $row = $sth-&gt;SUPER::fetch(@args)
               or return;
           do_something_magical_with_row_data($row)
               or return $sth-&gt;set_err(1234, "The magic failed", undef, "fetch");
           return $row;
         }

       When calling a SUPER::method that returns a handle, be careful to check the return value before
       trying to do other things with it in your overridden method. This is especially important if you want
       to set a hash attribute on the handle, as Perl's autovivification will bite you by (in)conveniently
       creating an unblessed hashref, which your method will then return with usually baffling results later
       on.  It's best to check right after the call and return undef immediately on error, just like DBI
       would and just like the example above.

       If your method needs to record an error it should call the <u>set</u><b>_</b><u>err()</u> method with the error code and
       error string, as shown in the example above. The error code and error string will be recorded in the
       handle and available via "$h-&gt;err" and $DBI::errstr etc.  The <u>set</u><b>_</b><u>err()</u> method always returns an
       undef or empty list as approriate. Since your method should nearly always return an undef or empty
       list as soon as an error is detected it's handy to simply return what <u>set</u><b>_</b><u>err()</u> returns, as shown in
       the example above.

       If the handle has "RaiseError", "PrintError", or "HandleError" etc. set then the <u>set</u><b>_</b><u>err()</u> method
       will honour them. This means that if "RaiseError" is set then <u>set</u><b>_</b><u>err()</u> won't return in the normal
       way but will 'throw an exception' that can be caught with an "eval" block.

       You can stash private data into DBI handles via "$h-&gt;{private_..._*}".  See the entry under
       "ATTRIBUTES COMMON TO ALL HANDLES" for info and important caveats.

<b>TRACING</b>
       The DBI has a powerful tracing mechanism built in. It enables you to see what's going on 'behind the
       scenes', both within the DBI and the drivers you're using.

       <b>Trace</b> <b>Settings</b>

       Which details are written to the trace output is controlled by a combination of a <u>trace</u> <u>level</u>, an
       integer from 0 to 15, and a set of <u>trace</u> <u>flags</u> that are either on or off. Together these are known as
       the <u>trace</u> <u>settings</u> and are stored together in a single integer.  For normal use you only need to set
       the trace level, and generally only to a value between 1 and 4.

       Each handle has it's own trace settings, and so does the DBI.  When you call a method the DBI merges
       the handles settings into its own for the duration of the call: the trace flags of the handle are
       OR'd into the trace flags of the DBI, and if the handle has a higher trace level then the DBI trace
       level is raised to match it.  The previous DBI trace setings are restored when the called method
       returns.

       <b>Trace</b> <b>Levels</b>

       Trace <u>levels</u> are as follows:

         0 - Trace disabled.
         1 - Trace DBI method calls returning with results or errors.
         2 - Trace method entry with parameters and returning with results.
         3 - As above, adding some high-level information from the driver
             and some internal information from the DBI.
         4 - As above, adding more detailed information from the driver.
         5 to 15 - As above but with more and more obscure information.

       Trace level 1 is best for a simple overview of what's happening.  Trace level 2 is a good choice for
       general purpose tracing.  Levels 3 and above are best reserved for investigating a specific problem,
       when you need to see "inside" the driver and DBI.

       The trace output is detailed and typically very useful. Much of the trace output is formatted using
       the "neat" function, so strings in the trace output may be edited and truncated by that function.

       <b>Trace</b> <b>Flags</b>

       Trace <u>flags</u> are used to enable tracing of specific activities within the DBI and drivers. The DBI
       defines some trace flags and drivers can define others. DBI trace flag names begin with a capital
       letter and driver specific names begin with a lowercase letter, as usual.

       Curently the DBI only defines two trace flags:

         ALL - turn on all DBI and driver flags (not recommended)
         SQL - trace SQL statements executed (not yet implemented)

       The "parse_trace_flags" and "parse_trace_flag" methods are used to convert trace flag names into the
       coresponding integer bit flags.

       <b>Enabling</b> <b>Trace</b>

       The "$h-&gt;trace" method sets the trace settings for a handle and "DBI-&gt;trace" does the same for the
       DBI.

       In addition to the "trace" method, you can enable the same trace information, and direct the output
       to a file, by setting the "DBI_TRACE" environment variable before starting Perl.  See "DBI_TRACE" for
       more information.

       Finally, you can set, or get, the trace settings for a handle using the "TraceLevel" attribute.

       All of those methods use <u>parse</u><b>_</b><u>trace</u><b>_</b><u>flags()</u> and so allow you set both the trace level and multiple
       trace flags by using a string containing the trace level and/or flag names separated by vertical bar
       (""|"") or comma ("","") characters. For example:

         local $h-&gt;{TraceLevel} = "3|SQL|foo";

       <b>Trace</b> <b>Output</b>

       Initially trace output is written to "STDERR".  Both the "$h-&gt;trace" and "DBI-&gt;trace" methods take an
       optional $trace_filename parameter. If specified, and can be opened in append mode, then <u>all</u> trace
       output (currently including that from other handles) is redirected to that file.  A warning is
       generated if the file can't be opened.

       Further calls to <u>trace()</u> without a $trace_filename do not alter where the trace output is sent. If
       $trace_filename is undefined, then trace output is sent to "STDERR" and the previous trace file is
       closed.

       Currently $trace_filename can't be a filehandle. But meanwhile you can use the special strings
       "STDERR" and "STDOUT" to select those filehandles.

       <b>Trace</b> <b>Content</b>

       Many of the values embeded in trace output are formatted using the <u>neat()</u> utility function. This
       means they may be quoted, sanitized, and possibly truncated if longer than $DBI::neat_maxlen. See
       "neat" for more details.

       <b>Tracing</b> <b>Tips</b>

       You can add tracing to your own application code using the "trace_msg" method.

       It can sometimes be handy to compare trace files from two different runs of the same script. However
       using a tool like "diff" doesn't work well because the trace file is full of object addresses that
       may differ each run. Here's a handy little command to strip those out:

         perl -pe 's/\b0x[\da-f]{6,}/0xNNNN/gi; s/\b[\da-f]{6,}/&lt;long number&gt;/gi'

<b>DBI</b> <b>ENVIRONMENT</b> <b>VARIABLES</b>
       The DBI module recognizes a number of environment variables, but most of them should not be used most
       of the time.  It is better to be explicit about what you are doing to avoid the need for environment
       variables, especially in a web serving system where web servers are stingy about which environment
       variables are available.

       <b>DBI_DSN</b>

       The DBI_DSN environment variable is used by DBI-&gt;connect if you do not specify a data source when you
       issue the connect.  It should have a format such as "dbi:Driver:databasename".

       <b>DBI_DRIVER</b>

       The DBI_DRIVER environment variable is used to fill in the database driver name in DBI-&gt;connect if
       the data source string starts "dbi::" (thereby omitting the driver).  If DBI_DSN omits the driver
       name, DBI_DRIVER can fill the gap.

       <b>DBI_AUTOPROXY</b>

       The DBI_AUTOPROXY environment variable takes a string value that starts "dbi:Proxy:" and is typically
       followed by "hostname=...;port=...".  It is used to alter the behaviour of DBI-&gt;connect.  For full
       details, see DBI::Proxy documentation.

       <b>DBI_USER</b>

       The DBI_USER environment variable takes a string value that is used as the user name if the
       DBI-&gt;connect call is given undef (as distinct from an empty string) as the username argument.  Be
       wary of the security implications of using this.

       <b>DBI_PASS</b>

       The DBI_PASS environment variable takes a string value that is used as the password if the
       DBI-&gt;connect call is given undef (as distinct from an empty string) as the password argument.  Be
       extra wary of the security implications of using this.

       <b>DBI_DBNAME</b> <b>(obsolete)</b>

       The DBI_DBNAME environment variable takes a string value that is used only when the obsolescent style
       of DBI-&gt;connect (with driver name as fourth parameter) is used, and when no value is provided for the
       first (database name) argument.

       <b>DBI_TRACE</b>

       The DBI_TRACE environment variable specifies the global default trace settings for the DBI at
       startup. Can also be used to direct trace output to a file. When the DBI is loaded it does:

         DBI-&gt;trace(split /=/, $ENV{DBI_TRACE}, 2) if $ENV{DBI_TRACE};

       So if "DBI_TRACE" contains an ""="" character then what follows it is used as the name of the file to
       append the trace to.

       output appended to that file. If the name begins with a number followed by an equal sign ("="), then
       the number and the equal sign are stripped off from the name, and the number is used to set the trace
       level. For example:

         DBI_TRACE=1=dbitrace.log perl your_test_script.pl

       On Unix-like systems using a Bourne-like shell, you can do this easily on the command line:

         DBI_TRACE=2 perl your_test_script.pl

       See "TRACING" for more information.

       <b>PERL_DBI_DEBUG</b> <b>(obsolete)</b>

       An old variable that should no longer be used; equivalent to DBI_TRACE.

       <b>DBI_PROFILE</b>

       The DBI_PROFILE environment variable can be used to enable profiling of DBI method calls. See
       DBI::Profile for more information.

       <b>DBI_PUREPERL</b>

       The DBI_PUREPERL environment variable can be used to enable the use of DBI::PurePerl.  See
       DBI::PurePerl for more information.

<b>WARNING</b> <b>AND</b> <b>ERROR</b> <b>MESSAGES</b>
       <b>Fatal</b> <b>Errors</b>


       Can't call method "prepare" without a package or object reference
           The $dbh handle you're using to call "prepare" is probably undefined because the preceding
           "connect" failed. You should always check the return status of DBI methods, or use the
           "RaiseError" attribute.

       Can't call method "execute" without a package or object reference
           The $sth handle you're using to call "execute" is probably undefined because the preceeding
           "prepare" failed. You should always check the return status of DBI methods, or use the
           "RaiseError" attribute.

       DBI/DBD internal version mismatch
           The DBD driver module was built with a different version of DBI than the one currently being
           used.  You should rebuild the DBD module under the current version of DBI.

           (Some rare platforms require "static linking". On those platforms, there may be an old DBI or DBD
           driver version actually embedded in the Perl executable being used.)

       DBD driver has not implemented the AutoCommit attribute
           The DBD driver implementation is incomplete. Consult the author.

       Can't [sg]et %s-&gt;{%s}: unrecognised attribute
           You attempted to set or get an unknown attribute of a handle.  Make sure you have spelled the
           attribute name correctly; case is significant (e.g., "Autocommit" is not the same as
           "AutoCommit").

<b>Pure-Perl</b> <b>DBI</b>
       A pure-perl emulation of the DBI is included in the distribution for people using pure-perl drivers
       who, for whatever reason, can't install the compiled DBI. See DBI::PurePerl.

<b>SEE</b> <b>ALSO</b>
       <b>Driver</b> <b>and</b> <b>Database</b> <b>Documentation</b>

       Refer to the documentation for the DBD driver that you are using.

       Refer to the SQL Language Reference Manual for the database engine that you are using.

       <b>ODBC</b> <b>and</b> <b>SQL/CLI</b> <b>Standards</b> <b>Reference</b> <b>Information</b>

       More detailed information about the semantics of certain DBI methods that are based on ODBC and
       SQL/CLI standards is available on-line via microsoft.com, for ODBC, and www.jtc1sc32.org for the
       SQL/CLI standard:

        DBI method        ODBC function     SQL/CLI Working Draft
        ----------        -------------     ---------------------<font color="#ffffff" class="whiteout">column_info&nbsp;--------------------column_info</font>
        column_info       SQLColumns        Page 124
        foreign_key_info  SQLForeignKeys    Page 163
        get_info          SQLGetInfo        Page 214
        primary_key_info  SQLPrimaryKeys    Page 254
        table_info        SQLTables         Page 294
        type_info         SQLGetTypeInfo    Page 239
        statistics_info   SQLStatistics

       For example, for ODBC information on SQLColumns you'd visit:

         <a href="http://msdn.microsoft.com/library/en-us/odbc/htm/odbcsqlcolumns.asp">http://msdn.microsoft.com/library/en-us/odbc/htm/odbcsqlcolumns.asp</a>

       If that URL ceases to work then use the MSDN search facility at:

         <a href="http://search.microsoft.com/us/dev/">http://search.microsoft.com/us/dev/</a>

       and search for "SQLColumns returns" using the exact phrase option.  The link you want will probably
       just be called "SQLColumns" and will be part of the Data Access SDK.

       And for SQL/CLI standard information on SQLColumns you'd read page 124 of the (very large) SQL/CLI
       Working Draft available from:

         <a href="http://jtc1sc32.org/doc/N0701-0750/32N0744T.pdf">http://jtc1sc32.org/doc/N0701-0750/32N0744T.pdf</a>

       <b>Standards</b> <b>Reference</b> <b>Information</b>

       A hyperlinked, browsable version of the BNF syntax for SQL92 (plus Oracle 7 SQL and PL/SQL) is
       available here:

         <a href="http://cui.unige.ch/db-research/Enseignement/analyseinfo/SQL92/BNFindex.html">http://cui.unige.ch/db-research/Enseignement/analyseinfo/SQL92/BNFindex.html</a>

       A BNF syntax for SQL3 is available here:

         <a href="http://www.sqlstandards.org/SC32/WG3/Progression_Documents/Informal_working_drafts/iso-9075-2-1999.bnf">http://www.sqlstandards.org/SC32/WG3/Progression_Documents/Informal_working_drafts/iso-9075-2-1999.bnf</a>

       The following links provide further useful information about SQL.  Some of these are rather dated now
       but may still be useful.

         <a href="http://www.jcc.com/SQLPages/jccs_sql.htm">http://www.jcc.com/SQLPages/jccs_sql.htm</a>
         <a href="http://www.contrib.andrew.cmu.edu/~shadow/sql.html">http://www.contrib.andrew.cmu.edu/~shadow/sql.html</a>
         <a href="http://www.altavista.com/query?q=sql+tutorial">http://www.altavista.com/query?q=sql+tutorial</a>

       <b>Books</b> <b>and</b> <b>Articles</b>

       Programming the Perl DBI, by Alligator Descartes and Tim Bunce.  &lt;<a href="http://books.perl.org/book/154">http://books.perl.org/book/154</a>

       Programming Perl 3rd Ed. by Larry Wall, Tom Christiansen &amp; Jon Orwant.
       &lt;<a href="http://books.perl.org/book/134">http://books.perl.org/book/134</a>

       Learning Perl by Randal Schwartz.  &lt;<a href="http://books.perl.org/book/101">http://books.perl.org/book/101</a>

       Details of many other books related to perl can be found at &lt;<a href="http://books.perl.org">http://books.perl.org</a>

       <b>Perl</b> <b>Modules</b>

       Index of DBI related modules available from CPAN:

        <a href="http://search.cpan.org/search?mode=module&amp;query=DBIx%3A%3A">http://search.cpan.org/search?mode=module&amp;query=DBIx%3A%3A</a>
        <a href="http://search.cpan.org/search?mode=doc&amp;query=DBI">http://search.cpan.org/search?mode=doc&amp;query=DBI</a>

       For a good comparison of RDBMS-OO mappers and some OO-RDBMS mappers (including Class::DBI, Alzabo,
       and DBIx::RecordSet in the former category and Tangram and SPOPS in the latter) see the Perl Object-
       Oriented Persistence project pages at:

        <a href="http://poop.sourceforge.net">http://poop.sourceforge.net</a>

       A similar page for Java toolkits can be found at:

        <a href="http://c2.com/cgi-bin/wiki?ObjectRelationalToolComparison">http://c2.com/cgi-bin/wiki?ObjectRelationalToolComparison</a>

       <b>Mailing</b> <b>List</b>

       The <u>dbi-users</u> mailing list is the primary means of communication among users of the DBI and its
       related modules. For details send email to:

        dbi-users-help@perl.org

       There are typically between 700 and 900 messages per month.  You have to subscribe in order to be
       able to post. However you can opt for a 'post-only' subscription.

       Mailing list archives (of variable quality) are held at:

        <a href="http://groups.google.com/groups?group=perl.dbi.users">http://groups.google.com/groups?group=perl.dbi.users</a>
        <a href="http://www.xray.mpe.mpg.de/mailing-lists/dbi/">http://www.xray.mpe.mpg.de/mailing-lists/dbi/</a>
        <a href="http://www.mail-archive.com/dbi-users%40perl.org/">http://www.mail-archive.com/dbi-users%40perl.org/</a>

       <b>Assorted</b> <b>Related</b> <b>WWW</b> <b>Links</b>

       The DBI "Home Page":

        <a href="http://dbi.perl.org/">http://dbi.perl.org/</a>

       Other DBI related links:

        <a href="http://tegan.deltanet.com/~phlip/DBUIdoc.html">http://tegan.deltanet.com/~phlip/DBUIdoc.html</a>
        <a href="http://dc.pm.org/perl_db.html">http://dc.pm.org/perl_db.html</a>
        <a href="http://wdvl.com/Authoring/DB/Intro/toc.html">http://wdvl.com/Authoring/DB/Intro/toc.html</a>
        <a href="http://www.hotwired.com/webmonkey/backend/tutorials/tutorial1.html">http://www.hotwired.com/webmonkey/backend/tutorials/tutorial1.html</a>
        <a href="http://bumppo.net/lists/macperl/1999/06/msg00197.html">http://bumppo.net/lists/macperl/1999/06/msg00197.html</a>
        <a href="http://gmax.oltrelinux.com/dbirecipes.html">http://gmax.oltrelinux.com/dbirecipes.html</a>

       Other database related links:

        <a href="http://www.jcc.com/sql_stnd.html">http://www.jcc.com/sql_stnd.html</a>
        <a href="http://cuiwww.unige.ch/OSG/info/FreeDB/FreeDB.home.html">http://cuiwww.unige.ch/OSG/info/FreeDB/FreeDB.home.html</a>

       Security, especially the "SQL Injection" attack:

        <a href="http://www.ngssoftware.com/research/papers.html">http://www.ngssoftware.com/research/papers.html</a>
        <a href="http://www.ngssoftware.com/papers/advanced_sql_injection.pdf">http://www.ngssoftware.com/papers/advanced_sql_injection.pdf</a>
        <a href="http://www.ngssoftware.com/papers/more_advanced_sql_injection.pdf">http://www.ngssoftware.com/papers/more_advanced_sql_injection.pdf</a>
        <a href="http://www.esecurityplanet.com/trends/article.php/2243461">http://www.esecurityplanet.com/trends/article.php/2243461</a>
        <a href="http://www.spidynamics.com/papers/SQLInjectionWhitePaper.pdf">http://www.spidynamics.com/papers/SQLInjectionWhitePaper.pdf</a>
        <a href="http://www.imperva.com/application_defense_center/white_papers/blind_sql_server_injection.html">http://www.imperva.com/application_defense_center/white_papers/blind_sql_server_injection.html</a>
        <a href="http://online.securityfocus.com/infocus/1644">http://online.securityfocus.com/infocus/1644</a>

       Commercial and Data Warehouse Links

        <a href="http://www.dwinfocenter.org">http://www.dwinfocenter.org</a>
        <a href="http://www.datawarehouse.com">http://www.datawarehouse.com</a>
        <a href="http://www.datamining.org">http://www.datamining.org</a>
        <a href="http://www.olapcouncil.org">http://www.olapcouncil.org</a>
        <a href="http://www.idwa.org">http://www.idwa.org</a>
        <a href="http://www.knowledgecenters.org/dwcenter.asp">http://www.knowledgecenters.org/dwcenter.asp</a>

       Recommended Perl Programming Links

        <a href="http://language.perl.com/style/">http://language.perl.com/style/</a>

       <b>FAQ</b>

       Please also read the DBI FAQ which is installed as a DBI::FAQ module.  You can use <u>perldoc</u> to read it
       by executing the "perldoc DBI::FAQ" command.

<b>AUTHORS</b>
       DBI by Tim Bunce.  This pod text by Tim Bunce, J. Douglas Dunlop, Jonathan Leffler and others.  Perl
       by Larry Wall and the "perl5-porters".

<b>COPYRIGHT</b>
       The DBI module is Copyright (c) 1994-2004 Tim Bunce. Ireland.  All rights reserved.

       You may distribute under the terms of either the GNU General Public License or the Artistic License,
       as specified in the Perl README file.

<b>SUPPORT</b> <b>/</b> <b>WARRANTY</b>
       The DBI is free Open Source software. IT COMES WITHOUT WARRANTY OF ANY KIND.

       <b>Support</b>

       My consulting company, Data Plan Services, offers annual and multi-annual support contracts for the
       DBI. These provide sustained support for DBI development, and sustained value for you in return.
       Contact me for details.

       <b>Sponsor</b> <b>Enhancements</b>

       The DBI Roadmap is available at &lt;<a href="http://search.cpan.org/~timb/DBI/Roadmap.pod">http://search.cpan.org/~timb/DBI/Roadmap.pod</a>

       If your company would benefit from a specific new DBI feature, please consider sponsoring its
       development.  Work is performed rapidly, and usually on a fixed-price payment-on-delivery basis.
       Contact me for details.

       Using such targeted financing allows you to contribute to DBI development, and rapidly get something
       specific and valuable in return.

<b>ACKNOWLEDGEMENTS</b>
       I would like to acknowledge the valuable contributions of the many people I have worked with on the
       DBI project, especially in the early years (1992-1994). In no particular order: Kevin Stock, Buzz
       Moschetti, Kurt Andersen, Ted Lemon, William Hails, Garth Kennedy, Michael Peppler, Neil S. Briscoe,
       Jeff Urlwin, David J. Hughes, Jeff Stander, Forrest D Whitcher, Larry Wall, Jeff Fried, Roy Johnson,
       Paul Hudson, Georg Rehfeld, Steve Sizemore, Ron Pool, Jon Meek, Tom Christiansen, Steve Baumgarten,
       Randal Schwartz, and a whole lot more.

       Then, of course, there are the poor souls who have struggled through untold and undocumented
       obstacles to actually implement DBI drivers.  Among their ranks are Jochen Wiedmann, Alligator
       Descartes, Jonathan Leffler, Jeff Urlwin, Michael Peppler, Henrik Tougaard, Edwin Pratomo, Davide
       Migliavacca, Jan Pazdziora, Peter Haworth, Edmund Mergl, Steve Williams, Thomas Lowery, and Phlip
       Plumlee. Without them, the DBI would not be the practical reality it is today.  I'm also especially
       grateful to Alligator Descartes for starting work on the first edition of the "Programming the Perl
       DBI" book and letting me jump on board.

       The DBI and DBD::Oracle were originally developed while I was Technical Director (CTO) of the Paul
       Ingram Group (www.ig.co.uk).  So I'd especially like to thank Paul for his generosity and vision in
       supporting this work for many years.

<b>CONTRIBUTING</b>
       As you can see above, many people have contributed to the DBI and drivers in many ways over many
       years.

       If you'd like to help then see &lt;<a href="http://dbi.perl.org/contributing">http://dbi.perl.org/contributing</a> and
       &lt;<a href="http://search.cpan.org/~timb/DBI/Roadmap.pod">http://search.cpan.org/~timb/DBI/Roadmap.pod</a>

       If you'd like the DBI to do something new or different then a good way to make that happen is to do
       it yourself and send me a patch to the source code that shows the changes. (But read "Speak before
       you patch" below.)

       <b>Browsing</b> <b>the</b> <b>source</b> <b>code</b> <b>repository</b>

       Use <a href="http://svn.perl.org/modules/dbi/trunk">http://svn.perl.org/modules/dbi/trunk</a> (basic) or  <a href="http://svn.perl.org/viewcvs/modules/">http://svn.perl.org/viewcvs/modules/</a> (more
       useful)

       <b>How</b> <b>to</b> <b>create</b> <b>a</b> <b>patch</b> <b>using</b> <b>Subversion</b>

       The DBI source code is maintained using Subversion (a replacement for CVS, see
       &lt;<a href="http://subversion.tigris.org/">http://subversion.tigris.org/</a>). To access the source you'll need to install a Subversion client.
       Then, to get the source code, do:

         svn checkout <a href="http://svn.perl.org/modules/dbi/trunk">http://svn.perl.org/modules/dbi/trunk</a>

       If it prompts for a username and password use your perl.org account if you have one, else just
       'guest' and 'guest'. The source code will be in a new subdirectory called "trunk".

       To keep informed about changes to the source you can send an empty email to dbi-changes@perl.org
       after which you'll get an email with the change log message and diff of each change checked-in to the
       source.

       After making your changes you can generate a patch file, but before you do, make sure your source is
       still upto date using:

         svn update

       If you get any conflicts reported you'll need to fix them first.  Then generate the patch file from
       within the "trunk" directory using:

         svn diff &gt; foo.patch

       Read the patch file, as a sanity check, and then email it to dbi-dev@perl.org.

       <b>How</b> <b>to</b> <b>create</b> <b>a</b> <b>patch</b> <b>without</b> <b>Subversion</b>

       Unpack a fresh copy of the distribution:

         tar xfz DBI-1.40.tar.gz

       Rename the newly created top level directory:

         mv DBI-1.40 DBI-1.40.your_foo

       Edit the contents of DBI-1.40.your_foo/* till it does what you want.

       Test your changes and then remove all temporary files:

         make test &amp;&amp; make distclean

       Go back to the directory you originally unpacked the distribution:

         cd ..

       Unpack <u>another</u> copy of the original distribution you started with:

         tar xfz DBI-1.40.tar.gz

       Then create a patch file by performing a recursive "diff" on the two top level directories:

         diff -r -u DBI-1.40 DBI-1.40.your_foo &gt; DBI-1.40.your_foo.patch

       <b>Speak</b> <b>before</b> <b>you</b> <b>patch</b>

       For anything non-trivial or possibly controversial it's a good idea to discuss (on dbi-dev@perl.org)
       the changes you propose before actually spending time working on them. Otherwise you run the risk of
       them being rejected because they don't fit into some larger plans you may not be aware of.

<b>TRANSLATIONS</b>
       A German translation of this manual (possibly slightly out of date) is available, thanks to O'Reilly,
       at:

         <a href="http://www.oreilly.de/catalog/perldbiger/">http://www.oreilly.de/catalog/perldbiger/</a>

       Some other translations:

        <a href="http://cronopio.net/perl/">http://cronopio.net/perl/</a>                              - Spanish
        <a href="http://member.nifty.ne.jp/hippo2000/dbimemo.htm">http://member.nifty.ne.jp/hippo2000/dbimemo.htm</a>        - Japanese

<b>TRAINING</b>
       References to DBI related training resources. No recommendation implied.

         <a href="http://www.treepax.co.uk/">http://www.treepax.co.uk/</a>
         <a href="http://www.keller.com/dbweb/">http://www.keller.com/dbweb/</a>

       (If you offer professional DBI related training services, please send me your details so I can add
       them here.)

<b>FREQUENTLY</b> <b>ASKED</b> <b>QUESTIONS</b>
       See the DBI FAQ for a more comprehensive list of FAQs. Use the "perldoc DBI::FAQ" command to read it.

       <b>Why</b> <b>doesn't</b> <b>my</b> <b>CGI</b> <b>script</b> <b>work</b> <b>right?</b>

       Read the information in the references below.  Please do <u>not</u> post CGI related questions to the <u>dbi</u>-
       <u>users</u> mailing list (or to me).

        <a href="http://www.perl.com/cgi-bin/pace/pub/doc/FAQs/cgi/perl-cgi-faq.html">http://www.perl.com/cgi-bin/pace/pub/doc/FAQs/cgi/perl-cgi-faq.html</a>
        <a href="http://www3.pair.com/webthing/docs/cgi/faqs/cgifaq.shtml">http://www3.pair.com/webthing/docs/cgi/faqs/cgifaq.shtml</a>
        <a href="http://www-genome.wi.mit.edu/WWW/faqs/www-security-faq.html">http://www-genome.wi.mit.edu/WWW/faqs/www-security-faq.html</a>
        <a href="http://www.boutell.com/faq/">http://www.boutell.com/faq/</a>
        <a href="http://www.perl.com/perl/faq/">http://www.perl.com/perl/faq/</a>

       <b>How</b> <b>can</b> <b>I</b> <b>maintain</b> <b>a</b> <b>WWW</b> <b>connection</b> <b>to</b> <b>a</b> <b>database?</b>

       For information on the Apache httpd server and the "mod_perl" module see

         <a href="http://perl.apache.org/">http://perl.apache.org/</a>

<b>OTHER</b> <b>RELATED</b> <b>WORK</b> <b>AND</b> <b>PERL</b> <b>MODULES</b>
       Apache::DBI by E.Mergl@bawue.de
           To be used with the Apache daemon together with an embedded Perl interpreter like "mod_perl".
           Establishes a database connection which remains open for the lifetime of the HTTP daemon. This
           way the CGI connect and disconnect for every database access becomes superfluous.

       JDBC Server by Stuart 'Zen' Bishop zen@bf.rmit.edu.au
           The server is written in Perl. The client classes that talk to it are of course in Java. Thus, a
           Java applet or application will be able to comunicate via the JDBC API with any database that has
           a DBI driver installed.  The URL used is in the form
           "jdbc:dbi://host.domain.etc:999/Driver/DBName".  It seems to be very similar to some commercial
           products, such as jdbcKona.

       Remote Proxy DBD support
           As of DBI 1.02, a complete implementation of a DBD::Proxy driver and the DBI::ProxyServer are
           part of the DBI distribution.

       SQL Parser
           See also the SQL::Statement module, SQL parser and engine.



perl v5.8.8                                      2006-08-06                                           DBI(3)
</tt></pre>
</td></tr></table>
	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Darwin/Reference/ManPages/man3/DBI.3pm.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Darwin/Reference/ManPages/man3/DBI.3pm.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Darwin/Reference/ManPages/man3/DBI.3pm.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

</body></html>
