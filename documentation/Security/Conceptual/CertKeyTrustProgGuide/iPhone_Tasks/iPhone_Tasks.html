<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>Certificate, Key, and Trust Services Programming Guide: Certificate, Key, and Trust Services Tasks for iPhone OS</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Certificate, Key, and Trust Services Tasks for iPhone OS"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP40001358-CH208" title="Certificate, Key, and Trust Services Tasks for iPhone OS"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../index.html#//apple_ref/doc/uid/TP30000440-TP30000434" target="_top">Security</a> &gt; <a href="../../../Authentication-date.html#//apple_ref/doc/uid/TP30000440-TP30000434-TP30000487" target="_top">Authentication</a> &gt; <a href="../01introduction/introduction.html#//apple_ref/doc/uid/TP40001358-CH203-DontLinkElementID_10">Certificate, Key, and Trust Services Programming Guide</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../02concepts/concepts.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../03tasks/tasks.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        
        <a name="//apple_ref/doc/uid/TP40001358-CH208-SW13" title="Certificate, Key, and Trust Services Tasks for iPhone OS"></a><h1>Certificate, Key, and Trust Services Tasks for iPhone OS</h1><p>This chapter describes and illustrates the use of Certificate, Key, and Trust Services functions to import an identity, evaluate the trust of a certificate, determine the cause of a trust failure, and recover from a trust failure.</p><p>The sequence of operations illustrated in this chapter is:</p><ol class="ol"><li class="li"><p>Import an identity.</p></li><li class="li"><p>Obtain a certificate from the imported data.</p></li><li class="li"><p>Obtain a policy object for the policy used in evaluation of the certificate.</p></li><li class="li"><p>Validate the certificate and evaluate whether it can be trusted as specified by the policy.</p></li><li class="li"><p>Test for a recoverable trust error.</p></li><li class="li"><p>Determine whether the trust error is due to an expired certificate.</p></li><li class="li"><p>Change the evaluation criteria to ignore expired certificates.</p></li><li class="li"><p>Reevaluate the certificate.</p></li></ol><p><span class="content_text"><a href="../02concepts/concepts.html#//apple_ref/doc/uid/TP40001358-CH204-TP9">“Chapter 2, Certificate, Key, and Trust Services Concepts,”</a></span> provides an introduction to the concepts and terminology of Certificate, Key, and Trust Services. For detailed information about all Certificate, Key, and Trust Services functions, see <em><a href="../../../Reference/certifkeytrustservices/index.html#//apple_ref/doc/uid/TP30000157" target="_top">Certificate, Key, and Trust Services Reference</a></em>.</p>
<!-- This template is being used for both PDF and HTML. -->

    
    <h4>In this section:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="iPhone_Tasks.html#//apple_ref/doc/uid/TP40001358-CH208-DontLinkElementID_8">Extracting and Evaluating an Identity From a *.P12 File</a>
				
			<br/>
			
        
			
			
				<a href="iPhone_Tasks.html#//apple_ref/doc/uid/TP40001358-CH208-DontLinkElementID_9">Getting and Using Persistent Keychain References</a>
				
			<br/>
			
        
			
			
				<a href="iPhone_Tasks.html#//apple_ref/doc/uid/TP40001358-CH208-SW2">Finding a Certificate In the Keychain</a>
				
			<br/>
			
        
			
			
				<a href="iPhone_Tasks.html#//apple_ref/doc/uid/TP40001358-CH208-SW10">Obtaining a Policy Object and Evaluating Trust</a>
				
			<br/>
			
        
			
			
				<a href="iPhone_Tasks.html#//apple_ref/doc/uid/TP40001358-CH208-SW8">Recovering From a Trust Failure</a>
				
			<br/>
			
        
			
			
				<a href="iPhone_Tasks.html#//apple_ref/doc/uid/TP40001358-CH208-SW9">Encrypting and Decrypting Data</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/TP40001358-CH208-DontLinkElementID_8" title="Extracting and Evaluating an Identity From a *.P12 File"></a><h2>Extracting and Evaluating an Identity From a *.P12 File</h2><p>If you need a cryptographic identity (that is, a private key and its associated certificate) on the iPhone or iPod Touch—for client-side authentication, for example—you can transfer it to the device securely as PKCS #12 data in a password-protected <code>*.p12</code> file. This section shows how to extract the identity and trust objects from the PKCS #12 data and how to evaluate the trust.</p><p><span class="content_text">Listing 2-1</span> shows sample code for using the <code>SecPKCS12Import</code> function to extract identity and trust objects from a <code>*.p12</code> file and how to evaluate the trust. <span class="content_text"><a href="iPhone_Tasks.html#//apple_ref/doc/uid/TP40001358-CH208-SW5">Listing 2-2</a></span> shows how to get the certificate from the identity and display certificate information. Explanations for numbered lines of code follow each listing.</p><a name="//apple_ref/doc/uid/TP40001358-CH208-SW1" title="Listing 2-1Extracting identity and trust objects from PKCS #12 Data"></a><p class="codesample"><strong>Listing 2-1&nbsp;&nbsp;</strong>Extracting identity and trust objects from PKCS #12 Data</p><div class="codesample"><table><tr><td scope="row"><pre>#import &lt;UIKit/UIKit.h><span></span></pre></td></tr><tr><td scope="row"><pre>#import &lt;Security/Security.h><span></span></pre></td></tr><tr><td scope="row"><pre>#import &lt;CoreFoundation/CoreFoundation.h><span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    NSString *thePath = [[NSBundle mainBundle]<span></span></pre></td></tr><tr><td scope="row"><pre>                            pathForResource:@"MyIdentity" ofType:@"p12"];<span></span></pre></td></tr><tr><td scope="row"><pre>    NSData *PKCS12Data = [[NSData alloc] initWithContentsOfFile:thePath];<span></span></pre></td></tr><tr><td scope="row"><pre>    CFDataRef inPKCS12Data = (CFDataRef)PKCS12Data;             <span>// 1</span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>     OSStatus status = noErr;<span></span></pre></td></tr><tr><td scope="row"><pre>    SecIdentityRef myIdentity;<span></span></pre></td></tr><tr><td scope="row"><pre>    SecTrustRef myTrust;<span></span></pre></td></tr><tr><td scope="row"><pre>    status = extractIdentityAndTrust(<span></span></pre></td></tr><tr><td scope="row"><pre>                                     inPKCS12Data,<span></span></pre></td></tr><tr><td scope="row"><pre>                                     &amp;myIdentity,<span></span></pre></td></tr><tr><td scope="row"><pre>                                     &amp;myTrust);                 <span>// 2</span></pre></td></tr><tr><td scope="row"><pre>    if status != 0 ...  //Do some error checking here<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>SecTrustResultType trustResult;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if (status == noErr) {                                      <span>// 3</span></pre></td></tr><tr><td scope="row"><pre>        status = SecTrustEvaluate(myTrust, &amp;trustResult);<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>...                                                             <span>// 4</span></pre></td></tr><tr><td scope="row"><pre>    if (trustResult == kSecTrustResultRecoverableTrustFailure) {<span></span></pre></td></tr><tr><td scope="row"><pre>        ...;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>OSStatus extractIdentityAndTrust(CFDataRef inPKCS12Data,        <span>// 5</span></pre></td></tr><tr><td scope="row"><pre>                                 SecIdentityRef *outIdentity,<span></span></pre></td></tr><tr><td scope="row"><pre>                                 SecTrustRef *outTrust)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    OSStatus securityError = errSecSuccess;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    CFStringRef password = CFSTR("Password");<span></span></pre></td></tr><tr><td scope="row"><pre>    const void *keys[] =   { kSecImportExportPassphrase };<span></span></pre></td></tr><tr><td scope="row"><pre>    const void *values[] = { password };<span></span></pre></td></tr><tr><td scope="row"><pre>    CFDictionaryRef optionsDictionary = CFDictionaryCreate(<span></span></pre></td></tr><tr><td scope="row"><pre>                                                  NULL, keys,<span></span></pre></td></tr><tr><td scope="row"><pre>                                                  values, 1<span></span></pre></td></tr><tr><td scope="row"><pre>                                                  NULL, NULL);  <span>// 6</span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    CFArrayRef items = CFArrayCreate(NULL, 0, 0, NULL);<span></span></pre></td></tr><tr><td scope="row"><pre>    securityError = SecPKCS12Import(inPKCS12Data,<span></span></pre></td></tr><tr><td scope="row"><pre>                                    optionsDictionary,<span></span></pre></td></tr><tr><td scope="row"><pre>                                    &amp;items);                    <span>// 7</span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    //<span></span></pre></td></tr><tr><td scope="row"><pre>    if (securityError == 0) {                                   <span>// 8</span></pre></td></tr><tr><td scope="row"><pre>        CFDictionaryRef myIdentityAndTrust = CFArrayGetValueAtIndex (items, 0);<span></span></pre></td></tr><tr><td scope="row"><pre>        const void *tempIdentity = NULL;<span></span></pre></td></tr><tr><td scope="row"><pre>        tempIdentity = CFDictionaryGetValue (myIdentityAndTrust,<span></span></pre></td></tr><tr><td scope="row"><pre>                                                       kSecImportItemIdentity);<span></span></pre></td></tr><tr><td scope="row"><pre>        *outIdentity = (SecIdentityRef)tempIdentity;<span></span></pre></td></tr><tr><td scope="row"><pre>        const void *tempTrust = NULL;<span></span></pre></td></tr><tr><td scope="row"><pre>        tempTrust = CFDictionaryGetValue (myIdentityAndTrust, kSecImportItemTrust);<span></span></pre></td></tr><tr><td scope="row"><pre>        *outTrust = (SecTrustRef)tempTrust;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if (optionsDictionary)<span></span></pre></td></tr><tr><td scope="row"><pre>        CFRelease(optionsDictionary);                           <span>// 9</span></pre></td></tr><tr><td scope="row"><pre>     [PKCS12Data release];<span></span></pre></td></tr></table></div><p></p><p>Here’s what the code does:</p><ol class="ol"><li class="li"><p>Finds the PKCS #12 file and gets the data. In this example, the file is included in the application bundle. However, you can transfer the file to your application over a network if you prefer.</p></li><li class="li"><p>Calls the function that gets the identity and trust from the PKCS #12 file (see step #5).</p></li><li class="li"><p>Evaluates the trust. In this case, the trust object, containing the policy and other information needed to determine whether the certificate is trusted, is included in the PKCS data. To evaluate the trust of an isolated certificate, see <span class="content_text"><a href="iPhone_Tasks.html#//apple_ref/doc/uid/TP40001358-CH208-SW3">Listing 2-6</a></span>.</p></li><li class="li"><p>Handles the trust result. If the trust result is <code>kSecTrustResultInvalid</code>, <code>kSecTrustResultDeny</code>, <code>kSecTrustResultFatalTrustFailure</code>, you cannot proceed and should fail gracefully. If the trust result is <code>kSecTrustResultRecoverableTrustFailure</code>, you might be able to recover from the failure. See <span class="content_text"><a href="iPhone_Tasks.html#//apple_ref/doc/uid/TP40001358-CH208-SW8">“Recovering From a Trust Failure.”</a></span></p></li><li class="li"><p>Implements the function called in step #2.</p></li><li class="li"><p>Sets up dictionary containing the password to pass to <code>SecPKCS12Import</code>. Notice that core foundation dictionaries—as used here—and the <code>NSDictionary</code> class are entirely equivalent. See <span class="content_text"><a href="iPhone_Tasks.html#//apple_ref/doc/uid/TP40001358-CH208-SW7">Listing 2-9</a></span> for an example using <code>NSDictionary</code> methods.</p></li><li class="li"><p>Extracts the certificate, key, and trust from the PKCS #12 data and puts them in an array.</p></li><li class="li"><p>Gets the first dictionary out of the array and gets the identity and trust out of the dictionary. The <code>SecPKCS12Import</code> function returns one dictionary for each item (identity or certificate) in the PKCS #12 data. In this sample, the identity being extracted is the first one in the array (item #0).</p></li><li class="li"><p>Disposes of the options dictionary and releases the PKCS12Data, which are no longer needed.</p></li></ol><p>The following listing shows how to get the certificate from the identity and how to display information from the certificate. </p><a name="//apple_ref/doc/uid/TP40001358-CH208-SW5" title="Listing 2-2Displaying information from the certificate"></a><p class="codesample"><strong>Listing 2-2&nbsp;&nbsp;</strong>Displaying information from the certificate</p><div class="codesample"><table><tr><td scope="row"><pre>    // Get the certificate from the identity.<span></span></pre></td></tr><tr><td scope="row"><pre>    SecCertificateRef myReturnedCertificate = NULL;<span></span></pre></td></tr><tr><td scope="row"><pre>    status = SecIdentityCopyCertificate (myReturnedIdentity,<span></span></pre></td></tr><tr><td scope="row"><pre>                                      &amp;myReturnedCertificate);  <span>// 1</span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    CFStringRef certSummary = SecCertificateCopySubjectSummary<span></span></pre></td></tr><tr><td scope="row"><pre>                                      (myReturnedCertificate);  <span>// 2</span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    NSString* summaryString = [[NSString alloc]<span></span></pre></td></tr><tr><td scope="row"><pre>                       initWithString:(NSString*)certSummary];  <span>// 3</span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    //Display the string<span></span></pre></td></tr><tr><td scope="row"><pre>...<span></span></pre></td></tr><tr><td scope="row"><pre>     [summaryString release];                                   <span>// 4</span></pre></td></tr></table></div><p>Here’s what the code does:</p><ol class="ol"><li class="li"><p>Extracts the certificate from the identity.</p></li><li class="li"><p>Gets summary information from the certificate. </p></li><li class="li"><p>Converts the string to an <code>NSString</code> object so it can be displayed.</p></li><li class="li"><p>Releases the <code>NSString</code> object.</p></li></ol><a name="//apple_ref/doc/uid/TP40001358-CH208-DontLinkElementID_9" title="Getting and Using Persistent Keychain References"></a><h2>Getting and Using Persistent Keychain References</h2><p>When you add an item to the keychain or find an item in the keychain, you can request a persistent reference. Because a persistent reference remains valid between invocations of your program and can be stored on disk, you can use one to make it easier to find a keychain item that you will need repeatedly. The following code sample shows how to obtain a persistent reference for the identity object obtained in <span class="content_text"><a href="iPhone_Tasks.html#//apple_ref/doc/uid/TP40001358-CH208-SW1">Listing 2-1</a></span>.</p><a name="//apple_ref/doc/uid/TP40001358-CH208-DontLinkElementID_71" title="Listing 2-3Getting a persistent reference for an identity"></a><p class="codesample"><strong>Listing 2-3&nbsp;&nbsp;</strong>Getting a persistent reference for an identity</p><div class="codesample"><table><tr><td scope="row"><pre>CFDataRef persistentRefForIdentity(SecIdentityRef identity)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    OSStatus status;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    CFTypeRef  identity_handle = NULL;<span></span></pre></td></tr><tr><td scope="row"><pre>    const void *keys[] =   { kSecReturnPersistentRef, kSecValueRef };<span></span></pre></td></tr><tr><td scope="row"><pre>    const void *values[] = { kCFBooleanTrue,          identity };<span></span></pre></td></tr><tr><td scope="row"><pre>    CFDictionaryRef dict = CFDictionaryCreate(NULL, keys, values,<span></span></pre></td></tr><tr><td scope="row"><pre>                                              2, NULL, NULL);<span></span></pre></td></tr><tr><td scope="row"><pre>    status = SecItemAdd(dict, &amp;persistent_ref);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if (dict)<span></span></pre></td></tr><tr><td scope="row"><pre>        CFRelease(dict);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    return (CFDataRef)persistent_ref;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>The following sample shows how to retrieve the identity object from the keychain using the persistent reference.</p><a name="//apple_ref/doc/uid/TP40001358-CH208-SW6" title="Listing 2-4Getting an identity using a persistent reference"></a><p class="codesample"><strong>Listing 2-4&nbsp;&nbsp;</strong>Getting an identity using a persistent reference</p><div class="codesample"><table><tr><td scope="row"><pre>SecIdentityRef identityForPersistentRef(CFDataRef persistent_ref)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    CFTypeRef   identity_ref     = NULL;<span></span></pre></td></tr><tr><td scope="row"><pre>    const void *keys[] =   { kSecReturnRef,  kSecValuePersistentRef };<span></span></pre></td></tr><tr><td scope="row"><pre>    const void *values[] = { kCFBooleanTrue, persistent_ref };<span></span></pre></td></tr><tr><td scope="row"><pre>    CFDictionaryRef dict = CFDictionaryCreate(NULL, keys, values,<span></span></pre></td></tr><tr><td scope="row"><pre>                                              2, NULL, NULL);<span></span></pre></td></tr><tr><td scope="row"><pre>    SecItemCopyMatching(dict, &amp;identity_ref);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if (dict)<span></span></pre></td></tr><tr><td scope="row"><pre>        CFRelease(dict);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    return (SecIdentityRef)identity_ref;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40001358-CH208-SW2" title="Finding a Certificate In the Keychain"></a><h2>Finding a Certificate In the Keychain</h2><p>The following code sample shows how to find a certificate in the keychain using the name of the certificate to identify it. To find a keychain item using a persistent reference, see <span class="content_text"><a href="iPhone_Tasks.html#//apple_ref/doc/uid/TP40001358-CH208-SW6">Listing 2-4</a></span>. To find a keychain item using an identifier string stored as a keychain item attribute, see <span class="content_text"><a href="iPhone_Tasks.html#//apple_ref/doc/uid/TP40001358-CH208-SW9">“Encrypting and Decrypting Data.”</a></span> An explanation for each numbered line of code follows the listing.</p><a name="//apple_ref/doc/uid/TP40001358-CH208-SW4" title="Listing 2-5Finding a certificate In the Keychain"></a><p class="codesample"><strong>Listing 2-5&nbsp;&nbsp;</strong>Finding a certificate In the Keychain</p><div class="codesample"><table><tr><td scope="row"><pre>    CFTypeRef   certificateRef     = NULL;                      <span>// 1</span></pre></td></tr><tr><td scope="row"><pre>    const char *certLabelString = "Romeo Montegue";<span></span></pre></td></tr><tr><td scope="row"><pre>    CFStringRef certLabel = CFStringCreateWithCString(<span></span></pre></td></tr><tr><td scope="row"><pre>                                NULL, certLabelString,<span></span></pre></td></tr><tr><td scope="row"><pre>                                kCFStringEncodingUTF8);         <span>// 2</span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    const void *keys[] =   { kSecClass, kSecAttrLabel, kSecReturnRef };<span></span></pre></td></tr><tr><td scope="row"><pre>    const void *values[] = { kSecClassCertificate, certLabel, kCFBooleanTrue };<span></span></pre></td></tr><tr><td scope="row"><pre>    CFDictionaryRef dict = CFDictionaryCreate(NULL, keys,<span></span></pre></td></tr><tr><td scope="row"><pre>                                               values, 3,<span></span></pre></td></tr><tr><td scope="row"><pre>                                             NULL, NULL);       <span>// 3</span></pre></td></tr><tr><td scope="row"><pre>    status = SecItemCopyMatching(dict, &amp;certificateRef);        <span>// 4</span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if (dict)<span></span></pre></td></tr><tr><td scope="row"><pre>        CFRelease(dict);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr></table></div><p>Here’s what the code does:</p><ol class="ol"><li class="li"><p>Defines a variable to hold the certificate object.</p></li><li class="li"><p>Creates a string containing the name of the certificate.</p></li><li class="li"><p>Creates a dictionary of attributes to be used in the certificate search. The <code>kSecReturnRef</code> key specifies that the function should return a reference to the keychain item when it’s found.</p></li><li class="li"><p>Searches for the certificate in the keychain.</p></li></ol><a name="//apple_ref/doc/uid/TP40001358-CH208-SW10" title="Obtaining a Policy Object and Evaluating Trust"></a><h2>Obtaining a Policy Object and Evaluating Trust</h2><p>Before you can evaluate the trust of a certificate, you must obtain a reference object for the certificate. You can obtain a certificate object by extracting it from an identity (see <span class="content_text"><a href="iPhone_Tasks.html#//apple_ref/doc/uid/TP40001358-CH208-SW5">Listing 2-2</a></span>), by creating one from DER certificate data using the <code>SecCertificateCreateWithData</code> function (see the following sample: <span class="content_text">Listing 2-6</span>), or by finding the certificate on a keychain (<span class="content_text"><a href="iPhone_Tasks.html#//apple_ref/doc/uid/TP40001358-CH208-SW4">Listing 2-5</a></span>). </p><p>The criteria for evaluation of trust are set by trust policies. <span class="content_text">Listing 3-2</span> shows how you can obtain a policy object for use in an evaluation. There are two policies available in iPhone OS for this purpose: Basic X509 and SSL (see <span class="content_text"><a href="../../../Reference/certifkeytrustservices/certKeyTrustPolicies/certKeyTrustPolicies.html#//apple_ref/doc/uid/TP30000157-CH204" target="_top">AppleX509TP Trust Policies</a></span>). You use the <code>SecPolicyCreateBasicX509</code> or <code>SecPolicyCreateSSL</code> function to obtain the policy object. </p><p>The following code sample shows how to obtain a policy object and use it to evaluate trust of a certificate. An explanation for each numbered line of code follows the listing.</p><a name="//apple_ref/doc/uid/TP40001358-CH208-SW3" title="Listing 2-6Obtaining a policy reference object and evaluating trust"></a><p class="codesample"><strong>Listing 2-6&nbsp;&nbsp;</strong>Obtaining a policy reference object and evaluating trust</p><div class="codesample"><table><tr><td scope="row"><pre>    NSString *thePath = [[NSBundle mainBundle]<span></span></pre></td></tr><tr><td scope="row"><pre>                          pathForResource:@"Romeo Montegue" ofType:@"cer"];<span></span></pre></td></tr><tr><td scope="row"><pre>    NSData *certData = [[NSData alloc]<span></span></pre></td></tr><tr><td scope="row"><pre>                         initWithContentsOfFile:thePath];<span></span></pre></td></tr><tr><td scope="row"><pre>    CFDataRef myCertData = (CFDataRef)certData;                 <span>// 1</span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    SecCertificateRef myCert;<span></span></pre></td></tr><tr><td scope="row"><pre>    myCert = SecCertificateCreateWithData(NULL, myCertData);    <span>// 2</span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    SecPolicyRef myPolicy = SecPolicyCreateBasicX509();         <span>// 3</span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    SecCertificateRef certArray[1] = { myCert };<span></span></pre></td></tr><tr><td scope="row"><pre>    CFArrayRef myCerts = CFArrayCreate(<span></span></pre></td></tr><tr><td scope="row"><pre>                                       NULL, (void *)certArray,<span></span></pre></td></tr><tr><td scope="row"><pre>                                       1, NULL);<span></span></pre></td></tr><tr><td scope="row"><pre>    SecTrustRef myTrust;<span></span></pre></td></tr><tr><td scope="row"><pre>    OSStatus status = SecTrustCreateWithCertificates(<span></span></pre></td></tr><tr><td scope="row"><pre>                                                    myCerts,<span></span></pre></td></tr><tr><td scope="row"><pre>                                                    myPolicy,<span></span></pre></td></tr><tr><td scope="row"><pre>                                                    &amp;myTrust);  <span>// 4</span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    SecTrustResultType trustResult;<span></span></pre></td></tr><tr><td scope="row"><pre>    if (status == noErr) {<span></span></pre></td></tr><tr><td scope="row"><pre>        status = SecTrustEvaluate(myTrust, &amp;trustResult);       <span>// 5</span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>...                                                             <span>// 6</span></pre></td></tr><tr><td scope="row"><pre>    if (trustResult == kSecTrustResultRecoverableTrustFailure) {<span></span></pre></td></tr><tr><td scope="row"><pre>        ...;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>...<span></span></pre></td></tr><tr><td scope="row"><pre>    if (myPolicy)<span></span></pre></td></tr><tr><td scope="row"><pre>        CFRelease(myPolicy);                                    <span>// 7</span></pre></td></tr></table></div><p>Here’s what the code does:</p><ol class="ol"><li class="li"><p>Finds the certificate file and gets the data. In this example, the file is included in the application bundle. However, you can transfer the certificate to your application over a network if you prefer. If the certificate is already in the keychain, see <span class="content_text"><a href="iPhone_Tasks.html#//apple_ref/doc/uid/TP40001358-CH208-SW2">“Finding a Certificate In the Keychain.”</a></span></p></li><li class="li"><p>Creates a certificate reference from the certificate data.</p></li><li class="li"><p>Creates a policy to be used in evaluating trust.</p></li><li class="li"><p>Creates a trust object using the certificate and the policy. If you have intermediate certificates or an anchor certificate for the certificate chain, you can include those in the certificate array passed to the <code>SecTrustCreateWithCertificates</code> function. Doing so speeds up the trust evaluation.</p></li><li class="li"><p>Evaluates the trust.</p></li><li class="li"><p>Handles the trust result. If the trust result is <code>kSecTrustResultInvalid</code>, <code>kSecTrustResultDeny</code>, <code>kSecTrustResultFatalTrustFailure</code>, you cannot proceed and should fail gracefully. If the trust result is <code>kSecTrustResultRecoverableTrustFailure</code>, you might be able to recover from the failure. See <span class="content_text"><a href="iPhone_Tasks.html#//apple_ref/doc/uid/TP40001358-CH208-SW8">“Recovering From a Trust Failure.”</a></span></p></li><li class="li"><p>Disposes of the policy object at the end of the routine, after it has been used to evaluate the trust.</p></li></ol><a name="//apple_ref/doc/uid/TP40001358-CH208-SW8" title="Recovering From a Trust Failure"></a><h2>Recovering From a Trust Failure</h2><p>There are several possible results of a trust evaluation, depending on such factors as whether all the certificates in the chain were found, whether they are all valid, and what the user trust settings are for the certificates. It is up to your application to determine the course of action based on the result of the evaluation. For example, if the result is <code>kSecTrustResultConfirm</code>, you should display a dialog requesting that the user give permission to proceed.</p><p>The evaluation result <code>kSecTrustResultRecoverableTrustFailure</code> indicates that trust was denied, but that it is possible to change settings to get a different result. For example, if the certificate used to sign a document has expired, you can change the date used for the evaluation to see whether the certificate was valid when the document was signed. The code in <span class="content_text">Listing 3-4</span> illustrates how to change the evaluation date. Note that the <code><a href="../../../../CoreFoundation/Reference/CFDateRef/Reference/reference.html#//apple_ref/c/func/CFDateCreate" target="_top">CFDateCreate</a></code> function takes an absolute time (the number of seconds since 1 January 2001); you can use the <code><a href="../../../../CoreFoundation/Reference/CFTimeUtils/Reference/reference.html#//apple_ref/c/func/CFGregorianDateGetAbsoluteTime" target="_top">CFGregorianDateGetAbsoluteTime</a></code> function to convert a calendar date and time into an absolute time. An explanation for each numbered line of code follows the listing.</p><a name="//apple_ref/doc/uid/TP40001358-CH208-DontLinkElementID_72" title="Listing 2-7Setting an evaluation date"></a><p class="codesample"><strong>Listing 2-7&nbsp;&nbsp;</strong>Setting an evaluation date</p><div class="codesample"><table><tr><td scope="row"><pre>        SecTrustResultType trustResult;<span></span></pre></td></tr><tr><td scope="row"><pre>        status = SecTrustEvaluate(myTrust, &amp;trustResult);       <span>// 1</span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    //Get time used to verify trust<span></span></pre></td></tr><tr><td scope="row"><pre>    CFAbsoluteTime trustTime,currentTime,timeIncrement,newTime;<span></span></pre></td></tr><tr><td scope="row"><pre>    CFDateRef newDate;<span></span></pre></td></tr><tr><td scope="row"><pre>    if (trustResult == kSecTrustResultRecoverableTrustFailure) {<span>// 2</span></pre></td></tr><tr><td scope="row"><pre>        trustTime = SecTrustGetVerifyTime(myTrust);             <span>// 3</span></pre></td></tr><tr><td scope="row"><pre>        timeIncrement = 31536000;                               <span>// 4</span></pre></td></tr><tr><td scope="row"><pre>        currentTime = CFAbsoluteTimeGetCurrent();               <span>// 5</span></pre></td></tr><tr><td scope="row"><pre>        newTime = currentTime - timeIncrement;                  <span>// 6</span></pre></td></tr><tr><td scope="row"><pre>        if (trustTime - newTime){                               <span>// 7</span></pre></td></tr><tr><td scope="row"><pre>            newDate = CFDateCreate(NULL, newTime);              <span>// 8</span></pre></td></tr><tr><td scope="row"><pre>            SecTrustSetVerifyDate(myTrust, newDate);            <span>// 9</span></pre></td></tr><tr><td scope="row"><pre>            status = SecTrustEvaluate(myTrust, &amp;trustResult);   <span>// 10</span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    if (trustResult != kSecTrustResultProceed) {                <span>// 11</span></pre></td></tr><tr><td scope="row"><pre>...<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>Here’s what the code does:</p><ol class="ol"><li class="li"><p>Evaluates the trust of the certificate. See <span class="content_text"><a href="iPhone_Tasks.html#//apple_ref/doc/uid/TP40001358-CH208-SW10">“Obtaining a Policy Object and Evaluating Trust.”</a></span></p></li><li class="li"><p>Checks whether the result of the trust evaluation was a recoverable trust failure.</p></li><li class="li"><p>Gets the absolute time that was used to evaluate the trust. If the certificate expired before this time, then it is considered invalid.</p></li><li class="li"><p>Sets a time increment equal to the number of seconds in a year.</p></li><li class="li"><p>Gets the current (absolute) time. </p></li><li class="li"><p>Subtracts a year from the current time.</p></li><li class="li"><p>Checks whether the time used to evaluate trust was more recent than one year before the current time. If it was, then the trust is evaluated again using the new time; that is, the certificate is checked to see if it failed verification because it expired sometime in the past year.</p></li><li class="li"><p>Converts the new time to a <code>CFDateRef</code>. You can also use <code>NSDate</code> to manipulate the dates; <code>CFDateRef</code> and <code>NSDate</code> are toll-free bridged, meaning in a method where you see an <code>NSDate *</code> parameter, you can pass in a <code>CFDateRef</code>, and in a function where you see a <code>CFDateRef</code> parameter, you can pass in an instance of <code>NSDate</code> or of a concrete subclass of <code>NSDate</code>.</p></li><li class="li"><p>Sets the date used to verify trust to the new time (a year earlier).</p></li><li class="li"><p>Reevaluates the trust. If the reason the trust evaluation failed was because the certificate expired within a year of the current time, the evaluation should now succeed.</p></li><li class="li"><p>Checks whether the evaluation now succeeds. If not, you can try something else, such as asking the user to install an intermediate certificate, or you can tell the user that the certificate is not valid and fail gracefully.</p></li></ol><a name="//apple_ref/doc/uid/TP40001358-CH208-SW9" title="Encrypting and Decrypting Data"></a><h2>Encrypting and Decrypting Data</h2><p>The Certificate, Key, and Trust API includes functions for generating asymmetric key pairs and using them to encrypt and decrypt data. You might want to use this feature to encrypt data that you do not want to be accessible in backup data, for example. Or, you can use a private-public key pair shared between your iPhone OS application and a desktop application to send encrypted data over a network. The code in <span class="content_text">Listing 2-8</span> shows how to generate a public-private key pair for use on the mobile device. <span class="content_text"><a href="iPhone_Tasks.html#//apple_ref/doc/uid/TP40001358-CH208-SW7">Listing 2-9</a></span> shows how to use a public key to encrypt data using Certificate, Key, and Trust functions, and <span class="content_text"><a href="iPhone_Tasks.html#//apple_ref/doc/uid/TP40001358-CH208-SW12">Listing 2-10</a></span> shows how to use a private key to decrypt data. Notice that these samples use Cocoa objects (such as <code>NSMutableDictionary</code>) rather than the core foundation objects (such as <code>CFMutableDictionaryRef</code>) used in other samples in this chapter. The Cocoa objects and their Core Foundation counterparts are completely equivalent and are toll-free bridged; for example, in a method where you see an <code>NSMutableDictionary *</code> parameter, you can pass in a <code>CFMutableDictionaryRef</code>, and in a function where you see a <code>CFMutableDictionaryRef</code> parameter, you can pass in an instance of <code>NSMutableDictionary</code>. Explanations for numbered lines of code follow each listing.</p><a name="//apple_ref/doc/uid/TP40001358-CH208-SW11" title="Listing 2-8Generating a key pair"></a><p class="codesample"><strong>Listing 2-8&nbsp;&nbsp;</strong>Generating a key pair</p><div class="codesample"><table><tr><td scope="row"><pre>static const UInt8 publicKeyIdentifier[] = "com.apple.sample.publickey\0";<span></span></pre></td></tr><tr><td scope="row"><pre>static const UInt8 privateKeyIdentifier[] = "com.apple.sample.privatekey\0";<span></span></pre></td></tr><tr><td scope="row"><pre>                                                                <span>// 1</span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>- (void)generateKeyPairPlease<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    OSStatus status = noErr;<span></span></pre></td></tr><tr><td scope="row"><pre>    NSMutableDictionary *privateKeyAttr = [[NSMutableDictionary alloc] init];<span></span></pre></td></tr><tr><td scope="row"><pre>    NSMutableDictionary *publicKeyAttr = [[NSMutableDictionary alloc] init];<span></span></pre></td></tr><tr><td scope="row"><pre>    NSMutableDictionary *keyPairAttr = [[NSMutableDictionary alloc] init];<span></span></pre></td></tr><tr><td scope="row"><pre>                                                                <span>// 2</span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    NSData * publicTag = [NSData dataWithBytes:publicKeyIdentifier<span></span></pre></td></tr><tr><td scope="row"><pre>                                length:strlen((const char *)publicKeyIdentifier)];<span></span></pre></td></tr><tr><td scope="row"><pre>    NSData * privateTag = [NSData dataWithBytes:privateKeyIdentifier<span></span></pre></td></tr><tr><td scope="row"><pre>                               length:strlen((const char *)privateKeyIdentifier)];<span></span></pre></td></tr><tr><td scope="row"><pre>                                                                <span>// 3</span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    SecKeyRef publicKey = NULL;<span></span></pre></td></tr><tr><td scope="row"><pre>    SecKeyRef privateKey = NULL;                                <span>// 4</span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    [keyPairAttr setObject:(id)kSecAttrKeyTypeRSA<span></span></pre></td></tr><tr><td scope="row"><pre>                                   forKey:(id)kSecAttrKeyType]; <span>// 5</span></pre></td></tr><tr><td scope="row"><pre>    [keyPairAttr setObject:[NSNumber numberWithInt:1024]<span></span></pre></td></tr><tr><td scope="row"><pre>                             forKey:(id)kSecAttrKeySizeInBits]; <span>// 6</span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    [privateKeyAttr setObject:[NSNumber numberWithBool:YES]<span></span></pre></td></tr><tr><td scope="row"><pre>                               forKey:(id)kSecAttrIsPermanent]; <span>// 7</span></pre></td></tr><tr><td scope="row"><pre>    [privateKeyAttr setObject:privateTag<span></span></pre></td></tr><tr><td scope="row"><pre>                            forKey:(id)kSecAttrApplicationTag]; <span>// 8</span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    [publicKeyAttr setObject:[NSNumber numberWithBool:YES]<span></span></pre></td></tr><tr><td scope="row"><pre>                               forKey:(id)kSecAttrIsPermanent]; <span>// 9</span></pre></td></tr><tr><td scope="row"><pre>    [publicKeyAttr setObject:publicTag<span></span></pre></td></tr><tr><td scope="row"><pre>                            forKey:(id)kSecAttrApplicationTag]; <span>// 10</span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    [keyPairAttr setObject:privateKeyAttr<span></span></pre></td></tr><tr><td scope="row"><pre>                               forKey:(id)kSecPrivateKeyAttrs]; <span>// 11</span></pre></td></tr><tr><td scope="row"><pre>    [keyPairAttr setObject:publicKeyAttr<span></span></pre></td></tr><tr><td scope="row"><pre>                                forKey:(id)kSecPublicKeyAttrs]; <span>// 12</span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    status = SecKeyGeneratePair((CFDictionaryRef)keyPairAttr,<span></span></pre></td></tr><tr><td scope="row"><pre>                                      &amp;publicKey, &amp;privateKey); <span>// 13</span></pre></td></tr><tr><td scope="row"><pre>//    error handling...<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if(privateKeyAttr) [privateKeyAttr release];<span></span></pre></td></tr><tr><td scope="row"><pre>    if(publicKeyAttr) [publicKeyAttr release];<span></span></pre></td></tr><tr><td scope="row"><pre>    if(keyPairAttr) [keyPairAttr release];<span></span></pre></td></tr><tr><td scope="row"><pre>    if(publicKey) CFRelease(publicKey);<span></span></pre></td></tr><tr><td scope="row"><pre>    if(privateKey) CFRelease(privateKey);                       <span>// 14</span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>Here’s what the code does:</p><ol class="ol"><li class="li"><p>Defines unique strings to be added as attributes to the private and public key keychain items to make them easier to find later.</p></li><li class="li"><p>Allocates dictionaries to be used for attributes in the <code>SecKeyGeneratePair</code> function. </p></li><li class="li"><p>Creates <code>NSData</code> objects that contain the identifier strings defined in step 1.</p></li><li class="li"><p>Allocates <code>SecKeyRef</code> objects for the public and private keys.</p></li><li class="li"><p>Sets the key-type attribute for the key pair to RSA.</p></li><li class="li"><p>Sets the key-size attribute for the key pair to 1024 bits.</p></li><li class="li"><p>Sets an attribute specifying that the private key is to be stored permanently (that is, put into the keychain).</p></li><li class="li"><p>Adds the identifier string defined in steps 1 and 3 to the dictionary for the private key.</p></li><li class="li"><p>Sets an attribute specifying that the public key is to be stored permanently (that is, put into the keychain).</p></li><li class="li"><p>Adds the identifier string defined in steps 1 and 3 to the dictionary for the public key.</p></li><li class="li"><p>Adds the dictionary of private key attributes to the key-pair dictionary.</p></li><li class="li"><p>Adds the dictionary of public key attributes to the key-pair dictionary.</p></li><li class="li"><p>Generates the key pair.</p></li><li class="li"><p>Releases memory that is no longer needed.</p></li></ol><p>You can send your public key to anyone, who can then use it to encrypt data. Assuming you keep your private key secure, then only you will be able to decrypt the data. The following code sample shows how to encrypt data using a public key. This can be a public key that you generated on the device (see the preceding code sample) or a public key that you extracted from a certificate that was sent to you or that is in your keychain. You can use the <code>SecTrustCopyPublicKey</code> function to extract a public key from a certificate. In the following code sample, the key is assumed to have been generated on the device and placed in the keychain. An explanation for each numbered line of code follows the listing.</p><a name="//apple_ref/doc/uid/TP40001358-CH208-SW7" title="Listing 2-9Encrypting data with a public key"></a><p class="codesample"><strong>Listing 2-9&nbsp;&nbsp;</strong>Encrypting data with a public key</p><div class="codesample"><table><tr><td scope="row"><pre>- (void)encryptWithPublicKey<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    OSStatus status = noErr;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    size_t cipherBufferSize = 256;<span></span></pre></td></tr><tr><td scope="row"><pre>    uint8_t cipherBuffer[cipherBufferSize];                     <span>// 1</span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    const uint8_t nonce[] = "the quick brown fox jumps<span></span></pre></td></tr><tr><td scope="row"><pre>                                          over the lazy dog\0"; <span>// 2</span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    SecKeyRef publicKey = NULL;                                 <span>// 3</span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    NSData * publicTag = [NSData dataWithBytes:publicKeyIdentifier<span></span></pre></td></tr><tr><td scope="row"><pre>             length:strlen((const char *)publicKeyIdentifier)]; <span>// 4</span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    NSMutableDictionary *queryPublicKey =<span></span></pre></td></tr><tr><td scope="row"><pre>                            [[NSMutableDictionary alloc] init]; <span>// 5</span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    [queryPublicKey setObject:(id)kSecClassKey forKey:(id)kSecClass];<span></span></pre></td></tr><tr><td scope="row"><pre>    [queryPublicKey setObject:publicTag forKey:(id)kSecAttrApplicationTag];<span></span></pre></td></tr><tr><td scope="row"><pre>    [queryPublicKey setObject:(id)kSecAttrKeyTypeRSA forKey:(id)kSecAttrKeyType];<span></span></pre></td></tr><tr><td scope="row"><pre>    [queryPublicKey setObject:[NSNumber numberWithBool:YES] forKey:(id)kSecReturnRef];<span></span></pre></td></tr><tr><td scope="row"><pre>                                                                <span>// 6</span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    status = SecItemCopyMatching<span></span></pre></td></tr><tr><td scope="row"><pre>    ((CFDictionaryRef)queryPublicKey, (CFTypeRef *)&amp;publicKey); <span>// 7</span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>//  Error handling<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Encrypt using the public.<span></span></pre></td></tr><tr><td scope="row"><pre>    status = SecKeyEncrypt(    publicKey,<span></span></pre></td></tr><tr><td scope="row"><pre>                                kSecPaddingPKCS1,<span></span></pre></td></tr><tr><td scope="row"><pre>                                nonce,<span></span></pre></td></tr><tr><td scope="row"><pre>                                (size_t) sizeof(nonce)/sizeof(nonce[0]),<span></span></pre></td></tr><tr><td scope="row"><pre>                                cipherBuffer,<span></span></pre></td></tr><tr><td scope="row"><pre>                                &amp;cipherBufferSize<span></span></pre></td></tr><tr><td scope="row"><pre>                                );                              <span>// 8</span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>//  Error handling<span></span></pre></td></tr><tr><td scope="row"><pre>//  Store or transmit the encrypted text<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if(publicKey) CFRelease(publicKey);<span></span></pre></td></tr><tr><td scope="row"><pre>    if(queryPublicKey) [queryPublicKey release];                <span>// 9</span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>Here’s what the code does:</p><ol class="ol"><li class="li"><p>Allocates a buffer to hold the encrypted text.</p></li><li class="li"><p>Specifies the text to be encrypted.</p></li><li class="li"><p>Allocates a <code>SecKeyRef</code> object for the public key.</p></li><li class="li"><p>Creates an <code>NSData</code> object containing the unique string used to identify the public key in the keychain (see steps 1, 3, and 8 in <span class="content_text"><a href="iPhone_Tasks.html#//apple_ref/doc/uid/TP40001358-CH208-SW11">Listing 2-8</a></span>).</p></li><li class="li"><p>Allocates the dictionary to be used to find the public key in the keychain.</p></li><li class="li"><p>Specifies the key-value attribute pairs for the dictionary to be used to find the public key in the keychain. The attributes specify that the keychain item is an encryption key; that the keychain item has an attribute containing the unique string specified in step 4; that the item is an RSA key; and that a reference to the keychain item is to be returned.</p></li><li class="li"><p>Calls the <code>SecItemCopyMatching</code> function to find the key in the keychain.</p></li><li class="li"><p>Encrypts the data from step 2 using the key returned by the <code>SecItemCopyMatching</code> function in step 7 using PKCS1 padding.</p></li><li class="li"><p>Releases memory that is no longer needed.</p></li></ol><p>The following code sample shows how to decrypt data. This sample uses the private key corresponding to the public key used to encrypt the data, and assumes you already have the cipher text created in the preceding example. It gets the private key from the keychain using the same technique as used in the preceding example to get the public key. </p><a name="//apple_ref/doc/uid/TP40001358-CH208-SW12" title="Listing 2-10Decrypting with a private key"></a><p class="codesample"><strong>Listing 2-10&nbsp;&nbsp;</strong>Decrypting with a private key</p><div class="codesample"><table><tr><td scope="row"><pre>- (void)decryptWithPrivateKey<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    OSStatus status = noErr;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    size_t plainBufferSize = 256;<span></span></pre></td></tr><tr><td scope="row"><pre>    uint8_t plainBuffer[plainBufferSize];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    SecKeyRef privateKey = NULL;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    NSData * privateTag = [NSData dataWithBytes:privateKeyIdentifier<span></span></pre></td></tr><tr><td scope="row"><pre>                            length:strlen((const char *)privateKeyIdentifier)];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    NSMutableDictionary *queryPrivateKey = [[NSMutableDictionary alloc] init];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Set the private key query dictionary.<span></span></pre></td></tr><tr><td scope="row"><pre>    [queryPrivateKey setObject:(id)kSecClassKey forKey:(id)kSecClass];<span></span></pre></td></tr><tr><td scope="row"><pre>    [queryPrivateKey setObject:privateTag forKey:(id)kSecAttrApplicationTag];<span></span></pre></td></tr><tr><td scope="row"><pre>    [queryPrivateKey setObject:(id)kSecAttrKeyTypeRSA forKey:(id)kSecAttrKeyType];<span></span></pre></td></tr><tr><td scope="row"><pre>    [queryPrivateKey setObject:[NSNumber numberWithBool:YES] forKey:(id)kSecReturnRef];<span></span></pre></td></tr><tr><td scope="row"><pre>                                                                <span>// 1</span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    status = SecItemCopyMatching<span></span></pre></td></tr><tr><td scope="row"><pre>  ((CFDictionaryRef)queryPrivateKey, (CFTypeRef *)&amp;privateKey); <span>// 2</span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>//  Error handling<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    status = SecKeyDecrypt(    privateKey,<span></span></pre></td></tr><tr><td scope="row"><pre>                                kSecPaddingPKCS1,<span></span></pre></td></tr><tr><td scope="row"><pre>                                cipherBuffer,<span></span></pre></td></tr><tr><td scope="row"><pre>                                cipherBufferSize,<span></span></pre></td></tr><tr><td scope="row"><pre>                                plainBuffer,<span></span></pre></td></tr><tr><td scope="row"><pre>                                &amp;plainBufferSize<span></span></pre></td></tr><tr><td scope="row"><pre>                                );                              <span>// 3</span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>//  Error handling<span></span></pre></td></tr><tr><td scope="row"><pre>//  Store or display the decrypted text<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if(publicKey) CFRelease(publicKey);<span></span></pre></td></tr><tr><td scope="row"><pre>    if(privateKey) CFRelease(privateKey);<span></span></pre></td></tr><tr><td scope="row"><pre>    if(queryPublicKey) [queryPublicKey release];<span></span></pre></td></tr><tr><td scope="row"><pre>    if(queryPrivateKey) [queryPrivateKey release];              <span>// 4</span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>Here’s what the code does:</p><ol class="ol"><li class="li"><p>Sets up the dictionary used to find the private key in the keychain.</p></li><li class="li"><p>Finds the private key in the keychain.</p></li><li class="li"><p>Decrypts the data.</p></li><li class="li"><p>Releases memory that is no longer needed.</p></li></ol>

        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../02concepts/concepts.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../03tasks/tasks.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2003, 2008 Apple Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2008-11-19<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Security/Conceptual/CertKeyTrustProgGuide/iPhone_Tasks/iPhone_Tasks.html%3Fid%3DTP40001358-2.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Security/Conceptual/CertKeyTrustProgGuide/iPhone_Tasks/iPhone_Tasks.html%3Fid%3DTP40001358-2.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Security/Conceptual/CertKeyTrustProgGuide/iPhone_Tasks/iPhone_Tasks.html%3Fid%3DTP40001358-2.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>