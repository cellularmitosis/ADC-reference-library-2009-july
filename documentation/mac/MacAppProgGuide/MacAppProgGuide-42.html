<!-- Generated by Harlequin WebMaker 2.2.3 (30-Apr-1996)
Macintosh Common Lisp Version 3.0kp2p2 [AppGen 3.0b1kp2p2] -->
<HTML> <HEAD>
<TITLE>Dispatching Events (MacApp PG)</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING42></A>


<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->


<!-- Main Body -->

<CENTER>
<P>
<A HREF="MacAppProgGuide-41.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="MacAppProgGuide-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="MacAppProgGuide-158.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="MacAppProgGuide-43.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="MacAppProgGuide-2.html"><B>Programmer's Guide to MacApp</B></A> / <A HREF="MacAppProgGuide-21.html"><B>Part 1 - MacApp Theory and Architecture</B></A><BR><DD><A HREF="MacAppProgGuide-40.html"><B>Chapter 5 - Events and Commands</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING42-0></A>
<H1>Dispatching Events</H1>
 <A NAME=MARKER-2-50></A><A NAME=MARKER-2-51></A>A MacApp application receives numerous Toolbox events from the operating system, including mouse-up and mouse-down events, key-up and key-down events, disk events, and high-level events. The application object processes Toolbox events by calling its <CODE><A NAME=MARKER-2-52></A>HandleToolboxEvent</CODE> method, with the following results:<P>
<OL>
<LI>If any enabled behavior objects are attached to the application, each in turn gets a chance to handle the event until one of the objects handles the event.
<LI>If no behavior object handles the event, the Standard Mail Package gets a chance to handle the event (if the application object is based on the <CODE><A NAME=MARKER-2-53></A>TMailingApplication</CODE> class).
<LI>If the event still hasn't been handled, it is dispatched by the application object's <CODE><A NAME=MARKER-2-107></A>DispatchEvent</CODE> method.<P>
</OL>
 The <CODE>DispatchEvent</CODE> method calls another application method to dispatch the event. The method it calls depends on the type of event. For example, <CODE>DispatchEvent</CODE> calls <CODE>HandleMouseDown</CODE> for a mouse-down event, <CODE>HandleActivateEvent</CODE> for an activate event, and so on.<P>
 The application dispatches events by one of four mechanisms:<P>
<UL>
<LI><B>Direct dispatching.</B> The application handles the event itself or sends the event directly to the object that should handle it.
<LI><B>View hierarchy dispatching.</B> The event is passed to a view hierarchy, to be handled by a view or window in the hierarchy.
<LI><B>Target chain dispatching.</B> The event is passed to a linked chain of objects that are capable of handling events and that are likely to be interested in the current event.
<LI><B>High-level (Apple) event dispatching.</B> The application calls the <CODE>AEProcessAppleEvent</CODE> routine, which causes the Apple Event Manager to dispatch the event to an application callback routine installed by MacApp's global Apple event dispatcher object. The dispatcher object attempts to resolve the specified target object and dispatch the Apple event to it. If no object is specified by the event, it is sent to the default Apple event target object. By default, MacApp specifies the application object as the default target for Apple events.<P>
</UL>
 These mechanisms are described in the following sections.<P>
<A NAME=HEADING42-12></A>
<H2>Direct Dispatching</H2>
 <A NAME=MARKER-2-56></A>The application object handles disk insertion and operating system events directly. <P>
<UL>
<LI><B>Disk insertion event.</B> The application's <CODE><A NAME=MARKER-2-57></A>HandleDiskEvent</CODE> method checks the event to see if a disk insertion error occurred. If an error occurred, it calls the Toolbox routine <CODE>DIBadMount</CODE> to display a dialog box and let the user decide what to do.
<LI><B>Operating system event.</B> The application's <CODE><A NAME=MARKER-2-58></A>HandleSystemEvent</CODE> method handles these events:<P>
<UL>
<LI><CODE><A NAME=MARKER-2-59></A>suspendResumeMessage</CODE>: For a suspend event, <CODE>HandleSystemEvent</CODE> deactivates the active window, informs each window that the application is about to lose control, and informs the Clipboard manager, which writes the application's data to the desk scrap. For a resume event, <CODE>HandleSystemEvent</CODE> determines which window should be the front window and activates its, informs each window that the application is being activated, and informs the Clipboard manager, which checks the desk scrap for new data. 
<LI><CODE><A NAME=MARKER-2-60></A>mouseMovedMessage</CODE>: If the mouse has moved outside the cursor region, <CODE>HandleSystemEvent</CODE> invalidates the application's cursor region. If the mouse has moved outside the help region, it invalidates the help region.<P>
</UL>
</UL>
 For update and activate events, the application dispatches the event directly to the object that should handle it. <P>
<UL>
<LI><B>Update event.</B> The <CODE><A NAME=MARKER-2-61></A>HandleUpdateEvent</CODE> method finds the window object to update and calls the window's <CODE>Update</CODE> method.
<LI><B>Activate event.</B> The <CODE><A NAME=MARKER-2-62></A>HandleActivateEvent</CODE> method finds the window object to activate and calls the window's <CODE>Activate</CODE> method.<P>
</UL>
<A NAME=HEADING42-21></A>
<H2><A NAME=MARKER-2-63></A><A NAME=MARKER-9-64></A>View Hierarchy Dispatching</H2>
 The application object dispatches mouse-up and mouse-down events in a window's content area to the window's view hierarchy (described on <A HREF=MacAppProgGuide-65.html#MARKER-9-49>page 207</A>) to be handled by the window or one of its views. The event is dispatched first to the window object. If the window doesn't handle the event itself, it passes the event to its subviews. Typically the event is passed down to the most deeply nested subview that contains the mouse-up or mouse-down event and wishes to respond to it.<P>
 <A HREF=#MARKER-9-65>Figure 5-2</A> shows how MacApp handles various mouse-down and key-down events. Dispatching of mouse-down and mouse-up events is described in the following sections. Dispatching of key-down and key-up events uses the target chain dispatching mechanism, described on <A HREF=#MARKER-9-80>page 107</A>.<P>
<B>Figure 5-2  <A NAME=MARKER-9-65></A><A NAME=MARKER-2-66></A>How MacApp handles mouse-down and key-down events</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/MacApp_PG-L-003.gif"><P>
<A NAME=HEADING42-26></A>
<H3><A NAME=MARKER-2-67></A><A NAME=MARKER-9-68></A>Mouse-Down Events</H3>
 To dispatch a mouse-down event, the application object's <CODE><A NAME=MARKER-2-69></A>DispatchEvent</CODE> method calls the application's <CODE><A NAME=MARKER-2-70></A>HandleMouseDown</CODE> method. What happens next depends on the location of the mouse-down event.<P>
 For a mouse-down event in the menu bar, the application's <CODE>HandleMouseDown</CODE> method calls the Toolbox routine <CODE><A NAME=MARKER-2-71></A>MenuSelect</CODE> to get a user menu choice, then passes the result to the application's <CODE><A NAME=MARKER-2-72></A>MenuEvent</CODE> method. If the menu choice is from the Apple menu, <CODE>MenuEvent</CODE> attempts to open the chosen item or perform the specified operation. If the menu choice is from an application menu, <CODE>MenuEvent</CODE> calls the <CODE>HandleMenuCommand</CODE> method of the current target object, passing the chosen menu command number. The operation of <CODE>HandleMenuCommand</CODE> is described in <A HREF=#MARKER-9-80>"Target Chain Dispatching," beginning on page 107</A>.<P>
 For a mouse-down event in a system window, the application's <CODE>HandleMouseDown</CODE> method calls the Toolbox routine <CODE>SystemClick</CODE> to pass the event on to the system window.<P>
 For a mouse-down event in an application window, the application's <CODE>HandleMouseDown</CODE> method calls the <CODE>HandleMouseDown</CODE> method of the window where the event occurred. What happens next is determined by the location of the event.<P>
<UL>
<LI><B>Mouse-down event in the window frame.</B> If the user presses the mouse button while the cursor is in the title bar, size box, close box, or zoom box, the window's <CODE>HandleMouseDown</CODE> method calls a window method (a method of the <CODE>TWindow</CODE> class) to handle the event.
<LI><B>Mouse-down event in the window's content area.</B> If the user presses the mouse button while the cursor is in the window's content area, the window's <CODE>HandleMouseDown</CODE> method calls <CODE>Inherited::HandleMouseDown</CODE>, which results in execution of the <CODE>TView::HandleMouseDown</CODE> method.<P>
The <CODE>TView::HandleMouseDown</CODE> method contains logic to handle a complex set of possibilities: is the window active or is it in the background? does the window handle first clicks (that is, a click in the window can both select the window if it is in the background <I>and</I> begin an operation)? can the window initiate a drag operation, and if so, is the mouse-down event over draggable content? is the mouse-down event in fact the start of a drag (the user is holding the mouse button down, not just clicking)? Depending on the answers to these questions, the actions taken by <CODE>HandleMouseDown</CODE> include the following:<P>
<UL>
<LI>It always calls the <CODE>HandleMouseDown</CODE> method of its subviews, if any, giving each subview a chance to handle the mouse-down event in its <CODE>DoMouseCommand</CODE> method.
<LI>It may initiate a drag operation (for both active and background windows).
<LI>It may select the window (for a background window).
<LI>It may call the <CODE>DoMouseCommand</CODE> method of each enabled behavior attached to the view to let a behavior object handle the mouse-down event.
<LI>It may call the <CODE>DoMouseCommand</CODE> method of the view itself to handle the mouse-down event. (The default implementation of <CODE>DoMouseCommand</CODE> in <CODE>TView</CODE> does nothing.)<P>
</UL>
</UL>
 To respond to mouse-down events that are part of drawing, selecting, and similar operations, you typically override <CODE>DoMouseCommand</CODE> in a view, window, or behavior class. To respond to mouse-down events that initiate drag and drop operations, you override various view methods--see <A HREF=MacAppProgGuide-72.html#MARKER-9-29>Chapter 9, "Drag and Drop,"</A> for a full description.<A NAME=MARKER-2-73></A><A NAME=MARKER-2-74></A><P>
<A NAME=HEADING42-40></A>
<H3><A NAME=MARKER-2-75></A>Mouse-Up Events</H3>
 To dispatch a mouse-up event, the application object's <CODE>DispatchEvent</CODE> method calls the application's <CODE><A NAME=MARKER-2-76></A>HandleMouseUp</CODE> method. As with mouse-down events, what happens next depends on the location of the mouse-up event, although there are fewer options.<P>
 The <CODE>HandleMouseUp</CODE> method ignores a mouse-up event in a system window.<P>
 For a mouse-up event in an application window, the application object's <CODE>HandleMouseUp</CODE> method calls the <CODE>HandleMouseUp</CODE> method of the window where the event occurred. This results in execution of the <CODE>TView::HandleMouseUp</CODE> method.<P>
 The <CODE>TView::HandleMouseUp</CODE> method calls <CODE>HandleMouseUp</CODE> recursively for each of the window's subviews. A subview can handle the event itself in its <CODE>DoMouseUp</CODE> method, or an attached behavior can handle the event in its <CODE>DoMouseUp</CODE> method. If no subview or subview behavior handles the event, each behavior attached to the window itself gets a chance to handle the event.<P>
 If the event isn't handled by a subview, it may be handled by the window itself if you have overridden the window's <CODE>DoMouseUp</CODE> method. If no view or window handles the event, the application's <CODE>DispatchEvent</CODE> method calls <CODE>HandleAlienEvent</CODE> to handle the event as an alien event.<P>
 To respond to mouse-up events, an application typically overrides <CODE>DoMouseUp</CODE> in a view, window, or behavior class.<A NAME=MARKER-2-77></A><A NAME=MARKER-2-78></A><P>
<A NAME=HEADING42-47></A>
<H2><A NAME=MARKER-2-79></A><A NAME=MARKER-9-80></A>Target Chain Dispatching</H2>
 <A NAME=MARKER-2-81></A>There are usually a number of objects in an application that can handle a keystroke or menu event. They include the application object, as well as any document, window, or view objects that are currently active. Each of these objects is accessible through the application object--the application has a list of documents, each document has a list of windows, each window has a list of views, and each view may have a list of subviews (including control views such as buttons).<P>
 The <I>target chain</I> is a linked list of event-handler objects that can handle the current event. It typically extends from the frontmost visible object, an active view, all the way to the application. The object at the head of the chain is called the <I>current target object</I>. The current target object is pointed to by the application object's <CODE><A NAME=MARKER-2-82></A>fTarget</CODE> field, which is accessed through the <CODE><A NAME=MARKER-2-83></A>GetTarget</CODE> and <CODE><A NAME=MARKER-2-84></A>SetTarget</CODE> methods. For example, in a window that has multiple views that can handle keystrokes, the currently selected view is normally the target.<P>
 <A HREF=MacAppProgGuide-19.html#MARKER-9-62>Figure 1-5 on page 14</A> shows a typical target chain. The current target object is a view and the next object in the chain is the view's superview, followed by its window, its document, and the application object.  The next handler for the application object is usually <CODE>NULL</CODE>.<P>
 MacApp handles menu choices and keystrokes by calling a method of the current target object. The target object either handles the event or sends it to the next object in the chain. As part of the process, behavior objects attached to the target object get a chance to handle the event. The process continues until either the event is handled or the end of the target chain is reached.<P>
<A NAME=HEADING42-52></A>
<H3><A NAME=MARKER-9-85></A>Behaviors and the Target Chain</H3>
 MacApp allows behaviors to handle events by wrapping each event-processing method in its own special handling method. For example, the <CODE>HandleMenuCommand</CODE> method is a wrapper for the <CODE>DoMenuCommand</CODE> method. <BR>(The operation of <CODE><A NAME=MARKER-2-86></A>HandleMenuCommand</CODE> and <CODE>DoMenuCommand</CODE> is described in the <BR>next section.)<P>
 MacApp sends an event to the target object by calling one of these handler methods. If the target object has no enabled behavior attached to it, the handler method calls the method of the target object (for example, <CODE>DoMenuCommand</CODE>); otherwise, it calls the same method of the first enabled behavior. If the behavior has a next enabled behavior, it passes the method call on to its next behavior; otherwise it calls the same method for its owner, the target object.<P>
 In this way, any enabled behavior attached to the target object gets a chance to handle the event before the object itself. If no behavior handles the event, the target object either processes the event itself, or passes it on to the next event handler in the target chain. <A HREF=#MARKER-9-87>Figure 5-3</A> shows this process. Each event-handler object in the target chain may have one or more behavior objects attached to it.<P>
<B>Figure 5-3  <A NAME=MARKER-9-87></A>Behaviors on the target chain</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/MacApp_PG-L-001.gif"><P>
 A behavior object can point to another behavior object with its <CODE><A NAME=MARKER-2-88></A>fNextBehavior</CODE> field, making it possible to have a linked list of behaviors attached to an event-handler object. Each behavior in the list can be enabled or disabled.<P>
<DL>
<DT><B>Note</B>
<DD>MacApp's use of the <CODE>HandleMenuCommand</CODE> method and other event-handling methods is designed to allow behaviors to intervene in the event-handling process. You don't normally override these handling methods.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
 Behaviors can also handle events that are not dispatched through the target chain. For example, a mouse-down event is dispatched to the window in which it occurs or to a view within that window <A HREF=#MARKER-9-68>(page 105)</A>. If the window or view has any behavior objects attached to it, they are given the opportunity to handle the mouse-down event in their <CODE><A NAME=MARKER-2-89></A>DoMouseDown</CODE> methods.<P>
<A NAME=HEADING42-61></A>
<H3><A NAME=MARKER-2-90></A><A NAME=MARKER-9-91></A>Menu Commands</H3>
 <A NAME=MARKER-2-92></A><A NAME=MARKER-2-93></A>When a user chooses a menu command, MacApp calls the <CODE>HandleMenuCommand</CODE> method of the current target object, passing a value that identifies the chosen command. <A HREF=#MARKER-9-95>Figure 5-4</A> shows how the <CODE>HandleMenuCommand</CODE> method gives each object in the target chain a chance to handle the menu command.<P>
 The <CODE>HandleMenuCommand</CODE> method dispatches the menu command as follows:<P>
<OL>
<LI>It gives each enabled behavior object attached to the current target object a chance to handle the menu command.
<LI>If no behavior object handles the menu command, <CODE>HandleMenuCommand</CODE> calls the current target object's <CODE><A NAME=MARKER-2-276></A>DoMenuCommand</CODE> method.
<LI>In the <CODE>TEventHandler</CODE> class, the <CODE>DoMenuCommand</CODE> method calls the <CODE>HandleMenuCommand</CODE> method of the next event handler in the target chain, if there is one (see <A HREF=#MARKER-9-87>Figure 5-3</A>).
<LI>If no object in the chain handles the command, the command is ignored.<P>
</OL>
 You typically handle a menu command by overriding the <CODE>DoMenuCommand</CODE> method in an application, document, window, view, or behavior class.<P>
 Each event-handler object in the target chain may contain multiple definitions of <CODE>DoMenuCommand</CODE> in its class hierarchy. Suppose, for example, the <CODE>T<I>YourDocument</I></CODE> class is a subclass of <CODE>TFileBasedDocument</CODE> that overrides the <CODE>DoMenuCommand</CODE> method. As shown in <A HREF=#MARKER-9-103>Figure 5-5</A>, there are four versions of <CODE>DoMenuCommand</CODE> in the object's class hierarchy: one version in <CODE>TYourDocument</CODE>, one in <CODE>TDocument</CODE>, one in <CODE>TCommandHandler</CODE>, and one in <CODE>TEventHandler</CODE>.<P>
<B>Figure 5-4  <A NAME=MARKER-9-95></A>Objects in the target chain responding to a menu command</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/MacApp_PG-L-004.gif"><P>
 When MacApp calls <CODE>DoMenuCommand</CODE> on an instance of <CODE>T<I>YourDocument</I></CODE>, the <CODE>T<I>YourDocument</I></CODE> version of <CODE>DoMenuCommand</CODE> checks to see if it can handle the menu command. If it can't, it calls <CODE>Inherited::DoMenuCommand</CODE>. If no inherited <CODE>DoMenuCommand</CODE> method handles the menu command, the <CODE>DoMenuCommand</CODE> method of the <CODE>TEventHandler</CODE> class passes the menu command to the next event-handler object in the target chain, if there is one, by calling the object's <CODE>HandleMenuCommand</CODE> method.<A NAME=MARKER-2-96></A><A NAME=MARKER-9-299></A><A NAME=MARKER-2-98></A><P>
<A NAME=HEADING42-73></A>
<H3><A NAME=MARKER-9-99></A>Key-Down Events</H3>
 <A NAME=MARKER-2-100></A>To dispatch a key-down event, the application object's <CODE>DispatchEvent</CODE> method calls the application's <CODE><A NAME=MARKER-2-101></A>HandleKeyDownEvent</CODE> method.<P>
<UL>
<LI>If the Command key was pressed, <CODE>HandleKeyDownEvent</CODE> calls the <CODE><A NAME=MARKER-2-102></A>HandleCommandKey</CODE> method of the current target object. The <CODE>HandleCommandKey</CODE> method gives each behavior object and each event-handler object in the target chain the opportunity to handle the key-down event in its <CODE>DoCommandKeyEvent</CODE> method, until an object handles the event.<P>
If a Command-key event reaches the application object in the target chain, the application attempts to map the event to an equivalent menu command. For example, Command-S is mapped to the Save menu command, which has the command constant <CODE>cSave</CODE>. MacApp's numbering scheme for menu commands is described in <A HREF=MacAppProgGuide-46.html#MARKER-9-239>"MacApp's Command-Numbering System," beginning on page 131</A>.<P>
To check for a menu equivalent, the application's <CODE>DoCommandKeyEvent</CODE> method calls <CODE>MenuEvent</CODE>. The operation of <CODE>MenuEvent</CODE> is described in <A HREF=#MARKER-9-68>"Mouse-Down Events," beginning on page 105</A>.<P>
</UL>
<B>Figure 5-5  <A NAME=MARKER-9-103></A>Calling the <CODE>DoMenuCommand</CODE> method of a document object</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/MacApp_PG-L-040.gif"><P>
<UL>
<LI>If the Command key was not pressed, <CODE>HandleKeyDownEvent</CODE> calls the <CODE><A NAME=MARKER-2-104></A>HandleKeyCommand</CODE> method of the current target object. The <CODE>HandleKeyCommand</CODE> method gives each behavior object and each event-handler object in the target chain the opportunity to handle the key-down event in its <CODE>DoKeyEvent</CODE> method, until an object handles the event. If no object handles the event, it is ignored.<P>
</UL>
 To respond to key-down events, an application typically overrides the <CODE><A NAME=MARKER-2-105></A>DoCommandKeyEvent</CODE> method or the <CODE><A NAME=MARKER-2-106></A>DoKeyEvent</CODE> method in an application, document, view, window, or behavior class.<P>
 For more information on handling key-down events, see <A HREF=MacAppProgGuide-109.html#MARKER-9-19>Chapter 20, "Working With the Keyboard."</A><A NAME=MARKER-2-107></A><A NAME=MARKER-2-108></A><P>
<A NAME=HEADING42-83></A>
<H3>Receiving Key-Up Events</H3>
 <A NAME=MARKER-2-109></A>Because most applications don't need key-up events, your application will never see one unless you change MacApp's default behavior. MacApp uses the <CODE><A NAME=MARKER-2-110></A>fWantKeyUpEvents</CODE> field of the <CODE>TApplication</CODE> class to control access to key-up events. The application's <CODE>Run</CODE> method contains code to modify the system event mask based on <CODE>fWantKeyUpEvents</CODE>:<P>
<PRE>
if (fWantKeyUpEvents)
   ::SetEventMask(everyEvent); // Allows us to get key-up events too.
</PRE>
 The constructor for <CODE>TApplication</CODE> sets the <CODE>fWantKeyUpEvents</CODE> field to <CODE>FALSE</CODE>. If you want to receive key-up events, set <CODE>fWantKeyUpEvents</CODE> to <CODE>TRUE</CODE> in the constructor for your application subclass.<P>
<A NAME=HEADING42-87></A>
<H3>Dispatching Key-Up Events</H3>
 To dispatch a key-up event, the application object's <CODE>DispatchEvent</CODE> method calls the application's <CODE><A NAME=MARKER-2-111></A>HandleKeyUpEvent</CODE> method. Since applications are rarely concerned with key-up events, MacApp's mechanism for handling these events is relatively simple. The <CODE>HandleKeyUpEvent</CODE> method calls the <CODE>HandleKeyUp</CODE> method of the current target object. The <CODE>HandleKeyUp</CODE> method in <CODE>TEventHandler</CODE> gives each enabled behavior object and each event-handling object in the target chain a chance to handle the key-up event in its <CODE><A NAME=MARKER-2-112></A>DoKeyUp</CODE> method, until an object handles the event. If no object handles the event, it is ignored.<P>
 Several MacApp classes override the <CODE>DoKeyUp</CODE> method:<P>
<UL>
<LI>The <CODE>TBehavior</CODE> class overrides <CODE>DoKeyUp</CODE> to pass the event to the behavior's next enabled behavior. If the behavior doesn't have a next enabled behavior, <CODE>TBehavior::DoKeyUp</CODE> calls the <CODE>DoKeyUp</CODE> method of the behavior's owner.
<LI>The <CODE>TEventHandler</CODE> class overrides <CODE>DoKeyUp</CODE> to pass the event to the next event handler in the target chain by calling the next handler's <CODE>HandleKeyUp</CODE> method.
<LI>The <CODE><A NAME=MARKER-2-113></A>TKeySelectionBehavior</CODE> class overrides <CODE>DoKeyUp</CODE> to keep track of a time-out interval. (<CODE>TKeySelectionBehavior</CODE> tracks user typing, and can be used with a <CODE>TTextListView</CODE> object to select items in a list alphabetically by type-ahead.)
<LI>The <CODE><A NAME=MARKER-2-114></A>TMailerView</CODE> class overrides <CODE>DoKeyUp</CODE> to give the mailer a chance to handle key-up events. <CODE>DoKeyUp</CODE> passes the event to the mailer view's <CODE>DoMailerEvent</CODE> method.<A NAME=MARKER-2-115></A><P>
</UL>
<A NAME=HEADING42-94></A>
<H3>Alien Events</H3>
 <A NAME=MARKER-2-116></A>An <B>alien event</B> is one that MacApp doesn't anticipate handling. That includes network events, driver events, null events, and any other events MacApp doesn't recognize, such as events defined by your application.<P>
 The application object's <CODE>DispatchEvent</CODE> method calls the application's <CODE>HandleAlienEvent</CODE> method to handle alien events. The <CODE>HandleAlienEvent</CODE> method gives each cohandler in the application's cohandler chain a chance to handle the alien event. Cohandler chains are described in <A HREF=MacAppProgGuide-47.html#MARKER-9-255>"The Cohandler Chain," beginning on page 134</A>.<A NAME=MARKER-2-118></A><A NAME=MARKER-2-119></A><A NAME=MARKER-2-120></A><P>
<A NAME=HEADING42-97></A>
<H2><A NAME=MARKER-9-121></A>Dispatching High-Level Events</H2>
 <A NAME=MARKER-2-122></A>For high-level events (those with identifier <CODE>kHighLevelEvent</CODE>), the application object's <CODE>DispatchEvent</CODE> method calls the application's <CODE><A NAME=MARKER-2-123></A>HandleHighLevelEvent</CODE> method. The <CODE>HandleHighLevelEvent</CODE> method in turn calls the Apple Event Manager routine <CODE><A NAME=MARKER-2-124></A>AEProcessAppleEvent</CODE>. MacApp uses a global Apple event dispatcher object to handle callbacks from the Apple Event Manager and to communicate with the Object Support Library to determine the object specified by the Apple event.<P>
 Dispatching of Apple events is described in detail in <A HREF=MacAppProgGuide-48.html#MARKER-9-19>Chapter 6, "Scripting."</A><A NAME=MARKER-2-125></A><A NAME=MARKER-2-126></A><P>
</BLOCKQUOTE>
<HR>
<center>
<A HREF="MacAppProgGuide-41.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="MacAppProgGuide-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="MacAppProgGuide-158.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="MacAppProgGuide-43.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="MacAppProgGuide-3.html">&copy; Apple Computer, Inc.</A><br>25 JUL 1996</center></font><P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML>  
