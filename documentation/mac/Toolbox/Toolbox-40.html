<!-- Generated by Harlequin WebMaker 2.2.3 (23-Apr-1996)
LispWorks 3.2.2 -->
<HTML> <HEAD>
<TITLE>Handling Low-Level Events(IM:Tb)</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING40></A>


<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->


<!-- Main Body -->

<CENTER>
<P>
<A HREF="Toolbox-39.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="Toolbox-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="Toolbox-490.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="Toolbox-41.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="Toolbox-2.html"><B>Macintosh Toolbox Essentials</B></A> / <BR><DD><A HREF="Toolbox-28.html"><B>Chapter 2 - Event Manager</B></A> / <A HREF="Toolbox-36.html"><B>Using the Event Manager</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING40-0></A>
<H2><A NAME=MARKER-9-137></A>Handling Low-Level Events</H2>
 <A NAME=MARKER-2-132></A>Low-level events include hardware-related occurrences stored in the Operating System event queue and activate and update events generated by the Window Manager. When your application receives a low-level event, your application needs to determine the type of event and respond appropriately. The following sections discuss how to respond to mouse events, keyboard events (including certain specific keyboard events, such as when the user presses the Command key and period key at the same time), update events, activate events, disk-inserted events, and null events.<P>
<A NAME=HEADING40-2></A>
<H3>Responding to Mouse Events</H3>
 <A NAME=MARKER-9-263></A>Whenever the user presses or releases the mouse button, the Operating System Event Manager records the action in the Operating System event queue. These actions are stored in the event queue as mouse-down and mouse-up events. Your application can retrieve these events using the <CODE>WaitNextEvent</CODE> function. <P>
 Events related to movements of the mouse are not stored in the event queue. The mouse driver automatically tracks the mouse and displays the cursor as the user moves the mouse. Therefore, the Operating System Event Manager does not report an event if the user simply moves the mouse.<P>
 However, you can request that the Event Manager report mouse-moved events if the user moves the cursor out of a region that you specify to the <CODE>WaitNextEvent</CODE> function. For example, your application can use mouse-moved events in this way to change the shape of the cursor from an I-beam to an arrow when the user moves the cursor from a text area to the scroll bar of a window.<P>
 The rest of this section describes how your application responds to mouse-down or mouse-up events. See <A HREF=Toolbox-41.html#MARKER-9-249>"Responding to Mouse-Moved Events"</A> beginning on <A HREF=Toolbox-41.html#MARKER-9-249>page 2-62</A> <BR>for specific details on mouse-moved events.<P>
 The user expects that pressing the mouse button correlates to particular actions in an application. Your application is responsible for providing feedback or performing any actions in response to the user. For example, if the user presses the mouse button while the cursor is in the menu bar, your application should use the Menu Manager function <CODE>MenuSelect</CODE> to allow the user to choose a menu command. <P>
 Your application can receive and respond to mouse-down and mouse-up events. Most applications respond to mouse-down events and use the routines of various managers (such as <CODE>MenuSelect</CODE>, <CODE>DragWindow</CODE>, <CODE>TEClick</CODE>, <CODE>TrackBox</CODE>, <CODE>TrackGoAway</CODE>, and <CODE>TrackControl</CODE>) to handle the corresponding mouse-up events. You can also provide code to respond to mouse-up events if it's appropriate for your application. For example, if your application implements its own text-editing capabilities, you might let the user select lines of text by dragging the mouse and use mouse-up events to signal the end of the selection. <A NAME=MARKER-2-4></A><P>
 In System 7, your application receives mouse-down events only when it is the foreground process and the user clicks in the menu bar, in a window belonging to your application, or in a window belonging to a desk accessory that was launched in your application's partition. If the user clicks in a window belonging to another application, the Event Manager sends your application a suspend event and performs a major switch to the other application.<P>
 <A NAME=MARKER-2-577></A>When your application receives a mouse-down event, you need to first determine the location of the cursor at the time the mouse button was pressed (the <B>mouse location</B>) and respond appropriately. You can use the Window Manager function <CODE>FindWindow</CODE> to find which of your application's windows, if any, the mouse button was pressed in and, if applicable, to find which part of the window it was pressed in. The <CODE>FindWindow</CODE> function also reports whether the given mouse location is in the menu bar or, in some cases, in a window belonging to a desk accessory (if the desk accessory was launched in your application's partition).<P>
 The <CODE>what</CODE> field of the event record for a mouse event contains the <CODE>mouseDown</CODE> or <CODE>mouseUp</CODE> constant to report that the mouse button was pressed or released. The <CODE>message</CODE> field is undefined. The <CODE>when</CODE> field contains the number of ticks since the system last started up. You can use the <CODE>when</CODE> field to compare how much time has elapsed between successive mouse events; for example, you might use this information to help detect mouse double clicks.<P>
 The <CODE>where</CODE> field of the event record contains the location of the cursor at the time the mouse button was pressed or released. You can pass this location to the <CODE>FindWindow</CODE> function; the <CODE>FindWindow</CODE> function maps the given mouse location to particular areas <BR>of the screen.<P>
 The <CODE>modifiers</CODE> field contains information about the state of the modifier keys at the time the mouse button was pressed or released. Your application can perform different actions based on the state of the modifier keys. For example, your application might let the user extend a selection or select multiple objects at a time if the Shift key was down at the time of the mouse-down event.<A NAME=MARKER-2-101></A><P>
 <A HREF=#MARKER-9-143>Listing 2-5</A> shows code that handles mouse-down events. The <CODE>DoMouseDown</CODE> procedure is an application-defined procedure that is called from the <CODE>DoEvent</CODE> procedure. <BR>(<A HREF=Toolbox-38.html#MARKER-9-110>Listing 2-3 on page 2-26</A> shows the <CODE>DoEvent</CODE> procedure.)<P>
<B>Listing 2-5  <A NAME=MARKER-9-143></A>Handling mouse-down events<A NAME=MARKER-2-172></A></B><P>
<PRE>
PROCEDURE DoMouseDown (event: EventRecord);  
VAR 
   part:             Integer;   
   thisWindow:       WindowPtr; 
BEGIN                          
   {map location of the cursor (at the time of mouse-down event) }
   { to general areas of the screen}
   part := FindWindow(event.where, thisWindow);
   CASE part OF {take action based on the mouse location}
   inMenuBar: {mouse down in menu bar, respond appropriately}
      BEGIN             
         {first adjust marks and enabled state of menu items}
         MyAdjustMenus; 
         {let user choose a menu command}
         DoMenuCommand(MenuSelect(event.where));
      END; 
inSysWindow: {cursor in a window belonging to a desk accessory}
      SystemClick(event, thisWindow); 
inContent: {mouse down occurred in the content area of }
             { one of your application's windows}    
   IF thisWindow &lt;&gt; FrontWindow THEN 
   BEGIN {mouse down occurred in a window other than the front }
         { window---make the window clicked in the front window, }
         { unless the front window is movable modal}
      IF MyIsMovableModal(FrontWindow) THEN
         SysBeep(30)
      ELSE
         SelectWindow(thisWindow); 
   END
   ELSE  {mouse down was in the content area of front window} 
      DoContentClick(thisWindow, event);
inDrag:                 {handle mouse down in drag area}    
      IF (thisWindow &lt;&gt; FrontWindow) AND 
         (MyIsMovableModal(FrontWindow)) 
      THEN 
         SysBeep(30)
      ELSE
        DragWindow(thisWindow, event.where, GetGrayRgn^^.rgnBBox);
   inGrow:              {handle mouse down in grow region}    
      DoGrowWindow(thisWindow, event);
   inGoAway:            {handle mouse down in go-away region}
      IF TrackGoAway(thisWindow, event.where) THEN 
         DoCloseCmd;
   inZoomIn, inZoomOut: {handle mouse down in zoom box region}
      IF TrackBox(thisWindow, event.where, part) THEN 
         DoZoomWindow(thisWindow, part); 
   END; {end of CASE}
END;{of DoMouseDown} 
</PRE>
 When your application retrieves a mouse-down event, call the Window Manager function <CODE>FindWindow</CODE> to map the location of the cursor to particular areas of the screen. Given a mouse location, the <CODE>FindWindow</CODE> function returns as its function result a value that indicates whether the mouse location is in the menu bar, in one of your application's windows, or, in some cases, in a desk accessory window. If the mouse location is in an application window, the function result indicates which part of the window the mouse location is in. You can test the function result of <CODE>FindWindow</CODE> against these constants to determine the mouse location at the time of the mouse-down event:<P>
<PRE>
CONST inDesk      = 0;{none of the following}
      inMenuBar   = 1;{in the menu bar}
      inSysWindow = 2;{in a desk accessory window}
      inContent   = 3;{anywhere in content region except the }
                      { grow region if the window is active, }
                      { anywhere in content region including the }
                      { grow region if the window is inactive}
      inDrag      = 4;{in drag (title bar) region}
      inGrow      = 5;{in grow region (active window only)}
      inGoAway    = 6;{in go-away region (active window only)}
      inZoomIn    = 7;{in zoom-in region (active window only)}
      inZoomOut   = 8;{in zoom-out region (active window only)}
</PRE>
 The <CODE>FindWindow</CODE> function reports the <CODE>inDesk</CODE> constant if the mouse location is not in the menu bar, desk accessory window, or any window of your application. For example, the <CODE>FindWindow</CODE> function may report this constant if the location of the cursor is inside a window frame but not in the drag region or go-away region of the window; your application seldom receives the <CODE>inDesk</CODE> constant.<P>
 If <CODE>FindWindow</CODE> returns the <CODE>inMenuBar</CODE> constant, the mouse location is in the menu bar. In this case your application should first adjust its menus. The application-defined <CODE>MyAdjustMenus</CODE> procedure adjusts its menus--enabling and disabling items and setting marks--based on the context of the active window. For example, if the active window is a document window that contains a selection, your application should enable the Cut and Copy commands in the Edit menu, add marks to the appropriate items in the Font, Size, and Style menus, and adjust any other menu items accordingly. After adjusting your application's menus, call the Menu Manager function <CODE>MenuSelect</CODE>, passing it the location of the mouse, to allow the user to choose a menu command. The <CODE>MenuSelect</CODE> function handles all user interaction until the user releases the mouse button. The <CODE>MenuSelect</CODE> function returns as its function result a long integer indicating the menu selection made by the user. As shown in <A HREF=#MARKER-9-143>Listing 2-5</A> on <A HREF=#MARKER-9-143>page 2-34</A>, the <CODE>DoMouseDown</CODE> routine calls an application-defined routine, <CODE>DoMenuCommand</CODE>, to perform the menu command selected by the user. See the chapter "Menu Manager" in this book for a listing that gives the code for the <CODE>MyAdjustMenus</CODE> and <CODE>DoMenuCommand</CODE> routines and for more information about responding to specific menu commands.<P>
 In System 7, the <CODE>FindWindow</CODE> function seldom returns the <CODE>inSysWindow</CODE> constant. The <CODE>FindWindow</CODE> function returns this constant only when a mouse-down event occurred <BR>in a desk accessory that was launched in the application's partition. Normally, if the <BR>user clicks in a desk accessory's window, the Event Manager sends your application a suspend event and brings the desk accessory to the foreground. From that point on, mouse-down events and other events are handled by the desk accessory until the user again clicks in one of your application's windows. <A NAME=MARKER-2-138></A><P>
 If <CODE>FindWindow</CODE> does return the <CODE>inSysWindow</CODE> constant, the mouse location is in a window belonging to a desk accessory that was launched in your application's <BR>partition. In this case, your application should call the <CODE>SystemClick</CODE> procedure. The <CODE>SystemClick</CODE> procedure routes the event to the desk accessory as appropriate. If the mouse button was pressed while the cursor was in the content region of the desk accessory's window and the window is inactive, <CODE>SystemClick</CODE> makes it the active window. It does this by sending your application an activate event to deactivate its front window and directing an event to the desk accessory to activate its window. <P>
 <CODE>FindWindow</CODE> can return any of the constants <CODE>inContent</CODE>, <CODE>inDrag</CODE>, <CODE>inGrow</CODE>, <CODE>inGoAway</CODE>, <CODE>inZoomIn</CODE>, or <CODE>inZoomOut</CODE> if the given mouse location is in your application's active window. If the cursor is in the content area, your application should perform any actions appropriate to your application. Note that scroll bars are part of the content region. In most cases, if the cursor is in the content area, your application first needs to determine whether the mouse location is in the scroll bar or any other controls and then respond appropriately. The <CODE>DoMouseDown</CODE> procedure calls the application-defined procedure <CODE>DoContentClick</CODE> to handle mouse-down events in the content area of the active window. If your application needs to determine whether the mouse-down event caused a foreground switch (and you set the <CODE>getFrontClicks</CODE> flag in your application's <CODE>'SIZE'</CODE> resource), your <CODE>DoContentClick</CODE> procedure can test bit 0 in the <CODE>modifiers</CODE> field of the event record (normally your application does not test for this condition). <BR>See the chapter "Control Manager" in this book for an example <CODE>DoContentClick</CODE> procedure and for detailed information on implementing controls in your <BR>application's windows.<P>
 If the mouse location is in any of the other specified regions of an active application window, your application should perform the action corresponding to that region. <BR>For example, if the cursor is in the drag region, your application should call the <BR>Window Manager procedure <CODE>DragWindow</CODE> to allow the user to drag the window to <BR>a new location.<P>
 If the mouse location is in an inactive application window, <CODE>FindWindow</CODE> can return the <CODE>inContent</CODE> or <CODE>inDrag</CODE> constant, but does not distinguish between any other areas of the window. In this case, if <CODE>FindWindow</CODE> reports the <CODE>inContent</CODE> constant, your application should bring the inactive window to the front using the <CODE>SelectWindow</CODE> procedure (unless the active window is a movable modal dialog box). If the active window is a movable modal dialog box, then your application should use the <CODE>SysBeep</CODE> procedure to play the system alert sound rather than activating the selected window. Also, if your application interprets the first mouse click in an inactive window as a request to activate the window <I>and</I> perform an action, you can process the event again. However, note that most users expect the first click in an inactive window to activate <BR>the window without performing any additional action. If <CODE>FindWindow</CODE> reports <CODE>inDrag</CODE> for an inactive application window, your application should call the <CODE>DragWindow</CODE> procedure to allow the user to drag the window to a new location (unless the active window is a movable modal dialog box, in which case your application should simply play the system alert sound).<A NAME=MARKER-9-165></A><P>
 If you're using TextEdit to handle text editing and call <CODE>TEClick</CODE>, <CODE>TEClick</CODE> automatically interprets mouse double clicks appropriately, including allowing the user to select a word by double-clicking it. Your application must provide the means to allow double- clicking in this manner in all other contexts.<A NAME=MARKER-2-147></A><P>
 You can detect mouse double clicks by comparing the time and location of a mouse-up event with that of the immediately following mouse-down event. The <CODE>GetDblTime</CODE> function returns the recommended difference in ticks that should exist between the occurrence of a mouse-up and mouse-down event for those two mouse events to be considered a double click.<P>
 You should interpret mouse events as a double click if both of these conditions are true: <A NAME=MARKER-2-113></A><P>
<UL>
<LI>The times of the mouse-up event and mouse-down event differ by a number of ticks less than or equal to the value returned by the <CODE>GetDblTime</CODE> function.
<LI>The locations of the two mouse-down events separated by the mouse-up event are sufficiently close to each other. How you determine this value depends on your application and the context in which the mouse-down events occurred. For example, in a word-processing application, you might consider two mouse-down events a double click if the mouse locations both mapped to the same character, whereas in a graphics application you might consider it a double click if the sum of the horizontal and vertical difference between the two mouse locations is no more than five pixels.<P>
</UL>
 The Event Manager also provides other routines that give information about the mouse. You can find the current mouse location using the <CODE>GetMouse</CODE> procedure. You can determine the current state of the mouse button using the <CODE>Button</CODE>, <CODE>StillDown</CODE>, and <CODE>WaitMouseUp</CODE> functions. See <A HREF=Toolbox-71.html#MARKER-9-443>"Reading the Mouse"</A> beginning on <A HREF=Toolbox-71.html#MARKER-9-443>page 2-108</A> for detailed information on these routines. <A NAME=MARKER-2-137></A><P>
<A NAME=HEADING40-39></A>
<H3>Responding to Keyboard Events</H3>
 <A NAME=MARKER-2-393></A>Your application can receive keyboard events to notify you when the user has pressed <BR>or released a key or continued to hold down a key. When the user presses a key, the Operating System Event Manager stores a key-down event in the Operating System event queue. Your application can retrieve the event from the queue; determine which key was pressed; determine which modifier keys, if any, were pressed at the time of the event; and respond appropriately. Typically, your application provides feedback by echoing (displaying) the glyph representing the character generated by the pressed key on the screen. <A NAME=MARKER-2-221></A><A NAME=MARKER-2-119></A><P>
 When the user holds down a key for a certain amount of time, the Event Manager generates auto-key events. The Event Manager generates an auto-key event after a certain initial delay (the auto-key threshold) has elapsed since the original key-down event. The Event Manager generates subsequent auto-key events whenever a certain repeat interval (the auto-key rate) has elapsed since the last auto-key event and while <BR>the original key is still held down. The user can set the initial delay and rate of repetition using the Keyboard control panel. The default value for the auto-key threshold is <BR>16 ticks, and the default value for the auto-key rate is 4 ticks. Current values of the auto- key threshold and auto-key rate are stored in the system global variables <CODE>KeyThresh</CODE> and <CODE>KeyRepThresh</CODE>.<A NAME=MARKER-9-237></A><P>
 In addition to getting keyboard events when the user presses or releases a key, you can directly read the keyboard (and keypad) using the <CODE>GetKeys</CODE> procedure. <P>
 When the user presses a key or a combination of keys, your application should respond appropriately. Your application should follow the guidelines in <I>Macintosh Human Interface Guidelines</I> for consistent use of and response to keyboard events. For example, your application should allow the user to choose a frequently used menu command by using a keyboard equivalent for that menu command--usually a combination of the Command key and another key. Your application should also respond to the user pressing the arrow keys, Shift key, or other keys according to the guidelines provided <BR>in <I>Macintosh Human Interface Guidelines</I>.<P>
 Also note that certain keyboards have different physical layouts or contain additional keys, such as function keys. If your application supports function keys or other special keys, you should follow the guidelines in <I>Macintosh Human Interface Guidelines</I> when determining what action to take when the user presses one of these keys.<P>
 Certain keystroke combinations are handled by the Event Manager and not returned to your application. If the user holds down the Command and Shift keys while pressing a numeric key to produce a special effect, that special effect occurs. Apple provides three standard Command-Shift-number key sequences. The standard  Command-Shift- number key sequences are 1 for ejecting the disk in the internal drive, 2 for ejecting the disk in a second internal drive or for ejecting the disk in an external drive if the computer has only one internal drive, and 3 for taking a snapshot of the screen and storing it as a TeachText document on the startup volume. <A NAME=MARKER-2-37></A><P>
 The action corresponding to a Command-Shift-number key sequence is implemented <BR>as a routine that takes no parameters and is stored in an '<CODE>FKEY</CODE>' resource with a resource ID that corresponds to the number that activates it. Apple reserves '<CODE>FKEY</CODE>' resources <BR>with resource IDs 1 through 4 for its own use; if you provide an '<CODE>FKEY</CODE>' resource, use a resource ID between 5 and 9. <A NAME=MARKER-2-40></A><A NAME=MARKER-2-156></A><P>
 You can disable the Event Manager's processing of Command-Shift-number key sequences for numbers 3 through 9 by setting the system global variable <CODE>ScrDmpEnb</CODE> <BR>(a byte) to 0. However, in most cases you should not disable the Event Manager's processing of these events.<P>
 The <CODE>what</CODE> field of the event record for a keyboard-related event contains either the <CODE>keyDown</CODE> or <CODE>keyUp</CODE> constant to indicate that the key was pressed or released, or the <CODE>autokey</CODE> constant to indicate that the key is being held down. <P>
 The Event Manager sets the system event mask of your application to accept all events except key-up events. Most applications ignore key-up events. If your application needs to receive key-up events, you can change the system event mask of your application using the Operating System Event Manager procedure <CODE>SetEventMask</CODE>. <A NAME=MARKER-2-43></A><P>
 In the low-order word the <CODE>message</CODE> field contains the character code and virtual key code that corresponds to the key pressed by the user. <P>
 The <B>virtual key code</B> represents the key pressed or released by the user; this value is always the same for a specific physical key on a particular keyboard. For example, on <BR>the Apple Keyboard II, ISO layout, the virtual key code for the fifth key to the right <BR>of the Tab key (the key labeled "T" ) is always $11, regardless of which modifier keys <BR>are also pressed. <P>
 <A NAME=MARKER-2-81></A><A NAME=MARKER-2-518></A><A NAME=MARKER-2-160></A><A NAME=MARKER-9-392></A><A NAME=MARKER-2-311></A><A NAME=MARKER-2-305></A>To determine the virtual key code that corresponds to a specific physical key, system software uses a hardware-specific key-map (<CODE>'KMAP'</CODE>) resource that specifies the virtual key codes for a particular keyboard. After determining the virtual key code of the key pressed by the user, system software uses a script-specific keyboard-layout (<CODE>'KCHR'</CODE>) resource to map a virtual key code to a specific character code. Any given script system has one or more <CODE>'KCHR'</CODE> resources. For example, a particular computer might contain the French <CODE>'KCHR'</CODE> resource in addition to the standard U.S. <CODE>'KCHR'</CODE> resource. In this situation, the current <CODE>'KCHR'</CODE> resource determines whether virtual key codes are mapped to the French or U.S. character set.<A NAME=MARKER-2-164></A><A NAME=MARKER-2-131></A><A NAME=MARKER-2-166></A><P>
 The <B>character code</B> represents a particular character. The character code that is generated depends on the virtual key code, the state of the modifier keys, and the current <CODE>'KCHR'</CODE> resource. For example, the U.S. <CODE>'KCHR'</CODE> resource specifies that for the virtual key code $2D (the fifth key to the left of the Shift key and labeled "N" on an Apple Keyboard II, Domestic layout), the character code is $6E when no modifier keys are pressed; the character code is $4E when this key is pressed in combination with the Shift key. Character codes for the Roman script system are specified in the extended version of ASCII (the American Standard Code for Information Interchange). <A NAME=MARKER-2-246></A><P>
 The <CODE>message</CODE> field contains additional information for ADB keyboards. The low-order byte of the high-order word contains the ADB address of the keyboard where the keyboard event occurred. <A HREF=#MARKER-9-168>Figure 2-7</A> shows the structure of the <CODE>message</CODE> field of the event record for keyboard events.<P>
<B>Figure 2-7  <A NAME=MARKER-9-168></A>The <CODE>message</CODE> field of the event record for keyboard events</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/Figure_1-7_EV-15.jpg"><P>
 Usually your application uses the character code, rather than the virtual key code, when responding to keyboard events. You can use these two constants to access the virtual key code and character code in the <CODE>message</CODE> field:<P>
<PRE>
CONST charCodeMask      = $000000FF;{mask for character code}
      keyCodeMask       = $0000FF00;{mask for virtual key code}
</PRE>
 The <CODE>when</CODE> field contains the number of ticks since the system last started up. You can <BR>use the <CODE>when</CODE> field to compare how much time has expired between successive <BR>keyboard events.<P>
 The <CODE>where</CODE> field of the event record contains the location of the cursor at the time the key was pressed or released. You typically disregard the mouse location when processing keyboard events.<P>
 The <CODE>modifiers</CODE> field contains information about the state of the modifier keys at the time the key was pressed or released. Your application can perform different actions based on the state of the modifier keys. For example, your application might perform an action associated with a corresponding menu command if the Command key was down at the time of the key-down event. <P>
 System software can support a number of different types of keyboards, for example, the Apple Keyboard II, the Apple Extended keyboards, or other keyboards. The system software uses various keyboard resources and international resources to manage different types of keyboards. <A HREF=#MARKER-9-170>Figure 2-8</A> illustrates how system software maps keys to character codes. <A NAME=MARKER-2-20></A><P>
<B>Figure 2-8  <A NAME=MARKER-9-170></A>Keyboard translation</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/Figure_1-8_EV-08.jpg"><P>
 When a user presses or releases a key on the keyboard, the keyboard generates a raw <BR>key code. The system software uses a '<CODE>KMAP</CODE>' resource to map the raw key code to a hardware-independent virtual key code and to set bits indicating the state of the modifier keys. A  '<CODE>KMAP</CODE>' resource specifies the physical arrangement of a particular keyboard and indicates the virtual key codes that correspond to each physical key. <A NAME=MARKER-2-302></A><P>
 If the optional key-remap ('<CODE>itlk</CODE>') resource is present, the system software remaps the virtual key codes and modifier state for some key combinations on certain keyboards before using the '<CODE>KCHR</CODE>' resource. The '<CODE>itlk</CODE>' resource can reintroduce hardware dependence because certain scripts, languages, and regions need subtle differences in layout for specific keyboards. If present, the '<CODE>itlk</CODE>' resource affects only a few keys. <A NAME=MARKER-2-318></A><A NAME=MARKER-2-470></A><P>
 After mapping the virtual key code and the state of the modifier keys through an optional '<CODE>itlk</CODE>' resource, the system software uses a '<CODE>KCHR</CODE>' resource to produce the character code representing the key that was pressed or released. The '<CODE>KCHR</CODE>' resource specifies how to map the setting of the modifier keys and a virtual key code to a character code. <P>
 After mapping the key, the Event Manager returns the virtual key code and the character code in the <CODE>message</CODE> field of the event record.<P>
  <A HREF=#MARKER-9-174>Figure 2-9</A> shows the virtual key codes as specified by the <CODE>'KMAP'</CODE> resource for the Apple Keyboard II, ISO layout. The labels for the keys on the keyboard are shown using the U.S. keyboard layout. The virtual key codes are shown in hexadecimal.<P>
<B>Figure 2-9  <A NAME=MARKER-9-174></A>Virtual key codes for the Apple Keyboard II, ISO layout <A NAME=MARKER-2-475></A></B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/Figure_1-9_EV-09.jpg"><P>
 <A HREF=#MARKER-9-184>Figure 2-10</A> shows the virtual key codes as specified by the <CODE>'KMAP'</CODE> resource for the Apple Extended Keyboard II, one that uses the Domestic (ANSI) layout, and one that uses the ISO layout. The labels for the keys on the ISO keyboard are shown using the French keyboard layout. The virtual key codes are shown in hexadecimal.<P>
 If a user of an Apple Extended Keyboard II (using the U.S. <CODE>'KCHR</CODE>' resource) presses the key labeled "C" and no modifier keys, the system software maps this through the '<CODE>KMAP</CODE>' and '<CODE>KCHR</CODE>' resources to produce a virtual key code of $08 and the character code $63 (the character "c") in the <CODE>message</CODE> field of the event record. If the user presses the key labeled "C" and the Option key, then the system software maps this to virtual key code $08 and the character code $8D (the character "&ccedil;") in the <CODE>message</CODE> field.<P>
 As another example, if a user of an Apple Extended Keyboard II, Domestic layout, is using the U.S. <CODE>'KCHR</CODE>' resource and presses the key labeled "M" the system software maps this through the <CODE>'KMAP</CODE>' and <CODE>'KCHR</CODE>' resources to produce a virtual key code of $2E and the character code $6D (the character "m") in the <CODE>message</CODE> field of the event record. <A NAME=MARKER-2-3></A><P>
 If a user of an Apple Extended Keyboard II, ISO layout, is using the French <CODE>'KCHR</CODE>' resource and presses the key labeled "M" the system software maps this through the <CODE>'KMAP</CODE>' and <CODE>'KCHR</CODE>' resources to produce a virtual key code of $29 and the character <BR>code $6D (the character "m") in the <CODE>message</CODE> field of the event record. <A NAME=MARKER-2-177></A><A NAME=MARKER-2-115></A><A NAME=MARKER-2-179></A><A NAME=MARKER-2-180></A><P>
 See <I><A HREF="../Text/Text-2.html">Inside Macintosh: Text</A></I> for additional information about the keyboard resources and how the Script Manager manages various scripts.<A NAME=MARKER-21-310></A><A NAME=MARKER-2-311></A><A NAME=MARKER-21-651></A><P>
<B>Figure 2-10  <A NAME=MARKER-9-184></A>Virtual key codes for the Apple Extended Keyboard <A NAME=MARKER-2-369></A>II <A NAME=MARKER-9-233></A> <A NAME=MARKER-9-204></A></B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/Figure_1-10_EV-17.jpg"><P>
 <A HREF=#MARKER-9-188>Listing 2-6</A> shows code that handles key-down and auto-key events. The <CODE>DoKeyDown</CODE> procedure is an application-defined procedure that is called from the <CODE>DoEvent</CODE> procedure. (<A HREF=Toolbox-38.html#MARKER-9-110>Listing 2-3 on page 2-26</A> shows the <CODE>DoEvent</CODE> procedure.) <P>
<B>Listing 2-6  <A NAME=MARKER-9-188></A>Handling key-down and auto-key events<A NAME=MARKER-2-189></A></B><P>
<PRE>
PROCEDURE DoKeyDown (event: EventRecord);
VAR
   key:  Char;
BEGIN
   key := CHR(BAnd(event.message, charCodeMask));
   IF BAnd(event.modifiers, cmdKey) &lt;&gt; 0 THEN
   BEGIN                      {Command key down}
      IF event.what = keyDown THEN
      BEGIN {first enable/disable/check menu items as needed-- }
            { the MyAdjustMenus procedure adjusts the menus }
            { as appropriate for the current window}
         MyAdjustMenus;
         DoMenuCommand(MenuKey(key)); {handle the menu command}
      END;
   END
   ELSE
      MyHandleKeyDown(event);
END;
</PRE>
 The <CODE>DoKeyDown</CODE> procedure in <A HREF=#MARKER-9-188>Listing 2-6</A> first extracts the character code of the key pressed from the <CODE>message</CODE> field of the event record. It then checks the <CODE>modifiers</CODE> field of the event record to determine if the Command key was pressed at the time of the event. If so, and if the event is a key-down event, the code calls the application-defined procedure <CODE>MyAdjustMenus</CODE>, and then calls another application-defined routine, <CODE>DoMenuCommand</CODE>, to perform the menu command associated with that key. (The <CODE>MyAdjustMenus</CODE> procedure adjusts the menus appropriately, and according to whether the current window is a document window or modeless dialog box. See the chapter "Menu Manager" in this book for code that defines the <CODE>MyAdjustMenus</CODE> procedure.) Otherwise, the code calls the application-defined procedure <CODE>MyHandleKeyDown</CODE> to handle the event.<P>
 <A HREF=#MARKER-9-190>Listing 2-7</A> shows the application-defined routine <CODE>MyHandleKeyDown</CODE>.<P>
<B>Listing 2-7  <A NAME=MARKER-9-190></A>Handling key-down events<A NAME=MARKER-2-163></A></B><P>
<PRE>
PROCEDURE MyHandleKeyDown (event: EventRecord);
VAR
   key:           Char;
   window:        WindowPtr;
   myData:        MyDocRecHnd;
   te:            TEHandle;
   windowType:    Integer;
BEGIN
   window := FrontWindow;
   {determine the type of window--document, modeless, etc.}
   windowType := MyGetWindowType(window);
   IF windowType = kMyDocWindow THEN
   BEGIN
      key := CHR(BAnd(event.message, charCodeMask));
      IF window &lt;&gt; NIL THEN
      BEGIN
         IF key = char(kTab) THEN {handle special characters}
            MyDoTab(event)
         ELSE
         BEGIN
            myData := MyDocRecHnd(GetWRefCon(window));
            te := myData^^.editRec;
            IF 
            (te^^.teLength - (te^^.selEnd - te^^.selStart) + 1
               &lt; kMaxTELength) THEN
            BEGIN
               TEKey(key, te);   {insert character in document}
               MyAdjustScrollBars(window, FALSE);
               MyAdjustTE(window);
               myData^^.windowDirty := TRUE;
            END;
         END;
      END;
   END
   ELSE
      MyHandleKeyDownInModeless(event, windowType);
END;
</PRE>
 The <CODE>MyHandleKeyDown</CODE> procedure in <A HREF=#MARKER-9-190>Listing 2-7</A> handles key-down events in any window of the application. For document windows, the code inserts the character represented by the key pressed by the user into the active document. It first finds the active document using the <CODE>FrontWindow</CODE> function, then handles the event as appropriate for the document window. For example, it treats the Tab key as a special character and calls an application-defined routine, <CODE>MyDoTab</CODE>, to handle this character appropriately for the document. For all other keys directed to the document window, the code gets the edit record associated with the document, and then it simply inserts the character into the document, using the TextEdit <CODE>TEKey</CODE> procedure. It also calls two other application-defined routines, <CODE>MyAdjustScrollBars</CODE> and <CODE>MyAdjustTE</CODE>, to update the document and edit record.  <A NAME=MARKER-2-341></A><P>
 The <CODE>MyHandleKeyDown</CODE> procedure calls an application-defined routine, MyHandleKeyDownInModeless, to handle key-down events in modeless dialog boxes. See the chapter "Dialog Manager" in this book for more information on handling events in dialog boxes.<A NAME=MARKER-2-156></A><P>
<A NAME=HEADING40-88></A>
<H3>Scanning for a Cancel Event</H3>
 <A NAME=MARKER-2-184></A>Your application should allow the user to cancel a lengthy operation by using the Command-period combination. Your application can implement this cancel operation by periodically examining the state of the keyboard using the <CODE>GetKeys</CODE> procedure, or your application can scan the event queue for a keyboard event.<P>
 <A HREF=#MARKER-9-197>Listing 2-8</A> shows an application-defined function that scans the event queue for any occurrence of a Command-period event.<P>
 The <CODE>UserDidCancel</CODE> function in <A HREF=#MARKER-9-197>Listing 2-8</A> first checks to see if the user changed the script. The application maintains a global variable, <CODE>gCurrentKeyScript</CODE>, that keeps track of this information. The application also uses a global variable, <CODE>gPeriodKeyCode</CODE>, to hold the key code that maps to the period key according to the current script. If the current script has changed, the <CODE>UserDidCancel</CODE> function calls an application-defined routine, <CODE>MySetPeriodKeyCode</CODE>, to change the value of the <CODE>gPeriodKeyCode</CODE> global variable as necessary.<P>
 <A NAME=MARKER-2-498></A>The <CODE>UserDidCancel</CODE> function then determines whether A/UX is running. You must <BR>use a different method to scan the event queue if A/UX is running. This code uses <BR>an application-defined function called <CODE>MyCheckAUXEventQueue</CODE> to search for a Command-period event if A/UX is running. Otherwise, the code checks the <CODE>what</CODE> field for a key-down event. If it finds a key-down event, it then checks the <CODE>message</CODE> field <BR>to determine whether the user pressed the period key and checks the <CODE>modifiers</CODE> <BR>field to determine whether the user also pressed the Command key. If it finds the Command-period combination, it sets the <CODE>foundEvent</CODE> variable to <CODE>TRUE</CODE> and returns this value. Otherwise, it looks at the next entry in the queue and continues to search the queue until it either finds a Command-period event or reaches the end of the queue. <A NAME=MARKER-2-191></A><P>
<B>Listing 2-8  <A NAME=MARKER-9-197></A>Scanning for a Command-period event<A NAME=MARKER-2-167></A></B><P>
<PRE>
FUNCTION UserDidCancel: Boolean; 
VAR
   foundEvent:    Boolean;
   eventQPtr:     EvQElPtr;
   eventQHdr:     QHdrPtr;
   keyCode:       LongInt;
   isCmdKey:      LongInt;
BEGIN
   foundEvent := FALSE;             {assume the event is not there} 
   {Check to see if the script has changed}
   IF (gCurrentKeyScript &lt;&gt; GetEnvirons(smKeyScript)) THEN
      MySetPeriodKeyCode;           {set gPeriodKeyCode to match new script}
   IF (GetAUXVersion &gt; 0) THEN      {if A/UX is running use this method} 
      foundEvent := MyCheckAUXEventQueue(gPeriodKeyCode, cmdKey)
   ELSE
   BEGIN                                        {scan event queue}
      eventQHdr := GetEvQHdr;                   {get the event queue header} 
      eventQPtr := EvQElPtr(eventQHdr^.qHead);  {get first entry}
      WHILE (eventQPtr &lt;&gt; NIL) AND (NOT(foundEvent)) DO
      BEGIN                                     {look for key-down event}
         IF (eventQPtr^.evtQWhat = keyDown) THEN {found key-down event, }
         BEGIN                                  { look for Command-period}
            keyCode := BAND(eventQPtr^.evtQMessage, keyCodeMask);
            keyCode := BSR(keyCode, 8);
            isCmdKey := BAND(eventQPtr^.evtQModifiers, cmdKey);
            IF isCmdKey &lt;&gt; 0 THEN               {Command key was pressed}
               IF keyCode = gPeriodKeyCode THEN
                  foundEvent := TRUE;           {key pressed was '.'}
         END;     {of found key-down}
         IF (NOT foundEvent) THEN               {go to next entry}
            eventQPtr := EvQElPtr(eventQPtr^.qLink);
      END;     {of while} 
   END;     {of scan event queue} 
   UserDidCancel := foundEvent;                 {return result of search}
END;
</PRE>
<A NAME=HEADING40-95></A>
<H3>Responding to Update Events</H3>
 <A NAME=MARKER-2-128></A>The Event Manager reports update events to your application whenever one of your <BR>application's windows needs updating. Upon receiving an update event, your application should update the contents of the specified window. Your application can call the Window Manager procedure <CODE>BeginUpdate</CODE>, draw the window's contents, and then call <CODE>EndUpdate</CODE> when your application has finished updating the window's contents. <A NAME=MARKER-2-183></A><A NAME=MARKER-2-335></A><P>
 Your application can also let the Window Manager automatically update the contents of a window by supplying in the window record a handle to a picture that contains the contents of the window. This technique is generally useful only for windows that contain static information that doesn't change or can't be edited. For example, if your application provides a window that always displays a picture of the earth, you can supply the handle to the picture, and the Window Manager automatically updates the window as needed, without sending your application an update event. In most cases, your application needs to perform the update itself.<P>
 The Window Manager maintains an update region for each window. The Window Manager keeps track of all areas in a window's content region that need to be redrawn and accumulates them in the window's update region. When an application calls <CODE>WaitNextEvent</CODE> or <CODE>EventAvail</CODE> (or <CODE>GetNextEvent</CODE>), the Event Manager checks to see if any windows have an update region that is not empty. If so, the Event Manager reports update events to the appropriate applications; any applications with windows that require updating receive the necessary update events according to the normal processing of events.<P>
 If more than one window needs updating, the Event Manager issues update events for the frontmost window first. This means that updating of windows occurs in front-to-back order, which is what the user expects.<P>
 When one of your application's windows needs to be updated, the Window Manager calls the window definition function of that window, requesting that it draw the window frame. The Window Manager then generates an update event for that window. The Event Manager reports any update events for your application's windows to your application, and your application should update the window contents as necessary. <P>
 In response to an update event, your application should first call the <CODE>BeginUpdate</CODE> procedure. The <CODE>BeginUpdate</CODE> procedure temporarily replaces the visible region of the window's graphics port (that part of the window that is visible on the screen) with the intersection of the visible region and update region of the window. The <CODE>BeginUpdate</CODE> procedure then clears the update region of the window--preventing the update event for this occurrence from being reported again.<P>
 After calling <CODE>BeginUpdate</CODE>, your application should draw the window's contents, either entirely or in part. You can draw either the entire content region or only the area in the visible region. In either case, the Window Manager allows only what falls within the visible region to be drawn on the screen. (Because the <CODE>BeginUpdate</CODE> procedure intersects the visible region with the update region, the visible region at this point corresponds to any visible parts of the old update region.)<P>
 The <CODE>EndUpdate</CODE> procedure restores the normal visible region of the window's <BR>graphics port.<P>
 <A HREF=#MARKER-9-202>Figure 2-11</A> shows how an application updates its windows. In this example, Window 1 partially covers Window 2. When the user moves Window 1 so that more of Window 2 is exposed, the Window Manager requests the window definition function of the window to update the window frame, and accumulates the area requiring updating in the update region of the window.<P>
 When the application receives an update event for this window, the <CODE>message</CODE> field of the event record contains a pointer to the window that needs updating. Your application can call <CODE>BeginUpdate</CODE>, draw the window's contents, and then call <CODE>EndUpdate</CODE>. This completes the handling of the update event.<P>
 Your application can receive update events when it is in the foreground or in the background. In the example shown in <A HREF=#MARKER-9-202>Figure 2-11</A>, Window 1 and Window 2 could belong to the same application or different applications. In either case, the Event Manager reports an update event to the application whose window contents <BR>need updating.<P>
<B>Figure 2-11  <A NAME=MARKER-9-202></A>Responding to an update event for a window</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/Figure_1-11_EV-10.jpg"><P>
 Your application should respond to update events or at least call the <CODE>BeginUpdate</CODE> procedure in response to an update event. If you do not call the <CODE>BeginUpdate</CODE> procedure, your application continues to receive update events for the window (until <BR>the update region is empty). You should always make sure that you match a call to <CODE>BeginUpdate</CODE> with a call to <CODE>EndUpdate</CODE>. By calling the <CODE>BeginUpdate</CODE> and <CODE>EndUpdate</CODE> procedures, you indicate to the Window Manager that you have updated the window and handled the update event.<A NAME=MARKER-9-459></A><P>
 <A HREF=#MARKER-9-204>Listing 2-9</A> shows an example of an application-defined routine that responds to <BR>update events.<P>
<B>Listing 2-9  <A NAME=MARKER-9-204></A>Responding to update events<A NAME=MARKER-2-175></A></B><P>
<PRE>
PROCEDURE DoUpdate (window: WindowPtr);
VAR
   windowType: Integer;
BEGIN
   {determine the type of window--document, modeless, etc.}
   windowType := MyGetWindowType(window);
   CASE windowType OF
      kMyDocWindow:
         BEGIN
            BeginUpdate(window); 
            MyDrawWindow(window);
            EndUpdate(window);
         END;
      OTHERWISE
         DoUpdateMyDialog(window);
   END; {of CASE}
END;
</PRE>
 The <CODE>DoUpdate</CODE> procedure in <A HREF=#MARKER-9-204>Listing 2-9</A> first determines if the window is a document window or a modeless dialog box. The MyGetWindowType function is an application-defined routine that returns the kMyDocWindow constant if the window is a document window and returns other application-defined constants if the window is a modeless dialog box.<P>
 If the window is a document window, the procedure does all its drawing of the window within calls to the <CODE>BeginUpdate</CODE> and <CODE>EndUpdate</CODE> procedures. The application-defined routine <CODE>MyDrawWindow</CODE> performs the actual updating of the document window contents. See the chapter "Window Manager" in this book for code that shows the <CODE>MyGetWindowType</CODE> and <CODE>MyDrawWindow</CODE> routines. <A NAME=MARKER-2-258></A><A NAME=MARKER-2-326></A><P>
 If the window is a modeless dialog box, the code calls the application-defined DoUpdateMyDialog procedure to update the contents of the dialog box. See the chapter "Dialog Manager" in this book for details on handling update events in dialog boxes.<P>
<A NAME=HEADING40-116></A>
<H3>Responding to Activate Events</H3>
 <A NAME=MARKER-2-198></A><A NAME=MARKER-2-209></A>When several windows belonging to your application are open, you should allow the user to switch from one window to another by clicking in the appropriate window. To implement this, whenever your application receives a mouse-down event, you should first determine whether the user clicked in another window by using the Window Manager function <CODE>FindWindow</CODE>; if so, you can use the Window Manager procedure <CODE>SelectWindow</CODE> to generate the necessary activate events.<A NAME=MARKER-2-536></A><A NAME=MARKER-2-211></A><P>
 Before returning to your application and before your application receives any events relating to this occurrence, the <CODE>SelectWindow</CODE> procedure does some work for you, such as removing the highlighting from the window to be deactivated and highlighting the newly activated window. At your application's next request for an event, the Event Manager returns an activate event.<P>
 An activate event indicates the window involved and whether the window is being activated or deactivated. Your application should perform any other actions needed to complete the action of the window becoming active or inactive. For example, when a window becomes active, your application should show any scroll bars and restore selections as necessary.<P>
 Your application typically receives an activate event (with a flag that indicates the window should be deactivated) for the window being deactivated, followed by an activate event for the window becoming active.<P>
 Activate events are not placed into the Operating System event queue but are sent directly to the Event Manager.<P>
 <A HREF=#MARKER-9-213>Figure 2-12</A> on the next page shows two documents belonging to the same application, with Window 1 the active window. When the user clicks in Window 2, your application receives a mouse-down event and can use the <CODE>FindWindow</CODE> function to determine whether the mouse location is in an inactive window. If so, your application should call the <CODE>SelectWindow</CODE> procedure. The <CODE>SelectWindow</CODE> procedure removes highlighting <BR>of Window 1, highlights Window 2, and generates activate events for both of these occurrences. The Event Manager reports the activate events one at a time to your application; in this example, the first activate event indicates that Window 1 should be deactivated. Your application should hide the scroll bars and remove the highlighting from any selections as necessary. <P>
 The next activate event indicates that Window 2 should be activated. Your application should show the scroll bars and restore any selections as necessary. If the window needs updating as a result of being activated, the Event Manager sends your application an update event so that your application can update the window contents.<P>
 Your application also needs to activate or deactivate windows in response to suspend and resume events. If you set the <CODE>acceptSuspendResumeEvents</CODE> flag and the <CODE>doesActivateOnFGSwitch</CODE> flag in your application's  <CODE>'SIZE'</CODE> resource, your application is responsible for activating or deactivating your application's <BR>windows in response to handling suspend and resume events.  If you set the <CODE>acceptSuspendResumeEvents</CODE> flag and do not set the <CODE>doesActivateOnFGSwitch</CODE> flag, your application receives an activate event immediately following a suspend or resume event. In most cases, you should set both the <CODE>acceptSuspendResumeEvents</CODE> and <CODE>doesActivateOnFGSwitch</CODE> flags in your application's <CODE>'SIZE'</CODE> resource.<A NAME=MARKER-2-412></A><P>
<B>Figure 2-12  <A NAME=MARKER-9-213></A>Responding to activate events for a window</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/Figure_1-12_EV-11.jpg"><P>
 The <CODE>what</CODE> field of an event record for an activate event contains the <CODE>activateEvt</CODE> constant. The <CODE>message</CODE> field contains a pointer to the window being activated or deactivated. The <CODE>modifiers</CODE> field contains additional information about the activate event, along with information about the state of the modifier keys at the time the event was posted. Your application can examine bit 0 of the <CODE>modifiers</CODE> field of the event record to determine if the window should be activated or deactivated. Bit 0 of the <CODE>modifiers</CODE> field is 1 if the window should be activated and 0 if the window should be deactivated. You can use the <CODE>activeFlag</CODE> constant to test the state of this bit in the <CODE>modifiers</CODE> field.<P>
 The <CODE>when</CODE> field of the event record contains the number of ticks since the system last started up. The <CODE>where</CODE> field of the event record contains the location of the cursor at the time the activate event occurred. <P>
 Upon receiving an activate event that indicates the window is being deactivated, your application should hide any scroll bars and remove the highlighting from any selections as necessary.<P>
 Upon receiving an activate event that indicates the window is becoming active, your application should show any scroll bars, highlight any selections, and otherwise restore the window to the state it was in when it was last active. For example, your application should restore the insertion point to its previous position, and the document should be scrolled to the position in which the user last left it. Your application should also adjust its menus appropriately for the newly active window--adjusting the marks and enabled state of menu items based on the state of the active window.<P>
 <A HREF=#MARKER-9-214>Listing 2-10</A> shows an application-defined procedure that responds to activate events.<P>
<B>Listing 2-10  <A NAME=MARKER-9-214></A>Responding to activate events<A NAME=MARKER-2-186></A></B><P>
<PRE>
PROCEDURE DoActivate (window: windowPtr; activate: Boolean; 
                      event: EventRecord);
VAR
   growRect:   Rect;          {window's grow rectangle}
   myData:     MyDocRecHnd;   {window's document record}
   windowType: Integer;
BEGIN
   {determine the type of window--document, modeless, etc.}
   windowType := MyGetWindowType(window);
   CASE windowType OF
   kMyDocWindow:
   BEGIN
      myData := MyDocRecHnd(GetWRefCon(window));
      HLock(Handle(myData));
      WITH myData^^ DO
      IF activate THEN     {window is being activated}
      BEGIN
         {restore any selections or display caret}
         MyRestoreSelection(window);
         {adjust menus as appropriate for this document window}
         MyAdjustMenus; 
         {activate any scroll bars}
         vScrollBar^^.contrlVis := kControlVisible;
         hScrollBar^^.contrlVis := kControlVisible;
         {invalidate area of scroll bars to force update}
         InvalRect(vScrollBar^^.contrlRect);
         InvalRect(hScrollBar^^.contrlRect);
         {invalidate area of size box, if any}
         growRect := window^.portRect;
         WITH growRect DO 
         BEGIN
            top := bottom - kScrollbarAdjust;
            left := right - kScrollbarAdjust;
         END; {end of WITH growRect statement}
         InvalRect(growRect);
      END
      ELSE                 {window is being deactivated}
      BEGIN
         {unhighlight selection (if any) or hide the caret}
         MyHideSelection;
         HideControl(vScrollBar);   {hide any scroll bars}
         HideControl(hScrollBar);
         DrawGrowIcon(window);      {change size box immediately}
      END;
      HUnLock(Handle(myData));
   END; {end of kMyDocWindow}
   
   kMyGlobalChangesID:  {this window is a modeless dialog box }
                        { for this app's Global Changes command}
      MyDoActivateGlobalChangesDialog(window, event);
   {handle other modeless dialog boxes as appropriate}
   END; {of CASE}
END;
</PRE>
 <A HREF=#MARKER-9-214>Listing 2-10</A> uses the application-defined function <CODE>MyGetWindowType</CODE> to determine what type of window is involved with the activate event. If the window is a document window, the <CODE>DoActivate</CODE> procedure uses the <CODE>GetWRefCon</CODE> function to get a handle <BR>to the window's document record. (The <CODE>DoActivate</CODE> procedure, and other application- defined routines, maintain information about the document associated with a window <BR>in a document record; the application stores a handle to the document record as the window's reference constant value when it creates a new window. See the chapter "Window Manager" in this book for information on defining a document record.)<P>
 If the document window should be activated, the code calls an application-defined routine, <CODE>MyRestoreSelection</CODE>. Your application should restore any selection or display the caret as appropriate. For example, if your application uses TextEdit to display text in the content area of windows, you can call the TextEdit procedure <CODE>TEActivate</CODE> to restore any selection or display a caret at the insertion point. The <CODE>DoActivate</CODE> procedure then calls another application-defined procedure, <CODE>MyAdjustMenus</CODE>, to adjust the menus as appropriate for the document window. (See <BR>the chapter "Menu Manager" for a listing of the <CODE>MyAdjustMenus</CODE> procedure.) After restoring any selections and adjusting its menus, the code shows the scroll bars and size box of the window being activated. It does this by invalidating the area of the scroll bars and size box, accumulating these areas into the update region. This causes an update event to be generated. The application redraws its controls as appropriate in response to update events.<P>
 If the document window should be deactivated, the code in <A HREF=#MARKER-9-214>Listing 2-10</A> unhighlights <BR>the selection and hides the caret by calling the application-defined procedure MyHideSelection. The code then hides the scroll bars and size box of the <BR>deactivated window. <A NAME=MARKER-2-198></A><P>
 If the window associated with the activate event is a modeless dialog box, for example, a Global Changes modeless dialog box, the <CODE>DoActivate</CODE> procedure calls an application-defined procedure to activate or deactivate the dialog box as needed. See the "Dialog Manager" chapter in this book for information on handling activate events in modeless dialog boxes.<A NAME=MARKER-2-320></A><P>
<A NAME=HEADING40-139></A>
<H3><A NAME=MARKER-9-218></A>Responding to Disk-Inserted Events</H3>
 <A NAME=MARKER-2-219></A><A NAME=MARKER-2-158></A>When your application uses the Standard File Package to allow the user to choose a file to open or choose a location for storing a file, the Standard File Package responds to disk-inserted events for your application while interacting with the user. In most cases, if your application receives an unexpected disk-inserted event, it can simply check to see if the disk was successfully mounted and use the Disk Initialization Manager function <CODE>DIBadMount</CODE> to notify the user if the disk was not successfully mounted.<P>
 When the user inserts a disk, the Operating System attempts to mount the volume on the disk by calling the File Manager function <CODE>PBMountVol</CODE>. If the volume is successfully mounted, an icon representing the disk appears on the desktop. The Operating System Event Manager then generates a disk-inserted event. If the user is interacting with a standard file dialog box, the Standard File Package intercepts the disk-inserted event and handles it. Otherwise, the event is left in the event queue for your application to retrieve. The Desk Manager also intercepts and handles disk-inserted events if a desk accessory is in front. <A NAME=MARKER-2-203></A><A NAME=MARKER-2-324></A><P>
 Usually your application should handle and not mask out disk-inserted events. The user might insert a disk at any time and expects to be warned if the disk is uninitialized or damaged. If your application receives a disk-inserted event and the volume was successfully mounted, your application usually does not need to take any further action. However, if the volume was not successfully mounted, then your application should give the user a chance to initialize or eject the uninitialized or damaged disk.<P>
 If you do mask out disk-inserted events, the event stays in the Operating System event queue until your application calls the Standard File Package or until an application that does handle disk-inserted events becomes the foreground process. This situation can be confusing to the user, so your application should handle disk-inserted events at the time that they occur.<P>
 If the volume was successfully mounted and your application either does not use the Standard File Package or prompts the user to insert a disk, then you can choose to respond to disk-inserted events in whatever way is appropriate for your application.<P>
 The Dialog Manager procedure <CODE>ModalDialog</CODE> masks out disk-inserted events. (The Standard File Package changes the mask in order to receive disk-inserted events.) If one of your application's modal dialog boxes needs to respond to disk-inserted events, then you can change the event mask from within the event filter function that you supply as one of the parameters to <CODE>ModalDialog</CODE>. Otherwise, your application can respond to the disk-inserted event after the user dismisses the modal dialog box. <A NAME=MARKER-2-208></A><P>
 The <CODE>what</CODE> field of the event record contains the <CODE>diskEvt</CODE> constant to indicate a disk-inserted event. The <CODE>message</CODE> field contains the drive number in the low-order word and the result code from the <CODE>PBMountVol</CODE> function in the high-order word. Your application can examine the high-order word to determine if the attempt to mount the volume was successful. If the volume was not successfully mounted, your application can notify the user using the Disk Initialization Manager function <CODE>DIBadMount</CODE>. If the volume was successfully mounted, your application can use the drive number returned in the low-order word for accessing the disk.<P>
 <A NAME=MARKER-2-44></A><A HREF=#MARKER-9-227>Listing 2-11</A> shows a procedure that handles disk-inserted events. If the disk was not successfully mounted, the procedure notifies the user using the <CODE>DIBadMount</CODE> function. Otherwise, it does not take any action. See the chapter "Disk Initialization Manager" <BR>in <I><A HREF="../Files/Files-2.html">Inside Macintosh: Files</A></I> for information on the routines provided by the Disk Initialization Manager. <A NAME=MARKER-2-122></A><A NAME=MARKER-2-226></A><P>
<B>Listing 2-11  <A NAME=MARKER-9-227></A>Responding to disk-inserted events<A NAME=MARKER-2-319></A></B><P>
<PRE>
PROCEDURE DoDiskEvent (event: EventRecord);
VAR
   thisPoint:  Point;
   myErr:      OSErr;
BEGIN 
   IF HiWord(event.message) &lt;&gt; noErr THEN
   BEGIN                      {attempt to mount was unsuccessful}
      DILoad;                 {load Disk Initialization Manager}
      SetPt(thisPoint, 120, 120);
                              {notify the user}
      myErr := DIBadMount(thisPoint, event.message);
      DIUnload;               {unload Disk Initialization Manager}
   END
   ELSE                       {attempt to mount was successful}
      ;        {record the drive number or do other processing}
END; 
</PRE>
<A NAME=HEADING40-150></A>
<H3>Responding to Null Events</H3>
 <A NAME=MARKER-2-66></A>When the Event Manager has no other events to report, it returns a null event. The <CODE>WaitNextEvent</CODE> function reports a null event by returning a function result of <CODE>FALSE</CODE> and setting the <CODE>what</CODE> field of the returned event record to <CODE>nullEvt</CODE>. (The <CODE>EventAvail</CODE> and <CODE>GetNextEvent</CODE> functions also return null events in this manner.)<P>
 When your application receives a null event, it can perform idle processing. Your application should do minimum processing in response to a null event, so that other processes can use the CPU and so that the foreground process (or your application, if <BR>it is in the foreground) can respond promptly to the user.<P>
 For example, if your application receives a null event and it is in the foreground, it can make the caret blink in the active window.<P>
 If your application receives a null event in the background, it can perform tasks or do other processing while in the background. However, your application should not perform any tasks that would slow down the responsiveness of the foreground process. Your application also should not interact with the user if it is in the background.<P>
 If you don't want your application to receive null events when it is in the background, set the <CODE>cannotBackground</CODE> flag in your application's <CODE>'SIZE'</CODE> resource.<A NAME=MARKER-2-422></A><P>
 <A HREF=#MARKER-9-232>Listing 2-12</A> shows a procedure that performs idle processing in response to a null event. If the application is not in the background and the active window is a document window, this code calls the TextEdit procedure <CODE>TEIdle</CODE>. The <CODE>TEIdle</CODE> procedure makes a blinking caret appear at the insertion point in the text referred to by the edit record. (This application uses TextEdit to display text in its document windows; if you don't use TextEdit for your document windows, provide your own routine to blink the caret.) If the active window is a modeless dialog box, the <CODE>DoIdle</CODE> procedure calls the Dialog Manager function <CODE>DialogSelect</CODE> to blink the caret in any editable text item of the dialog box.<A NAME=MARKER-2-190></A> <P>
<B>Listing 2-12  <A NAME=MARKER-9-232></A>Handling null events<A NAME=MARKER-2-203></A></B><P>
<PRE>
PROCEDURE DoIdle (event: EventRecord);
VAR
   window:     WindowPtr;
   myData:     MyDocRecHnd;
   windowType: Integer;
   itemHit:    Integer;
   result:     Boolean;


BEGIN
   window := FrontWindow;
   {determine the type of window--document, modeless, etc.}
   windowType := MyGetWindowType(window);
   CASE windowType OF
      kMyDocWindow:
         IF (NOT gInBackground) THEN
         BEGIN
            myData := MyDocRecHnd(GetWRefCon(window));
            TEIdle(myData^^.editRec);
         END;
      kMyGlobalChangesID:
         result := DialogSelect(event, window, itemHit);
   END; {of CASE}
END;
</PRE>
</BLOCKQUOTE>
<HR>
<center>
<A HREF="Toolbox-39.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="Toolbox-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="Toolbox-490.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="Toolbox-41.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="Toolbox-3.html">&copy; Apple Computer, Inc.</A><br>11 JUL 1996</center></font><P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML>  
