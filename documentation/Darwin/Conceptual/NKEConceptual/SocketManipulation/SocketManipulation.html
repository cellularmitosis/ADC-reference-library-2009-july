<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>Network Kernel Extensions Programming Guide: Memory Buffers, Socket Manipulation, and Socket Input/Output</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Memory Buffers, Socket Manipulation, and Socket Input/Output"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP40001858-CH235" title="Memory Buffers, Socket Manipulation, and Socket Input/Output"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../index.html#//apple_ref/doc/uid/TP30000440-TP30000422" target="_top">Darwin</a> &gt; <a href="../../../Kernel-date.html#//apple_ref/doc/uid/TP30000440-TP30000422-TP30000532" target="_top">Kernel</a> &gt; <a href="../intro/intro.html#//apple_ref/doc/uid/TP40001858-CH225-DontLinkElementID_68">Network Kernel Extensions Programming Guide</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../about/about.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../control/control.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        
        <a name="//apple_ref/doc/uid/TP40001858-CH235-DontLinkElementID_28" title="Memory Buffers, Socket Manipulation, and Socket Input/Output"></a><h1>Memory Buffers, Socket Manipulation, and Socket Input/Output</h1><p>Most of the networking KPIs enable you to write extensions that change the behavior of the networking stack. The mbuf KPI routines are central to these KPIs, providing functions to manipulate individual network packets within the kernel. You may also sometimes find it useful to perform socket communication in the kernel, for example, to contact a remote server in a network filesystem client such as AFS. The socket KPI routines were designed to help you work with sockets at the kernel level, using mbufs as the fundamental unit of data.</p><p>The mbuf KPIs may be unfamiliar territory for you if you are used to user-space network programming. Conceptually, they are just linked lists of objects that can either contain packet data or pointers to external buffers that contain packet data. For incoming traffic, the packet header is also encapsulated in the mbuf structure.</p>
<!-- This template is being used for both PDF and HTML. -->

    
    <h4>In this section:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="SocketManipulation.html#//apple_ref/doc/uid/TP40001858-CH235-SW4">Working with Memory Buffers</a>
				
			<br/>
			
        
			
			
				<a href="SocketManipulation.html#//apple_ref/doc/uid/TP40001858-CH235-DontLinkElementID_4">Working with Sockets in the Kernel</a>
				
			<br/>
			
        
			
			
				<a href="SocketManipulation.html#//apple_ref/doc/uid/TP40001858-CH235-DontLinkElementID_5">For More Information</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/TP40001858-CH235-SW4" title="Working with Memory Buffers"></a><h2>Working with Memory Buffers</h2><p>All of the networking KPIs are built on top of a shared data structure called a memory buffer, or mbuf. An mbuf is the fundamental unit of data flow through the networking stack and represents a packet (or portion thereof). This section describes the way mbufs and mbuf chains are organized and describes a number of common operations on mbufs. For a complete list of mbuf operations, see <code><a href="../../../Reference/KPI_Reference/kpi_mbuf/index.html#//apple_ref/doc/header/kpi_mbuf.h" target="_top">kpi_mbuf.h</a></code>.</p><a name="//apple_ref/doc/uid/TP40001858-CH235-DontLinkElementID_1" title="Structure of an mbuf"></a><h3>Structure of an mbuf</h3><p>A memory buffer, or mbuf, represents the contents of a single data packet. Its structure consists of a packet header (which may be absent for newly-generated outgoing traffic) and a payload (which contains the actual data).</p><br/><div><a name="//apple_ref/doc/uid/TP40001858-CH235-DontLinkElementID_29" title="Figure 2-1A chain of mbuf chains"></a><p><strong>Figure 2-1&nbsp;&nbsp;</strong>A chain of mbuf chains</p><img src = "../art/packets.jpg" alt = "A chain of mbuf chains" ></div><br/><p>For smaller payloads, the data may be encapsulated in the mbuf structure itself as an offset from the start of the structure. For a larger payload (beyond the length of the mbuf itself), the payload can be stored separately by associating the mbuf with an external buffer, called a cluster. You can learn whether an mbuf has a cluster by calling <code><a href="../../../Reference/KPI_Reference/kpi_mbuf/CompositePage.html#//apple_ref/c/func/mbuf_flags" target="_top">mbuf_flags</a></code> and checking to see if the <code><a href="../../../Reference/KPI_Reference/kpi_mbuf/CompositePage.html#//apple_ref/c/econst/MBUF_EXT" target="_top">MBUF_EXT</a></code> bit is set.</p><p>An mbuf can be part of a singly-linked list, called an mbuf chain. This allows you to chain data together that does not exist in a physically contiguous buffer without copying the data. You can find the next node in an mbuf chain by calling <code><a href="../../../Reference/KPI_Reference/kpi_mbuf/CompositePage.html#//apple_ref/c/func/mbuf_next" target="_top">mbuf_next</a></code>. (You cannot obtain the previous node because an mbuf chain is a singly-linked list.)</p><p>When moving more data than will fit in a single packet, these mbufs and mbuf chains can, in turn, be combined to form a larger singly-linked list that represents a stream of packets. You can find the next packet by calling <code><a href="../../../Reference/KPI_Reference/kpi_mbuf/CompositePage.html#//apple_ref/c/func/mbuf_nextpkt" target="_top">mbuf_nextpkt</a></code>.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40001858-CH235-DontLinkElementID_30" title="Note"></a><p><strong>Note:</strong>&nbsp;Not all parts of the networking stack support chains of packets. If you are sending data to an unfamiliar part of the stack, you should err on the side of caution and send packets individually as a single mbuf chain rather than as a chain of mbuf chains.</p></div><p>The packet represented by an mbuf or mbuf chain may be a fragment of a larger packet.</p><a name="//apple_ref/doc/uid/TP40001858-CH235-DontLinkElementID_2" title="Manipulating an mbuf or mbuf Chain"></a><h3>Manipulating an mbuf or mbuf Chain</h3><p>Using routines in <code><a href="../../../Reference/KPI_Reference/kpi_mbuf/index.html#//apple_ref/doc/header/kpi_mbuf.h" target="_top">kpi_mbuf.h</a></code>, you can manipulate an mbuf or mbuf chain in a number of ways, including copying data to or from an mbuf or mbuf chain, adding new mbufs to a chain, freeing an mbuf or mbuf chain, shifting data between mbufs in a chain to make a byte range contiguous (if space is available), and so on. This section explains some of the more common mbuf operations.</p><p>The most common operation you will need to perform is copying data into and out of an mbuf. To copy data from an mbuf or mbuf chain into a local buffer of your choosing, use <code><a href="../../../Reference/KPI_Reference/kpi_mbuf/CompositePage.html#//apple_ref/c/func/mbuf_copydata" target="_top">mbuf_copydata</a></code>. Be careful not to overflow the buffer. To copy data back into the mbuf or mbuf chain, use <code><a href="../../../Reference/KPI_Reference/kpi_mbuf/CompositePage.html#//apple_ref/c/func/mbuf_copyback" target="_top">mbuf_copyback</a></code>. If needed, the <code>mbuf_copyback</code> function will extend the chain to accommodate more data. For an example of how to use <code>mbuf_copydata</code>, see <span class="content_text"><a href="SocketManipulation.html#//apple_ref/doc/uid/TP40001858-CH235-SW3">Listing 2-1</a></span>.</p><p>If you are modifying an existing mbuf in a kernel extension, you should also familiarize yourself with the checksum functions. If your modifications involve changes to packet header information (protocol field, address information, and so on), you must swallow the packet entirely and reinject it.</p><p>For payload changes, before modifying the data, your extension should first call <code><a href="../../../Reference/KPI_Reference/kpi_mbuf/CompositePage.html#//apple_ref/c/func/mbuf_inbound_modified" target="_top">mbuf_inbound_modified</a></code>, which disables hardware checksums for a packet, and then call <code><a href="../../../Reference/KPI_Reference/kpi_mbuf/CompositePage.html#//apple_ref/c/func/mbuf_outbound_finalize" target="_top">mbuf_outbound_finalize</a></code>, which performs any outstanding operations on the packet so that it is safe for you to modify it. After modifying data, it should call <code><a href="../../../Reference/KPI_Reference/kpi_mbuf/CompositePage.html#//apple_ref/c/func/mbuf_outbound_finalize" target="_top">mbuf_outbound_finalize</a></code> again to recompute any checksums invalidated by those data changes.</p><p>If you are writing code that must avoid processing an mbuf more than once, the approach you should use depends on the type of filter you are writing. The networking stack will automatically track which IP filters have processed an mbuf. Thus, an IP filter should not see an mbuf more than once. If a socket filter reinjects a packet, however, the system will call all of the socket filters again to process the newly-altered packet.</p><p>To guarantee that you will not accidentally process an mbuf more than once, you can use mbuf tagging to attach data to the mbuf as it travels through the system. If you see the mbuf a second time, you can detect that tag and skip that mbuf. This feature is described more fully in <span class="content_text"><a href="../socket_nke/socket_nke.html#//apple_ref/doc/uid/TP40001858-CH228-SW2">“Creating a Socket Filter.”</a></span></p><p>Finally, Mac OS X maintains a fair amount of statistical information about these networking-related data structures, including the number of mbufs, the number of clusters, the number of payload bytes available in an mbuf (without using a cluster), and so on. You can obtain this information by calling <code><a href="../../../Reference/KPI_Reference/kpi_mbuf/CompositePage.html#//apple_ref/c/func/mbuf_stats" target="_top">mbuf_stats</a></code> and examining the information that it returns.</p><a name="//apple_ref/doc/uid/TP40001858-CH235-DontLinkElementID_3" title="Blocking and Nonblocking mbuf Operations"></a><h3>Blocking and Nonblocking mbuf Operations</h3><p>Many mbuf operations—particularly operations that allocate new buffers—take additional flags of type <code><a href="../../../Reference/KPI_Reference/kpi_mbuf/CompositePage.html#//apple_ref/c/tag/mbuf_how_t" target="_top">mbuf_how_t</a></code> to request blocking or nonblocking behavior. If you call them in blocking mode, the operations will block until the requested storage is available. If you call them in nonblocking mode, they will immediately return either the requested storage (if available) or an error code indicating why the operation could not be completed. Here are some tips for choosing whether to request blocking or nonblocking behavior:</p><ul class="spaceabove"><li class="li"><p>If your code is called from a part of the kernel where blocking is prohibited, you <em>must</em> use nonblocking buffer allocation. For example, you must use nonblocking allocation in any function that could be called from the VM system paging path, from an interrupt filter routine, or while holding a spinlock.</p></li><li class="li"><p>If your code is executing on a performance-critical path, use nonblocking operations:</p><ul class="nested"><li class="nested li"><p>For callback functions marked as “fast path” in the KPI reference documentation.</p></li><li class="nested li"><p>When a higher-level layer can retry the operation without data loss. This will generally result in better performance by allowing other work to occur while you wait.</p></li></ul></li><li class="li"><p>If your code is called in a context where failure is not allowed, you should always use blocking operations.</p></li><li class="li"><p>If none of the above applies, you can choose whichever mode is most compatible with your usage model. When in doubt, choose nonblocking operation.</p></li></ul><a name="//apple_ref/doc/uid/TP40001858-CH235-DontLinkElementID_4" title="Working with Sockets in the Kernel"></a><h2>Working with Sockets in the Kernel</h2><p>The socket KPIs are very similar to user-space socket functions except that they are prefixed with <code>sock_</code>. For example, the KPI function <code><a href="../../../Reference/KPI_Reference/kpi_socket/CompositePage.html#//apple_ref/c/func/sock_accept" target="_top">sock_accept</a></code> is nearly identical to the function <code><a href="../../../Reference/ManPages/man2/accept.2.html#//apple_ref/doc/man/2/accept" target="_top">accept(2)</a></code>. Unlike its user-space equivalent, however, <code><!--a-->sock_accept<!--/a--></code> does not return a socket (file descriptor) through its return value. Instead, it returns a <code><!--a target="_top" -->socket_t<!--/a--></code> opaque object through a pointer argument and returns an error code (<code>errno_t</code>) through its return value. As a result, the KPI functions are more consistent, and your code can perform better error checking and reporting.</p><p>Beyond these differences in coding style, kernel-space socket programming requires a great deal more care because of a few subtle differences from their user-space equivalents. These differences, described in the sections that follow, are in two major areas: socket I/O and manipulation of the sockets and file descriptors themselves.</p><p>There are also minor differences in the flags that are supported by various functions, as well as other subtle variations in behavior and syntax. These are documented in the API reference for the relevant functions. See <em><a href="../../../Reference/KPI_Reference/index.html#//apple_ref/doc/uid/TP40001274" target="_top">KPI Reference</a></em> for more information.</p><a name="//apple_ref/doc/uid/TP40001858-CH235-SW2" title="Manipulating Sockets and File Descriptors"></a><h3>Manipulating Sockets and File Descriptors</h3><p>In both user-space code and kernel-space code, a socket is an opaque reference to an underlying object. However, the nature of that reference differs somewhat. In kernel-space code, a socket is represented as an opaque type of type <code><!--a target="_top" -->socket_t<!--/a--></code>. In user-space code, a socket is represented instead as an integer file descriptor. When user-space code performs any operation on that socket, the kernel looks up that integer in a per-process table, then performs the operation on the underlying kernel-space socket. This relationship between in-kernel sockets and user-space file descriptors affects the way you use sockets in the kernel.</p><ul class="spaceabove"><li class="li"><p><strong>In the kernel, you must maintain the relationship between sockets and user-space file descriptors if it exists.</strong> Because you cannot manually tie a socket to a file descriptor in a process, you cannot perform certain operations on user-space sockets from inside the kernel. In particular, if you are manipulating sockets passed in from user-space applications (within a network kernel extension, for example), you cannot safely call <code><a href="../../../Reference/KPI_Reference/kpi_socket/CompositePage.html#//apple_ref/c/func/sock_close" target="_top">sock_close</a></code> on these sockets. If you do call <code>sock_close</code>, it leaves a dangling file descriptor, which will probably cause a kernel panic.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40001858-CH235-DontLinkElementID_31" title="Note"></a><p><strong>Note:</strong>&nbsp;If you were considering calling <code>sock_close</code> to redirect a socket to a different location, you can do this by intercepting the connection request with a socket filter and redirecting the stream when the application first opens the socket. Once opened, however, a stream cannot be redirected. For more information, see <span class="content_text"><a href="../socket_nke/socket_nke.html#//apple_ref/doc/uid/TP40001858-CH228-SW1">“Socket filters.”</a></span></p></div></li><li class="li"><p><strong>Kernel-space sockets are not bounded by descriptor limits.</strong> Because kernel sockets are not tied to file descriptors, the number of open sockets inside the kernel is not bounded by limitations on the number of per-process file descriptors.</p></li><li class="li"><p><strong>You must close kernel-space sockets to avoid leaks.</strong> Because kernel-space sockets are not tied to a process (and thus are not destroyed when the process exits), the burden of maintaining those sockets falls squarely on the shoulders of the developer of the kernel extension that allocates them.</p><p>If you create a socket with <code><a href="../../../Reference/KPI_Reference/kpi_socket/CompositePage.html#//apple_ref/c/func/sock_socket" target="_top">sock_socket</a></code> and do not call <code><a href="../../../Reference/KPI_Reference/kpi_socket/CompositePage.html#//apple_ref/c/func/sock_close" target="_top">sock_close</a></code> on that socket, it will live on <em>until the next reboot</em>, stealing precious resources from other kernel extensions and running applications. You <em>must</em> clean up after yourself. The kernel cannot do it for you. This means:</p><ul class="nested"><li class="nested li"><p>If you create a socket with <code><a href="../../../Reference/KPI_Reference/kpi_socket/CompositePage.html#//apple_ref/c/func/sock_socket" target="_top">sock_socket</a></code>, you must close it with <code><a href="../../../Reference/KPI_Reference/kpi_socket/CompositePage.html#//apple_ref/c/func/sock_close" target="_top">sock_close</a></code>.</p></li><li class="nested li"><p>If you allocate an mbuf, you must either free it explicitly or pass it to a send function that frees it implicitly.</p></li></ul></li></ul><a name="//apple_ref/doc/uid/TP40001858-CH235-SW1" title="Socket Input and Output"></a><h3>Socket Input and Output</h3><p>Socket I/O in the kernel differs from user-space socket I/O in two main ways:</p><ul class="spaceabove"><li class="li"><p>In the kernel, the <code><a href="../../../Reference/ManPages/man2/read.2.html#//apple_ref/doc/man/2/read" target="_top">read(2)</a></code> and <code><a href="../../../Reference/ManPages/man2/write.2.html#//apple_ref/doc/man/2/write" target="_top">write(2)</a></code> system calls are not available. Instead, you must copy data between the <code><!--a target="_top" -->mbuf_t<!--/a--></code> object and a local buffer using <code><a href="../../../Reference/KPI_Reference/kpi_mbuf/CompositePage.html#//apple_ref/c/func/mbuf_copydata" target="_top">mbuf_copydata</a></code> and <code><a href="../../../Reference/KPI_Reference/kpi_mbuf/CompositePage.html#//apple_ref/c/func/mbuf_copyback" target="_top">mbuf_copyback</a></code>.</p></li><li class="li"><p>In the kernel, asynchronous socket reads are handled differently. The kernel does not provide the equivalent of <code><a href="../../../Reference/ManPages/man2/select.2.html#//apple_ref/doc/man/2/select" target="_top">select(2)</a></code> for writing wait loops. Instead, it provides a callback mechanism that calls a function in your extension whenever data becomes available on a socket.</p></li></ul><p>If your code is in a performance-critical part of the kernel (as opposed to a call from user space), you should generally perform socket I/O asynchronously. In the kernel, this asynchronous I/O is based on a callback mechanism, using callbacks of the type <code><a href="../../../Reference/KPI_Reference/kpi_socket/CompositePage.html#//apple_ref/c/tdef/sock_upcall" target="_top">sock_upcall</a></code>. <span class="content_text">Listing 2-1</span> shows how to open a socket asynchronously and perform an asynchronous read on the socket using <code><a href="../../../Reference/KPI_Reference/kpi_socket/CompositePage.html#//apple_ref/c/func/sock_receivembuf" target="_top">sock_receivembuf</a></code>.</p><a name="//apple_ref/doc/uid/TP40001858-CH235-SW3" title="Listing 2-1Reading from a kernel-space socket asynchronously"></a><p class="codesample"><strong>Listing 2-1&nbsp;&nbsp;</strong>Reading from a kernel-space socket asynchronously</p><div class="codesample"><table><tr><td scope="row"><pre>#include &lt;kern/debug.h><span></span></pre></td></tr><tr><td scope="row"><pre>#include &lt;sys/errno.h><span></span></pre></td></tr><tr><td scope="row"><pre>#include &lt;sys/kpi_mbuf.h><span></span></pre></td></tr><tr><td scope="row"><pre>#include &lt;sys/kpi_socket.h><span></span></pre></td></tr><tr><td scope="row"><pre>#include &lt;net/kpi_protocol.h><span></span></pre></td></tr><tr><td scope="row"><pre>#include &lt;net/ethernet.h><span></span></pre></td></tr><tr><td scope="row"><pre>#include &lt;sys/param.h><span></span></pre></td></tr><tr><td scope="row"><pre>#include &lt;sys/filio.h><span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>#define ULTIMATE_ANSWER 0x00000042<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/* Forward declarations */<span></span></pre></td></tr><tr><td scope="row"><pre>errno_t set_nonblocking(socket_t so, int value);<span></span></pre></td></tr><tr><td scope="row"><pre>static void my_sock_callback(socket_t so, void* cookie, int waitf);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/* This function opens a connection and sets it up to wait<span></span></pre></td></tr><tr><td scope="row"><pre>   for data.  When data is received, the network stack will<span></span></pre></td></tr><tr><td scope="row"><pre>   call the callback function my_sock_callback(). */<span></span></pre></td></tr><tr><td scope="row"><pre>errno_t open_socket_and_start_listener(void)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    socket_t so;<span></span></pre></td></tr><tr><td scope="row"><pre>    errno_t err;<span></span></pre></td></tr><tr><td scope="row"><pre>    int protocol = 0; // usually the right choice<span></span></pre></td></tr><tr><td scope="row"><pre>    struct sockaddr to;<span></span></pre></td></tr><tr><td scope="row"><pre>    uint32_t cookie = ULTIMATE_ANSWER; // Normally, we would<span></span></pre></td></tr><tr><td scope="row"><pre>                                       // point to a private<span></span></pre></td></tr><tr><td scope="row"><pre>                                       // data structure here.<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if ((err = sock_socket(PF_INET, SOCK_STREAM, protocol,<span></span></pre></td></tr><tr><td scope="row"><pre>        (sock_upcall)&amp;my_sock_callback, (void *)cookie, &amp;so))) {<span></span></pre></td></tr><tr><td scope="row"><pre>            return err;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    /* Set the socket to non-blocking mode */<span></span></pre></td></tr><tr><td scope="row"><pre>    set_nonblocking(so, 1);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    /* ... Fill in sockaddr value here ... */<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    err = sock_connect(so, &amp;to, MSG_DONTWAIT);<span></span></pre></td></tr><tr><td scope="row"><pre>    if (err == EINPROGRESS) return 0; // it worked.<span></span></pre></td></tr><tr><td scope="row"><pre>    return err;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/* This function is called when data is available on the socket.<span></span></pre></td></tr><tr><td scope="row"><pre>   It reads data from the socket. */<span></span></pre></td></tr><tr><td scope="row"><pre>static void my_sock_callback(socket_t so, void* cookie, int waitf)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    errno_t err;<span></span></pre></td></tr><tr><td scope="row"><pre>    size_t len = sizeof(value);<span></span></pre></td></tr><tr><td scope="row"><pre>    mbuf_t data;<span></span></pre></td></tr><tr><td scope="row"><pre>    int value;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    /* The socket should have some data available now. */<span></span></pre></td></tr><tr><td scope="row"><pre>    if (cookie == (void *)ULTIMATE_ANSWER) {<span></span></pre></td></tr><tr><td scope="row"><pre>        // This socket's cookie matches the desired magic value,<span></span></pre></td></tr><tr><td scope="row"><pre>        // so read data from the socket here.<span></span></pre></td></tr><tr><td scope="row"><pre>        err = sock_receivembuf(so, NULL, &amp;data, MSG_WAITALL, &amp;len);<span></span></pre></td></tr><tr><td scope="row"><pre>        if (err == EWOULDBLOCK) {<span></span></pre></td></tr><tr><td scope="row"><pre>            // The kernel hasn't seen enough data yet.<span></span></pre></td></tr><tr><td scope="row"><pre>            return;<span></span></pre></td></tr><tr><td scope="row"><pre>        } else if (err || len &lt; sizeof(value)) {<span></span></pre></td></tr><tr><td scope="row"><pre>            /* This example does no error recovery.  Your code should. */<span></span></pre></td></tr><tr><td scope="row"><pre>            panic("Something is very wrong.  Maybe the other end closed the connection....\n");<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Copy the data from the mbuf chain into local storage.<span></span></pre></td></tr><tr><td scope="row"><pre>    err = mbuf_copydata(data, 0, sizeof(value), &amp;value); // Copy 4 bytes at start<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Call a function with the value received.<span></span></pre></td></tr><tr><td scope="row"><pre>    dont_panic(htonl(value));<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // We no longer need this socket, so close it.<span></span></pre></td></tr><tr><td scope="row"><pre>    sock_close(so);<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/* This is a short example of how to use the sock_ioctl()<span></span></pre></td></tr><tr><td scope="row"><pre>   function on a socket within the kernel.  This is the<span></span></pre></td></tr><tr><td scope="row"><pre>   KPI equivalent of the ioctl() system call. */<span></span></pre></td></tr><tr><td scope="row"><pre>errno_t set_nonblocking(socket_t so, int value)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    errno_t err;<span></span></pre></td></tr><tr><td scope="row"><pre>    int val = value; // taking the address of parameters is bad<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if (value != 0 &amp;&amp; value != 1) return EINVAL;<span></span></pre></td></tr><tr><td scope="row"><pre>    err = sock_ioctl(so, FIONBIO, &amp;val);<span></span></pre></td></tr><tr><td scope="row"><pre>    return err;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p><span class="content_text">Listing 2-1</span> also shows the use of the mbuf routine <code><a href="../../../Reference/KPI_Reference/kpi_mbuf/CompositePage.html#//apple_ref/c/func/mbuf_copydata" target="_top">mbuf_copydata</a></code>. This routine copies data from an mbuf chain to a buffer. When using this function, you <em>must</em> make sure you do not overflow the destination buffer.</p><p>Handling incoming connections works similarly. If you want to block until a connection is pending, you can use <code><a href="../../../Reference/KPI_Reference/kpi_socket/CompositePage.html#//apple_ref/c/func/sock_accept" target="_top">sock_accept</a></code> in blocking mode to wait for an incoming connection. If you would prefer to handle incoming connections asynchronously, you can pass in a callback of type <code><a href="../../../Reference/KPI_Reference/kpi_socket/CompositePage.html#//apple_ref/c/tdef/sock_upcall" target="_top">sock_upcall</a></code> when you create the socket with <code><a href="../../../Reference/KPI_Reference/kpi_socket/CompositePage.html#//apple_ref/c/func/sock_socket" target="_top">sock_socket</a></code>. That callback will be called whenever a client connects to your listen socket. From your callback handler, you should then call <code>sock_accept</code> (optionally with the <code>MSG_DONTWAIT</code> flag).</p><p>Writing data to a socket is similar to reading data synchronously. The steps for writing data to a socket are as follows:</p><ol class="ol"><li class="li"><p>If you do not already have an mbuf, call <code><a href="../../../Reference/KPI_Reference/kpi_mbuf/CompositePage.html#//apple_ref/c/func/mbuf_allocpacket" target="_top">mbuf_allocpacket</a></code> to create an mbuf with a cluster to hold external data. This need not be as large as your data; the next step will expand the chain as needed.</p></li><li class="li"><p>Call <code><a href="../../../Reference/KPI_Reference/kpi_mbuf/CompositePage.html#//apple_ref/c/func/mbuf_copyback" target="_top">mbuf_copyback</a></code> to copy data from a local buffer into the mbuf. To copy data from additional buffers, simply repeat this step for each subsequent buffer, specifying the offset from the start of the mbuf where the contents of the buffer should be stored.</p></li><li class="li"><p>Call <code><a href="../../../Reference/KPI_Reference/kpi_socket/CompositePage.html#//apple_ref/c/func/sock_sendmbuf" target="_top">sock_sendmbuf</a></code> to send the data.</p></li></ol><a name="//apple_ref/doc/uid/TP40001858-CH235-DontLinkElementID_5" title="For More Information"></a><h2>For More Information</h2><p>For information about user-space socket programming in general, you should read the <span class="content_text"><a href="http://www.developerweb.net/forum/forumdisplay.php?f=70&amp;daysprune=-1&amp;order=asc&amp;sort=title" target="_blank">UNIX Socket FAQ</a></span>. This bulletin board provides the answers to a lot of basic, intermediate, and advanced user-space socket programming questions, and includes numerous examples. You can also find details about user-space socket functions in <em><a href="../../../Reference/ManPages/index.html#//apple_ref/doc/uid/TP40000894" target="_top">Mac OS X Man Pages</a></em>.</p><p>To learn more about the KPI networking functions, read <em><a href="../../../Reference/KPI_Reference/index.html#//apple_ref/doc/uid/TP40001274" target="_top">KPI Reference</a></em>—in particular, the kernel mbuf data structures and associated functions, described in <code><a href="../../../Reference/KPI_Reference/kpi_mbuf/index.html#//apple_ref/doc/header/kpi_mbuf.h" target="_top">kpi_mbuf.h</a></code>, and socket APIs, described in <code><a href="../../../Reference/KPI_Reference/kpi_socket/index.html#//apple_ref/doc/header/kpi_socket.h" target="_top">kpi_socket.h</a></code>.</p>

        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../about/about.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../control/control.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2003, 2009 Apple Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2009-03-02<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Darwin/Conceptual/NKEConceptual/SocketManipulation/SocketManipulation.html%3Fid%3DTP40001858-2.3&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Darwin/Conceptual/NKEConceptual/SocketManipulation/SocketManipulation.html%3Fid%3DTP40001858-2.3&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Darwin/Conceptual/NKEConceptual/SocketManipulation/SocketManipulation.html%3Fid%3DTP40001858-2.3&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>