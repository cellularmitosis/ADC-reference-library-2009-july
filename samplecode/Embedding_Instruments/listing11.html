<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>Embedding Instruments - /BigEasy/BigEasyPPC.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../samplecode/LegacyTechnologies/idxQuickTime-date.html">QuickTime</a> &gt; <A HREF="javascript:location.replace('index.html');">Embedding Instruments</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/QuickTime/index.html" target="_blank">Reference Library > QuickTime</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">Embedding Instruments</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/BigEasy/BigEasyPPC.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/BigEasy/BigEasy2.c</option>
<option value="listing2.html">/BigEasy/BigEasy2.h</option>
<option value="listing3.html">/BigEasy/BigEasyControls.c</option>
<option value="listing4.html">/BigEasy/BigEasyControls.h</option>
<option value="listing5.html">/BigEasy/BigEasyDialogs.c</option>
<option value="listing6.html">/BigEasy/BigEasyDialogs.h</option>
<option value="listing7.html">/BigEasy/BigEasyGestalt.c</option>
<option value="listing8.html">/BigEasy/BigEasyGestalt.h</option>
<option value="listing9.html">/BigEasy/BigEasyGrafish.c</option>
<option value="listing10.html">/BigEasy/BigEasyGrafish.h</option>
<option value="listing11.html">/BigEasy/BigEasyPPC.c</option>
<option value="listing12.html">/BigEasy/BigEasyPPC.h</option>
<option value="listing13.html">/BigEasy/BigEasyStandardControls.c</option>
<option value="listing14.html">/BigEasy/BigEasyStandardControls.h</option>
<option value="listing15.html">/BigEasy/BigEasyTextish.c</option>
<option value="listing16.html">/BigEasy/BigEasyTextish.h</option>
<option value="listing17.html">/BigEasy/BigEasyUtils.c</option>
<option value="listing18.html">/BigEasy/BigEasyUtils.h</option>
<option value="listing19.html">/BigEasy/IconUtilsPriv.h</option>
<option value="listing20.html">/BigEasy/NWindows.c</option>
<option value="listing21.html">/BigEasy/OneWindow.c</option>
<option value="listing22.html">/FlatInstrumentTest.c</option>
<option value="listing23.html">/FlatInstrumentTest.h</option>
<option value="listing24.html">/MusicHelper.c</option>
<option value="listing25.html">/MusicHelper.h</option>
<option value="listing26.html">/TuneGeneration2.0.c</option></select>
				</p>
				</form>
				<p><strong><a href="Embedding_Instruments.zip">Download Sample</a></strong> (&#147;Embedding_Instruments.zip&#148;, 84.3K)<BR>
<strong><a href="Embedding_Instruments.dmg">Download Sample</a></strong> (&#147;Embedding_Instruments.dmg&#148;, 147.7K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/*  File:    BigEasyPPC.c  Contains:  xxx put contents here xxx  Written by:  xxx put writers here xxx  Copyright:  &copy; 1992 by Apple Computer, Inc., all rights reserved.  Change History (most recent first):     &lt;2&gt;    1/7/93  dvb    Compile under mpw.     &lt;1&gt;   1/20/92  dvb    first checked in*//* file: BigEasyPPC.c * * Started Mid 1991, more or less. * * A set of routines to quickly * access some simple uses of PPC. * *//*--------------------------  Protocol Notes--------------------------*//*Port creator type is always 'BigE', and the type is specified bythe application.When the BrowseAndConnect is used, the PPCBrowser checks port creator andtype to match the connecting port (and only shows those that match), andalso attempts to connect to the port with a userdata of 'test'. The serverport rejects the connection attempt if the userdata is 'test', andreturns 'test' as the Reject-reason.*//*--------------------------  Inclusions--------------------------*/#include &quot;BigEasyPPC.h&quot;#include &lt;Errors.h&gt;#include &lt;Events.h&gt;/*--------------------------  Constants--------------------------*/#define kEasyPPCPortCreator 'BigE'enum/* * For the filterproc to work, there must * be an inform pending. The filterproc tests * this by actually connecting to the proposed * target, with userdata 'test'. The target sees this, * and ignores the connection, and posts another 'Inform' * just to make sure. */  {  testConnection = 'test',  realConnection = 'real'  };/*--------------------------  Globals--------------------------*/Boolean gEverBrowsed = 0;      /* to remember where we are in the browser */LocationNameRec gTheLocation;PortInfoRec gThePortInfo;static EasyPPCSession gEasyFilterSession;    /* communicate with Filter Proc *//*--------------------------  Prototypes--------------------------*/static short BumpStringNumber(StringPtr s);static void HandleSomeErrors(EasyPPCSession es,EasyPPCPollResult *pollResult);static void InitializeClient(EasyPPCSession es,EasyPPCClient *clientPtr);static EasyPPCClient *FindClient(EasyPPCSession es,long sessRefNum);static void RemoveClientEntry(EasyPPCSession es,EasyPPCClient *clientPtr);static void PollEasyPPCClient(EasyPPCSession es,EasyPPCClient *clientPtr,    EasyPPCPollResult *pollResult);static EasyPPCClient *FindFreeClient(EasyPPCSession es);static pascal void InformCompletion(PPCParamBlockPtr pb);static pascal Boolean EasyBrowserFilter (LocationNamePtr location, PortInfoPtr port);#define MoveString(src,dst) BlockMove(src,dst,src[0]+1)/*--------------------------  Agedashi Dofu--------------------------*/short BumpStringNumber(StringPtr s)/* * Starting from string &quot;string&quot; make strings &quot;string 00&quot; through * &quot;string 99&quot;. Return false when that isn't possible. */  {  unsigned char *c;  c = s + s[0];    /* c points to very last character */  if(*c &lt; '0' || *c &gt; '9' || *(c-1) &lt; '0' || *(c-1) &gt; '9')  /* need to append 00? */    {    s[0] += 3;    *++c = ' ';    *++c = '0';    *++c = '0';    }  else    {    *c += 1;    if(*c &gt; '9')      {      *c-- = '0';      *c += 1;      if(*c &gt; '9')        return 0;      }    }  return 1;  }EasyPPCSession NewEasyPPCSession(StringPtr name,OSType type)  {  EasyPPCSession es;  PPCOpenPBRec opbr;  PPCPortRec portName;  OSErr thisError;  short i;  es = (void *)NewPtr(sizeof(EasyPPCSessionRecord));  portName.nameScript = 0;  MoveString(name,portName.name);  portName.portKindSelector = ppcByCreatorAndType;  portName.u.port.creator = kEasyPPCPortCreator;  portName.u.port.type = type;  opbr.ioCompletion = 0;  opbr.serviceType = ppcServiceRealTime;  opbr.resFlag = 0;  opbr.portName = &amp;portName;  opbr.locationName = 0;  opbr.networkVisible = 1;tryOpen:  thisError = PPCOpenSync(&amp;opbr);  if(thisError == portNameExistsErr)    if(BumpStringNumber(portName.name))      goto tryOpen;  if(thisError)    goto fail;  es-&gt;portRefNum = opbr.portRefNum;  es-&gt;type = type;  es-&gt;serverType = type;  thisError = GetDefaultUser(0,es-&gt;userName);  es-&gt;waitingToWrite = 0;  for(i = 0; i &lt; kEasyPPCWritePacketCount; i++)    es-&gt;wpbr[i].used = 0;  es-&gt;connected = 0;  for(i = 0; i &lt; kEasyPPCClientCount; i++)    es-&gt;client[i].used = 0;  goto goHome;fail:  DisposePtr((Ptr)es);  es = 0;goHome:  return es;  }void DisposeEasyPPCSession(EasyPPCSession es)  {  EasyPPCWritePB *ewpb;  PPCClosePBRec cpbr;  short i;  if(es)    {    cpbr.ioCompletion = 0;    cpbr.portRefNum = es-&gt;portRefNum;      PPCCloseSync(&amp;cpbr);    for(i = 0; i &lt; kEasyPPCWritePacketCount; i++)      {      ewpb = &amp;es-&gt;wpbr[i];      if(ewpb-&gt;used &amp;&amp; ewpb-&gt;buffer)        DisposePtr(ewpb-&gt;buffer);      /* easymanage */      }    }  }OSErr ConnectEasyPPCSession(EasyPPCSession es,    LocationNameRec *locationName,PortInfoRec *pir,long *sessRefNum)  {  PPCStartPBRec spbr;  OSErr thisError;  EasyPPCClient *clientPtr;  if(!es || es-&gt;connected &gt;= kEasyPPCClientCount)      /* already enough connected */    {    thisError = -1;    goto goHome;    }  spbr.ioCompletion = 0;  spbr.portRefNum = es-&gt;portRefNum;  spbr.serviceType = ppcServiceRealTime;  spbr.resFlag = 0;  spbr.portName = &amp;pir-&gt;name;  spbr.locationName = locationName;  spbr.userData = 0;  spbr.userRefNum = 0;  thisError = PPCStartSync(&amp;spbr);  if(thisError == guestNotAllowedErr)    {    Boolean asGuest;    thisError = StartSecureSession(&amp;spbr,        (StringPtr)0x910,        true,        /* use default? */        false,        /* don't allow guest, it didn't work */        &amp;asGuest,        &quot;\p&quot;);    }  if(!thisError)    {    clientPtr = FindFreeClient(es);    InitializeClient(es,clientPtr);    clientPtr-&gt;userName[0] = 0;    clientPtr-&gt;locationName = *locationName;    clientPtr-&gt;portName = pir-&gt;name;    clientPtr-&gt;sessRefNum = spbr.sessRefNum;    }goHome:  if(sessRefNum)    *sessRefNum = spbr.sessRefNum;  return thisError;  }/* ---------------------------------------------------------- */OSErr DisconnectEasyPPCSession(EasyPPCSession es,long sessRefNum)  {  PPCEndPBRec epbr;  OSErr thisError;  EasyPPCClient *clientPtr;  if(!es)    return -1;  clientPtr = FindClient(es,sessRefNum);  if(!clientPtr)    return -1;  epbr.ioCompletion = 0;  epbr.sessRefNum = clientPtr-&gt;sessRefNum;  thisError = PPCEndSync(&amp;epbr);  RemoveClientEntry(es,clientPtr);  HUnlock((void *)es-&gt;client);  return thisError;  }/* ---------------------------------------------------------- */OSErr LetConnectEasyPPCSession(EasyPPCSession es)  {  OSErr thisError;  EasyPPCClient *clientPtr;  /*   * Enough connected?   */  if(!es || es-&gt;connected &gt;= kEasyPPCClientCount)    {    thisError = -1;    goto goHome;    }  clientPtr = FindFreeClient(es);  InitializeClient(es,clientPtr);  clientPtr-&gt;sessRefNum = 0;  clientPtr-&gt;waitingToConnect = 1;  clientPtr-&gt;ipbr.ioCompletion = (ProcPtr)InformCompletion;  clientPtr-&gt;ipbr.portRefNum = es-&gt;portRefNum;  clientPtr-&gt;ipbr.autoAccept = 0;  clientPtr-&gt;ipbr.portName = &amp;clientPtr-&gt;portName;  clientPtr-&gt;ipbr.locationName = &amp;clientPtr-&gt;locationName;  clientPtr-&gt;ipbr.userName = clientPtr-&gt;userName;  thisError = PPCInformAsync(&amp;clientPtr-&gt;ipbr);goHome:  return thisError;  }pascal void InformCompletion(PPCParamBlockPtr pb)/* * Here, we only accept the connection if * it's not a 'test' connection. * If it _is_ a test, we return 'test' as the * Reject-reason. */  {  PPCInformPBRec *ipbr;  PPCAcceptPBRec apbr;  PPCRejectPBRec rpbr;  ipbr = (PPCInformPBRec *)pb;  if(ipbr-&gt;ioResult)      /* problem? maybe the port's being closed? */    return;          /* just quit it. */  if(ipbr-&gt;userData != testConnection)    {    apbr.ioCompletion = 0;    apbr.sessRefNum = ipbr-&gt;sessRefNum;    PPCAcceptSync(&amp;apbr);    }  else    {    rpbr.ioCompletion = 0;    rpbr.sessRefNum = ipbr-&gt;sessRefNum;    rpbr.rejectInfo = testConnection;    PPCRejectSync(&amp;rpbr);    PPCInformAsync(ipbr);    }  }OSErr WriteEasyPPCSession(EasyPPCSession es,long sessRefNum,    long packetType,void *buffer,long length,Boolean easyManage)/* * If 'easyManage' is true, then BigEasyPPC makes a local copy * of the data, and the caller is free to forget about his copy. */  {  OSErr result;  PPCWritePBRec *wpb;  EasyPPCWritePB *ewpb;  short i;  EasyPPCClient *clientPtr;  if(!es || (es-&gt;waitingToWrite &gt;= kEasyPPCWritePacketCount) )    {    result = 1;    goto goHome;    }  clientPtr = FindClient(es,sessRefNum);  if(!clientPtr)    {    result = 1;    goto goHome;    }  es-&gt;waitingToWrite ++;  for(i = 0; i &lt; kEasyPPCWritePacketCount; i++)    {    ewpb = &amp;es-&gt;wpbr[i];    if(!ewpb-&gt;used)      goto gotOne;    }  result = 1;        /* this should never happen! */  Debugger();  goto goHome;  gotOne:  ewpb-&gt;used = 1;  if(easyManage)    {    ewpb-&gt;buffer = NewPtr(length);    if(!ewpb-&gt;buffer)      DebugStr(&quot;\pCouldn't allocate ppc buffer copy! Whoa!&quot;);    BlockMove(buffer,ewpb-&gt;buffer,length);    buffer = ewpb-&gt;buffer;    }  else    ewpb-&gt;buffer = 0;  wpb = &amp;ewpb-&gt;wpbr;  wpb-&gt;ioCompletion = 0;  wpb-&gt;sessRefNum = clientPtr-&gt;sessRefNum;  wpb-&gt;bufferLength = length;  wpb-&gt;bufferPtr = buffer;  wpb-&gt;more = 0;  wpb-&gt;userData = length;  wpb-&gt;blockCreator = 0;  wpb-&gt;blockType = packetType;  result = PPCWriteAsync(wpb);goHome:  return result;  }OSErr ReadEasyPPCSession(EasyPPCSession es,long sessRefNum,void *buffer,long length)  {  OSErr result;  EasyPPCClient *clientPtr;  if(!es)    {    result = 1;    goto goHome;    }  clientPtr = FindClient(es,sessRefNum);  if(!clientPtr || clientPtr-&gt;waitingToReadLength || clientPtr-&gt;waitingToReadData)    {    result = 1;    goto goHome;    }  clientPtr-&gt;waitingToReadData = 1;  *(long *)buffer = clientPtr-&gt;tinyBuffer;  if(clientPtr-&gt;waitingDataSize &gt; 4)    {    clientPtr-&gt;rpbr.ioCompletion = 0;    clientPtr-&gt;rpbr.sessRefNum = clientPtr-&gt;sessRefNum;    clientPtr-&gt;rpbr.bufferLength = length - 4;    clientPtr-&gt;rpbr.bufferPtr = (void *) ( (long)buffer + 4 );    if(clientPtr-&gt;rpbr.bufferLength &lt; 0)      clientPtr-&gt;rpbr.bufferLength = 0;    result = PPCReadAsync(&amp;clientPtr-&gt;rpbr);    }goHome:  return result;  }/* ---------------------------------------------------------- */void PollEasyPPCClient(EasyPPCSession es,EasyPPCClient *clientPtr,    EasyPPCPollResult *pollResult)  {  /*   * Should we start up the read process?   */  if(!clientPtr-&gt;waitingToReadLength &amp;&amp; !clientPtr-&gt;waitingToReadData &amp;&amp;      clientPtr-&gt;sessRefNum)    /* neither? */    {    clientPtr-&gt;waitingToReadLength = 1;    clientPtr-&gt;rpbr.ioCompletion = 0;    clientPtr-&gt;rpbr.sessRefNum = clientPtr-&gt;sessRefNum;    clientPtr-&gt;rpbr.bufferLength = 4;    clientPtr-&gt;rpbr.bufferPtr = (void *)&amp;clientPtr-&gt;tinyBuffer;    pollResult-&gt;error = PPCReadAsync(&amp;clientPtr-&gt;rpbr);    if(pollResult-&gt;error)      {      pollResult-&gt;operation = 1;      pollResult-&gt;sessRefNum = clientPtr-&gt;sessRefNum;      pollResult-&gt;length = 0;      pollResult-&gt;packetType = 0;      pollResult-&gt;buffer = 0;      goto goHome;      }    }  /*   * Received a length datum?   */  if(clientPtr-&gt;waitingToReadLength &amp;&amp; clientPtr-&gt;rpbr.ioResult != 1)    {    clientPtr-&gt;waitingToReadLength = 0;    clientPtr-&gt;waitingDataSize = clientPtr-&gt;rpbr.userData;    pollResult-&gt;operation = easyPPCSessionMessageWaiting;    pollResult-&gt;error = clientPtr-&gt;rpbr.ioResult;    pollResult-&gt;sessRefNum = clientPtr-&gt;rpbr.sessRefNum;    pollResult-&gt;length = clientPtr-&gt;rpbr.userData;    pollResult-&gt;packetType = clientPtr-&gt;rpbr.blockType;    pollResult-&gt;buffer = 0;    goto goHome;    }  /*   * Received a message?   */  if(clientPtr-&gt;waitingToReadData &amp;&amp;      (clientPtr-&gt;waitingDataSize &lt; 4 || clientPtr-&gt;rpbr.ioResult != 1) )    {    clientPtr-&gt;waitingToReadData = 0;    clientPtr-&gt;waitingDataSize = 0;    pollResult-&gt;operation = easyPPCSessionMessageRead;    pollResult-&gt;error = clientPtr-&gt;rpbr.ioResult;    pollResult-&gt;sessRefNum = clientPtr-&gt;rpbr.sessRefNum;    pollResult-&gt;length = clientPtr-&gt;rpbr.userData;    pollResult-&gt;packetType = clientPtr-&gt;rpbr.blockType;    pollResult-&gt;buffer = clientPtr-&gt;rpbr.bufferPtr;    if(clientPtr-&gt;rpbr.more &amp;&amp; !pollResult-&gt;error)    /* don't handle part-reads very well. */      Debugger();    goto goHome;    }  /*   * Someone connect to us?   */  if(clientPtr-&gt;waitingToConnect &amp;&amp; clientPtr-&gt;ipbr.ioResult != 1)    {    if(clientPtr-&gt;ipbr.userData != testConnection)      {      clientPtr-&gt;waitingToConnect = 0;      clientPtr-&gt;sessRefNum = clientPtr-&gt;ipbr.sessRefNum;        pollResult-&gt;operation = easyPPCSessionJustConnected;      pollResult-&gt;error = clientPtr-&gt;ipbr.ioResult;      pollResult-&gt;sessRefNum = clientPtr-&gt;ipbr.sessRefNum;      pollResult-&gt;length = 0;      pollResult-&gt;packetType = 0;      pollResult-&gt;buffer = 0;      goto goHome;      }    }  /*   * No activity?   */  pollResult-&gt;operation = easyPPCSessionIdle;  pollResult-&gt;error = 0;  pollResult-&gt;sessRefNum = 0;  pollResult-&gt;length = 0;  pollResult-&gt;packetType = 0;  pollResult-&gt;buffer = 0;goHome:  HandleSomeErrors(es,pollResult);  }/* ---------------------------------------------------------- */void PollEasyPPCSession(EasyPPCSession es,EasyPPCPollResult *pollResult)  {  unsigned short i,j;  EasyPPCWritePB *ewpb;  PPCWritePBRec *wpb;  EasyPPCClient *clientPtr;  es-&gt;fairSeed++;  if(es-&gt;fairSeed &amp; 1)    goto checkOutgoing;  /*   * Every poll, switch which    * client gets checked first.   */  es-&gt;fairClient++;  j = es-&gt;fairClient;  for(i = 0; i &lt; kEasyPPCClientCount; i++)    {    clientPtr = &amp;es-&gt;client[ (i + j) % kEasyPPCClientCount];    if(clientPtr-&gt;used)      {      PollEasyPPCClient(es,clientPtr,pollResult);      if(pollResult-&gt;operation != easyPPCSessionIdle)        goto goHome;      }    }checkOutgoing:  /*   * Sent a message?   */  if(es-&gt;waitingToWrite)    {    es-&gt;fairWrite ++;    j = es-&gt;fairWrite + TickCount();    for(i = 0; i &lt; kEasyPPCWritePacketCount; i++)      {      ewpb = &amp;es-&gt;wpbr[(i + j) % kEasyPPCWritePacketCount];      wpb = &amp;ewpb-&gt;wpbr;      if(ewpb-&gt;used &amp;&amp; wpb-&gt;ioResult != 1)        {        es-&gt;waitingToWrite --;        ewpb-&gt;used = 0;        pollResult-&gt;operation = easyPPCSessionMessageWritten;        pollResult-&gt;error = wpb-&gt;ioResult;        pollResult-&gt;sessRefNum = wpb-&gt;sessRefNum;        pollResult-&gt;packetType = wpb-&gt;blockType;        pollResult-&gt;length = wpb-&gt;userData;        if(ewpb-&gt;buffer)          {          DisposePtr(ewpb-&gt;buffer);    /* easymanage */          pollResult-&gt;buffer = 0;          }        else          pollResult-&gt;buffer = wpb-&gt;bufferPtr;                  goto goHome;        }      }    }  pollResult-&gt;operation = easyPPCSessionIdle;  pollResult-&gt;error = 0;  pollResult-&gt;sessRefNum = 0;  pollResult-&gt;length = 0;  pollResult-&gt;packetType = 0;  pollResult-&gt;buffer = 0;goHome:  HandleSomeErrors(es,pollResult);  }void HandleSomeErrors(EasyPPCSession es,EasyPPCPollResult *pollResult)/* * Handle some types of PPC errors, and modify * the result accordingly. */  {  EasyPPCClient *clientPtr;  switch(pollResult-&gt;error)    {    case sessClosedErr:    case noSessionErr:      pollResult-&gt;error = easyPPCSessionOtherPortGone;      /*       * There may be no client, if we're just       * clearing out the stale outgoing-messages.       */      clientPtr = FindClient(es,pollResult-&gt;sessRefNum);      if(clientPtr)        RemoveClientEntry(es,clientPtr);      break;    default:      if(pollResult-&gt;error &lt; 0)        Debugger();      break;    }  }/* ---------------------------------------------------------- */OSErr BrowseAndConnectEasyPPCSession(EasyPPCSession es,    StringPtr prompt, StringPtr applListLabel,long *sessRefNum,    LocationNameRec *location,PortInfoRec *portInfo)  {  OSErr thisError;  if(es-&gt;connected &gt;= kEasyPPCClientCount)    /* enough connections? */    {    thisError = easyPPCSessionTooManyConnections;    goto goHome;    }  gEasyFilterSession = es;      /* great, pass arguments in global */  thisError = PPCBrowser(prompt,      applListLabel,      gEverBrowsed,      &amp;gTheLocation,      &amp;gThePortInfo,      EasyBrowserFilter,      0);  gEverBrowsed = true;  if(thisError)    goto goHome;  thisError = ConnectEasyPPCSession(es,&amp;gTheLocation,&amp;gThePortInfo,sessRefNum);  if(location)    *location = gTheLocation;  if(portInfo)    *portInfo = gThePortInfo;goHome:  return thisError;  }pascal Boolean EasyBrowserFilter (LocationNamePtr location, PortInfoPtr port)/* * If the port has the same type as us, and our servertype is our own type, * then guest access must be enabled, and a test connection is attempted. * * If the servertype is different, and we find one of that kind, then a * connection is attempted, but, if &quot;guest not allowed&quot; is returned, we * assume that it's okay to try, later, with the password, and allow it in * the browser. */  {  OSErr thisError;  if (port-&gt;name.u.port.creator == kEasyPPCPortCreator      &amp;&amp; port-&gt;name.u.port.type == gEasyFilterSession-&gt;serverType)    {    /*     * Try to connect to it, to see if it's available     */    PPCStartPBRec spbr;    PPCEndPBRec epbr;    spbr.ioCompletion = 0;    spbr.portRefNum = gEasyFilterSession-&gt;portRefNum;    spbr.serviceType = ppcServiceRealTime;    spbr.resFlag = 0;    spbr.portName = &amp;port-&gt;name;    spbr.locationName = location;    spbr.userData = testConnection;    spbr.userRefNum = 0;    thisError = PPCStartSync(&amp;spbr);    if(!thisError)            /* shouldn't accept, but... */      {      epbr.ioCompletion = 0;      epbr.sessRefNum = spbr.sessRefNum;      PPCEndSync(&amp;epbr);      return false;      }    else if(thisError == guestNotAllowedErr)      return true;    else      {      if(thisError == userRejectErr &amp;&amp; spbr.rejectInfo == testConnection)        return true;      else        return false;      }    }  else    return false;  }/* ---------------------------------------------------------- */void FindNamesEasyPPCSession(EasyPPCSession es,long sessRefNum,    StringPtr zoneName,StringPtr macName,StringPtr portName)/* * Return the names of the Macintosh we're connected to. */  {  EasyPPCClient *clientPtr;  StringPtr s;  clientPtr = FindClient(es,sessRefNum);  if(clientPtr)    {    if(zoneName)      {      s = clientPtr-&gt;locationName.u.nbpEntity.zoneStr;      if(s[0] &amp;&amp; clientPtr-&gt;locationName.locationKindSelector          == ppcNBPLocation)        MoveString(s,zoneName);      else        MoveString(&quot;\p&lt;Local&gt;&quot;,zoneName);      }    if(macName)      {      s = clientPtr-&gt;locationName.u.nbpEntity.objStr;      if(s[0] &amp;&amp; clientPtr-&gt;locationName.locationKindSelector          == ppcNBPLocation)        MoveString(s,macName);      else        MoveString(&quot;\p&lt;This Macintosh&gt;&quot;,macName);      }    if(portName)      MoveString(clientPtr-&gt;portName.name,portName);    }  else    {    if(zoneName)      zoneName[0] = 0;    if(macName)      macName[0] = 0;    if(portName)      portName[0] = 0;    }  }/* ---------------------------------------------------------- */void InitializeClient(EasyPPCSession es,EasyPPCClient *clientPtr)/* * Initialize just this client, as if it's * just sitting there. */  {  #pragma unused (es)  clientPtr-&gt;sessRefNum = 0;  clientPtr-&gt;waitingToConnect = 0;  clientPtr-&gt;waitingToReadData = 0;  clientPtr-&gt;waitingToReadLength = 0;  }/* ---------------------------------------------------------- */EasyPPCClient *FindClient(EasyPPCSession es,long sessRefNum)/* * Do a linear search of the EasyPPCSession's * clients, and return a pointer to the * client specified. * * sessRefNum nil==0 matches to the first client. * So, an app that only has one connection need not remember * its refNum. * * If there isn't a match, return nil. */  {  short i;  EasyPPCClient *w;  if(!es-&gt;connected)    {    w = 0;    goto goHome;    }  if(sessRefNum == 0)    {    w = &amp;es-&gt;client[0];    if(!w-&gt;sessRefNum)    /* Not a good choice, if not really connected */      w = 0;    goto goHome;    }  for(i = 0; i &lt; kEasyPPCClientCount; i++)    {    w = &amp;es-&gt;client[i];    if(w-&gt;used &amp;&amp; w-&gt;sessRefNum == sessRefNum)      goto goHome;    }  w = 0;goHome:  return w;  }/* ---------------------------------------------------------- */void RemoveClientEntry(EasyPPCSession es,EasyPPCClient *clientPtr)/* * Remove client number 'n' from the list. * Assume the list is locked, already. * Also, unmark any outgoing packets for that session. */  {  /*   * Remove any waiting outgoing packets   */  clientPtr-&gt;used = 0;  es-&gt;connected --;  }/* ---------------------------------------------------------- */EasyPPCClient *FindFreeClient(EasyPPCSession es)  {  short i;  EasyPPCClient *clientPtr;  for(i = 0; i &lt; kEasyPPCClientCount; i++)    {    clientPtr = &amp;es-&gt;client[i];    if(!clientPtr-&gt;used)      {      clientPtr-&gt;used = 1;      es-&gt;connected ++;      goto goHome;      }    }  clientPtr = 0;  Debugger(); //!!! should _never_ happen.goHome:  return clientPtr;  }/* ---------------------------------------------------------- */void SetServerTypeEasyPPCSession(EasyPPCSession es,OSType serverType)  {  es-&gt;serverType = serverType;  }</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/Embedding_Instruments/listing11.html%3Fid%3DDTS10000321-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/Embedding_Instruments/listing11.html%3Fid%3DDTS10000321-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/Embedding_Instruments/listing11.html%3Fid%3DDTS10000321-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>