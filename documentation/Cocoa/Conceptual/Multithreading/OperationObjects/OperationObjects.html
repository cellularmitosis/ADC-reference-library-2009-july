<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>Threading Programming Guide: Creating and Managing Operation Objects</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Creating and Managing Operation Objects"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/10000057i-CH14" title="Creating and Managing Operation Objects"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../index.html#//apple_ref/doc/uid/TP30000440-TP30000416" target="_top">Cocoa</a> &gt; <a href="../../../ProcessManagement-date.html#//apple_ref/doc/uid/TP30000440-TP30000416-TP30000456" target="_top">Process Management</a> &gt; <a href="../Introduction/Introduction.html#//apple_ref/doc/uid/10000057i-CH1-SW1">Threading Programming Guide</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../AboutThreads/AboutThreads.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../CreatingThreads/CreatingThreads.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        
        <a name="//apple_ref/doc/uid/10000057i-CH14-SW1" title="Creating and Managing Operation Objects"></a><h1>Creating and Managing Operation Objects</h1><p>Introduced in Mac OS X v10.5, operation objects and operation queue objects simplify the job of executing multiple, finite tasks in a concurrent manner. Operation objects provide a way for you to encapsulate tasks into distinct objects. Each subclass of <code>NSOperation</code> that you create represents a unique type of task to be performed by your application. When you want to perform one of these tasks, simply create the appropriate operation object and either run it directly or add it to an operation queue. </p><p>The encapsulation provided by operation objects makes them a good way to manage your application’s independent tasks. Encasing the data and behavior for a given task inside a single object provides a clean demarcation between that task and the rest of your application. Having individual tasks inside objects also makes it easier to reuse those tasks in other code. </p><p>One of the other great benefits of operation objects, though, is the ability to add them to an operation queue. An operation queue manages the execution of operation objects within separate threads of your application. You do not have to write any thread creation or management code to make this happen either. The operation queue takes care of all the thread management work behind the scenes so that you can focus on what you want to run, and not how you want to run it. Operation queues can also manage interoperation dependencies to make sure your tasks execute in the correct order. </p><p>The following sections provide background on operation objects and show you how to define custom operation objects and run them with and without an operation queue. Even if you do not plan to run tasks in separate threads, you should consider using operation objects to manage tasks. The encapsulation they provide makes for better code reuse and management over time. </p>
<!-- This template is being used for both PDF and HTML. -->

    
    <h4>In this section:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="OperationObjects.html#//apple_ref/doc/uid/10000057i-CH14-SW14">About Operation Objects and Operation Queues</a>
				
			<br/>
			
        
			
			
				<a href="OperationObjects.html#//apple_ref/doc/uid/10000057i-CH14-SW15">Configuration Options for Operation Objects</a>
				
			<br/>
			
        
			
			
				<a href="OperationObjects.html#//apple_ref/doc/uid/10000057i-CH14-SW16">Defining Operation Objects</a>
				
			<br/>
			
        
			
			
				<a href="OperationObjects.html#//apple_ref/doc/uid/10000057i-CH14-SW19">Running Operations</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/10000057i-CH14-SW14" title="About Operation Objects and Operation Queues"></a><h2>About Operation Objects and Operation Queues</h2><p>Operation objects provide a flexible mechanism for encapsulating the code and data associated with a task. Operation queue objects provide an advanced infrastructure for executing those operations in background threads. Together these objects simplify the steps needed to create background tasks and run them in your application.</p><p><span class="content_text">Table 2-1</span> lists the classes associated with implementing and managing operations. </p><a name="//apple_ref/doc/uid/10000057i-CH14-SW5" title="Table 2-1Operation-related classes"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table 2-1&nbsp;&nbsp;</strong>Operation-related classes</caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Class</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Description</p></th></tr><tr><td  scope="row"><p><code>NSOperation</code></p></td><td ><p>The base subclass for defining an operation object. You can override this class to create custom operation objects for your application’s tasks. You can use the default <code>NSOperation</code> methods to manage the status of your task and set up the execution environment, or you can override those methods to customize the environment. For information on creating a basic subclass, see <span class="content_text"><a href="OperationObjects.html#//apple_ref/doc/uid/10000057i-CH14-SW4">“Defining a Simple NSOperation Subclass.”</a></span> </p></td></tr><tr><td  scope="row"><p><code>NSInvocationOperation</code></p></td><td ><p>A concrete subclass of <code>NSOperation</code>. Instead of subclassing <code>NSOperation</code>, you can use this class as-is to create a task from an existing object and selector in your application. You might use this class in cases where you do not want to create custom subclasses of <code>NSOperation</code>. For example, you might use it in cases where your tasks are already encapsulated in custom objects, or in cases where you want to choose a task dynamically at runtime. For information about how to use this class, see <span class="content_text"><a href="OperationObjects.html#//apple_ref/doc/uid/10000057i-CH14-SW6">“Using an NSInvocationOperation Object.”</a></span> </p></td></tr><tr><td  scope="row"><p><code>NSOperationQueue</code></p></td><td ><p>An infrastructure object you use to manage operation objects. An application can use any number of operation queues to run operations, although one is usually sufficient. Each queue works with the kernel to ensure operations are run in the most efficient manner possible. For information on managing operations with an operation queue, see <span class="content_text"><a href="OperationObjects.html#//apple_ref/doc/uid/10000057i-CH14-SW2">“Using a Queue to Run Operations.”</a></span> </p></td></tr></table></div><a name="//apple_ref/doc/uid/10000057i-CH14-SW15" title="Configuration Options for Operation Objects"></a><h2>Configuration Options for Operation Objects</h2><p>The <code>NSOperation</code> class is flexible and supports several different configuration and usage variants. These variants make it possible to design your operation objects in several different ways, depending on your needs. Fortunately, there are simple options if you just want the basic behavior provided by <code>NSOperation</code>, and even the more advanced configuration options do not require large amounts of work.</p><p><span class="content_text">Table 2-2</span> lists the basic options for creating your <code>NSOperation</code> object. The overrides column lists the methods you need to override to support each configuration option. You may need to override additional methods, but this column lists the ones you should always override.</p><a name="//apple_ref/doc/uid/10000057i-CH14-SW13" title="Table 2-2Configuration options for operation objects"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table 2-2&nbsp;&nbsp;</strong>Configuration options for operation objects</caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Option</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Overrides</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Description</p></th></tr><tr><td  scope="row"><p>Avoid subclassing <code>NSOperation</code></p></td><td ><p>None</p></td><td ><p>Create an <code>NSInvocationOperation</code> object and provide it with the object and selector you want to run. For more information, see <span class="content_text"><a href="OperationObjects.html#//apple_ref/doc/uid/10000057i-CH14-SW6">“Using an NSInvocationOperation Object”</a></span></p></td></tr><tr><td  scope="row"><p>Simple <code>NSOperation</code> object</p></td><td ><p><code>main</code></p></td><td ><p>Use the <code>main</code> method to implement your task. The operation object uses the default implementation to manage the operation’s dependency and state information. For more information, see <span class="content_text"><a href="OperationObjects.html#//apple_ref/doc/uid/10000057i-CH14-SW4">“Defining a Simple NSOperation Subclass”</a></span></p></td></tr><tr><td  scope="row"><p>Custom configuration of the operation’s runtime environment (option 1)</p></td><td ><p><code>start</code></p><p><code>main</code></p><p><code>isExecuting</code></p><p><code>isFinished</code></p></td><td ><p>Use the <code>start</code> method to set up your custom environment. Use the <code>main</code> method to implement the actual task. Your <code>start</code> method should call your <code>main</code> method at some point and update state information, such as the <code>isExecuting</code> and <code>isFinished</code> properties. For more information, see <span class="content_text"><a href="OperationObjects.html#//apple_ref/doc/uid/10000057i-CH14-SW8">“Customizing the Execution Environment of an Operation Object.”</a></span> </p></td></tr><tr><td  scope="row"><p>Custom configuration of the operation’s runtime environment  (option 2)</p></td><td ><p><code>start</code></p><p><code>isExecuting</code></p><p><code>isFinished</code></p></td><td ><p>Use the <code>start</code> method to set up your custom environment and implement the actual task. Your <code>start</code> method should update state information, such as the <code>isExecuting</code> and <code>isFinished</code> properties. For more information, see <span class="content_text"><a href="OperationObjects.html#//apple_ref/doc/uid/10000057i-CH14-SW8">“Customizing the Execution Environment of an Operation Object.”</a></span> </p></td></tr></table></div><p>The environment in which your operation objects runs depends partly on how you run the operation object and how you have customized that object. <span class="content_text">Table 2-3</span> lists the different options for running your operation objects. </p><a name="//apple_ref/doc/uid/10000057i-CH14-SW12" title="Table 2-3Running operation objects in different environments "></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table 2-3&nbsp;&nbsp;</strong>Running operation objects in different environments </caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Option</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Description</p></th></tr><tr><td  scope="row"><p>Run the operation in the current thread</p></td><td ><p>Invoke the <code>start</code> method of the operation object directly. </p></td></tr><tr><td  scope="row"><p>Run the operation in a background thread (option 1)</p></td><td ><p>Add the operation object to an <code>NSOperationQueue</code> object. (Recommended)</p></td></tr><tr><td  scope="row"><p>Run the operation in a background thread (option 2)</p></td><td ><p>Create a custom thread and invoke the <code>start</code> method of the operation object from that thread. </p></td></tr><tr><td  scope="row"><p>Run the operation object in a custom environment</p></td><td ><p>Customize the operation object as described in <span class="content_text"><a href="OperationObjects.html#//apple_ref/doc/uid/10000057i-CH14-SW8">“Customizing the Execution Environment of an Operation Object.”</a></span> Add the operation object to an operation queue or invoke its <code>start</code> method directly. </p></td></tr></table></div><a name="//apple_ref/doc/uid/10000057i-CH14-SW16" title="Defining Operation Objects"></a><h2>Defining Operation Objects</h2><p>There are two ways to create an operation object: You can subclass <code>NSOperation</code> or create an <code>NSInvocationOperation</code> object to wrap an existing method. Either technique results in essentially the same operation object; the only difference is how you define the task. The following sections show you how to use operation objects to implement tasks and how you configure those objects for execution. </p><a name="//apple_ref/doc/uid/10000057i-CH14-SW6" title="Using an NSInvocationOperation Object"></a><h3>Using an NSInvocationOperation Object</h3><p>The <code>NSInvocationOperation</code> class is a concrete subclass of <code>NSOperation</code> that, when run, invokes a selector on the object you specify. You might use this class as a convenient way to define operation objects without having to subclass <code>NSOperation</code>. For example, if your application uses operations to perform a large number of tasks, you might not want to define separate operation objects for each. Instead, you could use <code>NSInvocationOperation</code> to create tasks out of existing methods. You might also use this class when the task you need to perform is determined more dynamically. In such a case, each potential task could be associated with a different selector that you use to create the resulting operation object. </p><p><span class="content_text">Listing 2-1</span> shows a custom class that creates a new <code>NSInvocationOperation</code> object and adds it to the application’s shared operation queue. The operation queue in this example is accessed through a custom method of the application delegate, but you could create the operation queue anywhere in your application. Once added to the queue, the operation runs automatically in a background thread until it completes or is explicitly cancelled.  </p><a name="//apple_ref/doc/uid/10000057i-CH14-SW7" title="Listing 2-1Creating a task with NSInvocationOperation"></a><p class="codesample"><strong>Listing 2-1&nbsp;&nbsp;</strong>Creating a task with NSInvocationOperation</p><div class="codesample"><table><tr><td scope="row"><pre>@implementation MyCustomClass<span></span></pre></td></tr><tr><td scope="row"><pre>- (void)launchTaskWithData:(id)data<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    NSInvocationOperation* theOp = [[NSInvocationOperation alloc] initWithTarget:self<span></span></pre></td></tr><tr><td scope="row"><pre>                    selector:@selector(myTaskMethod:) object:data];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Add the operation to the internal operation queue managed by the application delegate.<span></span></pre></td></tr><tr><td scope="row"><pre>    [[MyAppDelegate sharedOperationQueue] addOperation:theOp];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>// This is the method that does the actual work of the task.<span></span></pre></td></tr><tr><td scope="row"><pre>- (void)myTaskMethod:(id)data<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    // Perform the task.<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre>@end<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/10000057i-CH14-SW4" title="Defining a Simple NSOperation Subclass"></a><h3>Defining a Simple NSOperation Subclass</h3><p>If you want a more explicit separation between your general application code and your task-specific code, you can subclass  <code>NSOperation</code> directly to implement your tasks. When you subclass <code>NSOperation</code>, you put all of your task-based code, along with the data needed to implement that task, into your subclass. If all of the data belongs to the operation object, you can avoid synchronization issues. Even in situations where an operation does use a shared object, you now have the option of taking locks at the operation object level, where doing so might be more efficient.</p><p>To define a minimal operation object, create a new subclass of <code>NSOperation</code>, add whatever instance variables you need to your subclass, and implement the following methods: </p><ul class="spaceabove"><li class="li"><p>a custom initialization method</p></li><li class="li"><p>the <code>main</code> method</p></li></ul><p>In general, you should use a custom initialization method to configure your operation object as much as possible. If you define accessor methods for instance variables and plan to call those methods from other threads, be sure to employ some sort of synchronization to prevent thread-safety issues. Better yet, avoid accessing member variables from multiple threads entirely. Instead, just set the variables from a single thread at initialization time and read them back only after the operation finishes.</p><p>The actual implementation of your task goes inside the <code>main</code> method. This method is defined by <code>NSOperation</code> but the default implementation does nothing. Your implementation of this method should perform the desired task and then notify any interested clients when the results are ready. The notification process can vary depending on your needs. You can use an actual notification object, set a flag, send a message to the main thread using one of the perform selector routines of <code>NSObject</code>, or you can have interested clients register for KVO notifications on your object’s <code>isFinished</code> property.</p><p>If your task is long-lived—that is, it takes more than a few milliseconds to execute—your <code>main</code> method should periodically check to see if the operation was cancelled. You do this by calling the <code>isCancelled</code> method of your operation object. If this method ever returns <code>YES</code>, your <code>main</code> method should immediately stop what it is doing and exit, leaving any pending calculations unfinished. The exact amount of time you should wait between calls to <code>isCancelled</code> depends entirely on how responsive you want your task to be. If the task can be programmatically terminated, you might want to call this method more frequently. If it can only be cancelled by the user, once every millisecond is probably sufficient, but more frequently would be even better. </p><p>To run your operation, create a new instance and add it to an operation queue as described in <span class="content_text"><a href="OperationObjects.html#//apple_ref/doc/uid/10000057i-CH14-SW2">“Using a Queue to Run Operations.”</a></span> For additional options on how to run your operation, see <span class="content_text"><a href="OperationObjects.html#//apple_ref/doc/uid/10000057i-CH14-SW3">“Running an Operation Object Directly.”</a></span> </p><a name="//apple_ref/doc/uid/10000057i-CH14-SW17" title="Configuring Dependencies Among Operation Objects"></a><h3>Configuring Dependencies Among Operation Objects</h3><p>Dependencies define the relationships between operation objects. You use dependencies in your application to enforce a specific execution order for your operations. When you add a dependency to an operation object, you prevent that operation object from starting until the dependent operation has finished. For example, you might use a dependency to prevent one operation from starting until the data it needed was generated by a different operation object.</p><p>To establish dependencies between operations, use the <code>addDependency:</code> method. To remove dependencies, use the <code>removeDependency:</code> method. You can add as many dependencies as you want to a given operation, but it is a programmer error to create circular dependencies. </p><div class="importantbox"><a name="//apple_ref/doc/uid/10000057i-CH14-DontLinkElementID_8" title="Important:"></a><p><strong>Important:</strong>&nbsp;You should always configure dependencies before running your operation object or adding it to an operation queue. Dependencies added afterwards may not prevent the operation object from running.  </p><p></p></div><p>Dependencies rely on each operation object sending out appropriate KVO notifications whenever the status of the object changes. If you customize the behavior of your operation objects, you may need to generate appropriate KVO notifications from your custom code to avoid causing issues with dependencies. For more information on KVO notifications and operation objects, see <span class="content_text"><a href="OperationObjects.html#//apple_ref/doc/uid/10000057i-CH14-SW10">“Maintaining KVO Compliance.”</a></span> For additional information on configuring dependencies, see <em><a href="../../../Reference/NSOperation_class/index.html#//apple_ref/doc/uid/TP40004591" target="_top">NSOperation Class Reference</a></em>.</p><a name="//apple_ref/doc/uid/10000057i-CH14-SW8" title="Customizing the Execution Environment of an Operation Object"></a><h3>Customizing the Execution Environment of an Operation Object</h3><p>The default runtime environment for operations is a thread. If you run an operation from an operation queue, the <code>NSOperationQueue</code> object creates a new thread and runs the operation in it. If you run an operation directly, the operation runs in the current thread. Threads are not the only environment you can use in conjunction with operations, however. Through customization, it is possible to configure a custom environment. </p><p>The <code>NSOperation</code> class itself is simply an abstraction for a task. It does not matter how that task is executed. What is important is the encapsulation that the class provides. You could create an operation object that performs its task by launching a separate process or by calling an asynchronous function and handling the resulting callback. Both of these options are perfectly acceptable and might not involve threads at all. </p><p>The following sections show how to modify an operation object to use a different runtime environment or use a slightly modified version of the existing thread environment.  </p><a name="//apple_ref/doc/uid/10000057i-CH14-SW18" title="Configuring a Custom Runtime Environment"></a><h4>Configuring a Custom Runtime Environment</h4><p>Configuring an operation object to use a different environment involves override the following methods at a minimum: </p><ul class="spaceabove"><li class="li"><p><code>isConcurrent</code></p></li><li class="li"><p><code>start</code></p></li></ul><p>The implementation of your <code>isConcurrent</code> method is pretty simple. Override it and return <code>YES</code> to let Cocoa know that the operation object configures its own runtime environment. </p><p>The <code>start</code> method is where you configure your environment and run your task. In the case of launching a separate process, you might <code>fork</code> and <code>exec</code> the process here, set up a communications channel for receiving the results, and exit. Similarly, in the case of calling an asynchronous function, you would call the function and exit. The key part to both of these techniques is that after setting up the environment, you start the task and then exit from the <code>start</code> method. You do not want your <code>start</code> method to block the current thread, because as strange as it might sound, Cocoa executes concurrent tasks on the current thread. The “concurrency” in this case is provided by you when you set your task in motion and exit. </p><p>Of course, the end of your <code>start</code> method does not imply that your task is finished or that your work is done. Another job of your customized <code>NSOperation</code> object (and your <code>start</code> method in particular) is to generate KVO notifications about the current execution status of the operation. In your start method, this means generating change notifications for the <code>isExecuting</code> property. Your <code>start</code> method must do this. Once your task completes (or is cancelled), your operation object must generate another notification for the <code>isExecuting</code> property and another notification for the <code>isFinished</code> (or <code>isCancelled</code>) property.</p><p><span class="content_text">Listing 2-2</span> shows the implementation of a simple operation class that forks a process and waits for it to exit. The <code>start</code> method of the operation object creates the <code>NSTask</code> object, registers for the <code>NSTaskDidTerminateNotification</code> notification, launches the task, and exits. Receipt of the notification results in the finalization of the task, which generates the final KVO change notifications. Because the class maintains its own instance variables for the <code>isExecuting</code> and <code>isFinished</code> properties, the implementation of the class also provides overrides of the corresponding accessor methods. </p><a name="//apple_ref/doc/uid/10000057i-CH14-SW11" title="Listing 2-2Using an operation object to launch a process"></a><p class="codesample"><strong>Listing 2-2&nbsp;&nbsp;</strong>Using an operation object to launch a process</p><div class="codesample"><table><tr><td scope="row"><pre>@interface TaskOperation : NSOperation {<span></span></pre></td></tr><tr><td scope="row"><pre>    NSTask*     task;<span></span></pre></td></tr><tr><td scope="row"><pre>    BOOL        executing;<span></span></pre></td></tr><tr><td scope="row"><pre>    BOOL        finished;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre>- (void)handleTaskExitedNotification:(NSNotification*)aNotification;<span></span></pre></td></tr><tr><td scope="row"><pre>@end<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>@implementation TaskOperation<span></span></pre></td></tr><tr><td scope="row"><pre>- (id)init {<span></span></pre></td></tr><tr><td scope="row"><pre>    self = [super init];<span></span></pre></td></tr><tr><td scope="row"><pre>    if (self){<span></span></pre></td></tr><tr><td scope="row"><pre>        executing = NO;<span></span></pre></td></tr><tr><td scope="row"><pre>        finished = NO;<span></span></pre></td></tr><tr><td scope="row"><pre>        task = nil;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    return self;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>- (BOOL)isConcurrent {<span></span></pre></td></tr><tr><td scope="row"><pre>    return YES;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>- (void)start {<span></span></pre></td></tr><tr><td scope="row"><pre>    // Create the NSTask object.<span></span></pre></td></tr><tr><td scope="row"><pre>    task = [[NSTask alloc] init];<span></span></pre></td></tr><tr><td scope="row"><pre>    [task setLaunchPath:@"/usr/bin/myCustomTool"];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    [[[NSApplication sharedApplication] delegate] registerNotifications];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    [[NSNotificationCenter defaultCenter] addObserver:self<span></span></pre></td></tr><tr><td scope="row"><pre>            selector:@selector(handleTaskExitedNotification:)<span></span></pre></td></tr><tr><td scope="row"><pre>            name:NSTaskDidTerminateNotification<span></span></pre></td></tr><tr><td scope="row"><pre>            object:task];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // If the operation hasn't already been cancelled, launch it.<span></span></pre></td></tr><tr><td scope="row"><pre>    if (![self isCancelled]) {<span></span></pre></td></tr><tr><td scope="row"><pre>        [self willChangeValueForKey:@"isExecuting"];<span></span></pre></td></tr><tr><td scope="row"><pre>        executing = YES;<span></span></pre></td></tr><tr><td scope="row"><pre>        [task launch];<span></span></pre></td></tr><tr><td scope="row"><pre>        [self didChangeValueForKey:@"isExecuting"];<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>- (void)handleTaskExitedNotification:(NSNotification*)aNotification {<span></span></pre></td></tr><tr><td scope="row"><pre>    [self willChangeValueForKey:@"isFinished"];<span></span></pre></td></tr><tr><td scope="row"><pre>    [self willChangeValueForKey:@"isExecuting"];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    finished = YES;<span></span></pre></td></tr><tr><td scope="row"><pre>    executing = NO;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Clean up.<span></span></pre></td></tr><tr><td scope="row"><pre>    [[NSNotificationCenter defaultCenter] removeObserver:self<span></span></pre></td></tr><tr><td scope="row"><pre>            name:NSTaskDidTerminateNotification<span></span></pre></td></tr><tr><td scope="row"><pre>            object:task];<span></span></pre></td></tr><tr><td scope="row"><pre>    [task release];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    NSLog(@"Task exit notification received successfully.\n");<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    [self didChangeValueForKey:@"isExecuting"];<span></span></pre></td></tr><tr><td scope="row"><pre>    [self didChangeValueForKey:@"isFinished"];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>- (BOOL)isExecuting {<span></span></pre></td></tr><tr><td scope="row"><pre>    return executing;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>- (BOOL)isFinished {<span></span></pre></td></tr><tr><td scope="row"><pre>    return finished;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>@end<span></span></pre></td></tr></table></div><p>As with other operation objects, your code should call the <code>isCancelled</code> method whenever possible to determine whether the operation has been cancelled. If the method ever returns <code>YES</code>, you should abort the current task and set both the <code>isExecuting</code> and <code>isFinished</code> properties to <code>NO</code>. </p><a name="//apple_ref/doc/uid/10000057i-CH14-SW10" title="Maintaining KVO Compliance"></a><h4>Maintaining KVO Compliance</h4><p>The <code>NSOperation</code> class is KVO compliant for the following properties: </p><ul class="spaceabove"><li class="li"><p><code>isCancelled</code></p></li><li class="li"><p><code>isConcurrent</code></p></li><li class="li"><p><code>isExecuting</code></p></li><li class="li"><p><code>isFinished</code></p></li><li class="li"><p><code>isReady</code></p></li><li class="li"><p><code>dependencies</code></p></li><li class="li"><p><code>queuePriority</code></p></li></ul><p>If you override the <code>start</code> method or do any other significant customization of an <code>NSOperation</code> object, other than override <code>main</code>, you must ensure that your custom object remains KVO compliant for these properties. For custom operation objects, the properties you should be most concerned with are the <code>isExecuting</code> and <code>isFinished</code> properties. These are the properties most commonly affected by implementing a custom <code>start</code> method. </p><p>If your custom operation object also manages its own set of custom dependencies, you should also add KVO notifications for the <code>isReady</code> property. You should also override the <code>isReady</code> method and force it to return <code>NO</code> until your custom dependencies were satisfied. (Be sure to call <code>super</code> if you also support the default dependency management of <code>NSOperation</code> .) Unless you override the <code>addDependency:</code> or <code>removeDependency:</code> methods, you should not need to worry about the <code>dependencies</code> property.</p><p>Although you could generate KVO notifications for other properties of <code>NSOperation</code>, it is unlikely you would ever need to do so. If you need to cancel an operation, you can simply use the existing <code>cancel</code> method to do so. Similarly, there should be little need for you to modify the queue priority information in an operation object. Finally, unless your operation is capable of changing its concurrency status dynamically, you do not need to provide KVO notifications for the <code>isConcurrent</code> property.</p><p>For an example that shows how to generate KVO notifications for the <code>isExecutable</code> and <code>isFinished</code> properties, see <span class="content_text"><a href="OperationObjects.html#//apple_ref/doc/uid/10000057i-CH14-SW11">Listing 2-2</a></span>. </p><a name="//apple_ref/doc/uid/10000057i-CH14-SW20" title="Responding to Errors"></a><h3>Responding to Errors</h3><p>If your operation object is unable to perform its task for some reason, it is your responsibility to make that determination and generate the appropriate errors. Similarly, if your operation object is dependent on other operations that may fail, it is also your responsibility to respond to potential errors and abort the current operation as needed. </p><p>Operation objects that are not concurrent (that is, their <code>isConcurrent</code> method returns <code>NO</code>) automatically catch and suppress any exceptions thrown by the operation object’s <code>main</code> method. Thus, an operation that generates an exception may appear to finish normally even if it did not. If an operation may fail, it is up to you to provide a way for dependent operations to determine that an error occurred and do something about it. For example, you might want to provide a custom method for reporting whether the operation completed successfully. The <code>isReady</code> method of dependent operation objects could then call this method and use it to determine whether it is safe to execute.</p><a name="//apple_ref/doc/uid/10000057i-CH14-SW19" title="Running Operations"></a><h2>Running Operations</h2><p>Once you have an operation object, you need to know how to run it. There are two ways to run an operation object: directly or from an operation queue. The following sections show you how to use both of these options.</p><a name="//apple_ref/doc/uid/10000057i-CH14-SW2" title="Using a Queue to Run Operations"></a><h3>Using a Queue to Run Operations</h3><p>By far, the easiest way to run an operation is to add it to an operation queue. The <code>NSOperationQueue</code> class defines the basic interface for managing operation objects within an application. An operation queue is typically a long-lived object—that is, you create it and keep it around for the lifetime of your application. An application can create any number of operation queues, although one is usually sufficient. </p><p>To run an operation, all you have to do is add that operation to a queue using the <code>addOperation:</code> method, as shown in <span class="content_text">Listing 2-3</span>. This method gets the application’s shared queue object and adds the specified operation to it. </p><a name="//apple_ref/doc/uid/10000057i-CH14-SW9" title="Listing 2-3Adding an operation to a queue"></a><p class="codesample"><strong>Listing 2-3&nbsp;&nbsp;</strong>Adding an operation to a queue</p><div class="codesample"><table><tr><td scope="row"><pre>- (void)myQueueUpOperation:(NSOperation*)theOp<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    // Get the custom queue object from the app delegate.<span></span></pre></td></tr><tr><td scope="row"><pre>    NSOperationQueue* myQueue = [[[NSApplication sharedApplication] delegate] myOperationQueue];<span></span></pre></td></tr><tr><td scope="row"><pre>    [myQueue addOperation:theOp];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>In most cases, operations are run shortly after they are added to an operation queue. The operation queue may delay execution of an operation for any of several reasons, however. Specifically, an operation may be delayed if it is dependent on other operations that have not yet completed. It may also be delayed if the operation queue determines that there are not enough system resources to run it. </p><p>Operation queues try to balance the available system resources with the amount of work that needs to be done. Rather than spawn a number of operations and let them vie for processor time, operation queues work with the kernel to run as many operations as possible while still using the available processor cores efficiently. The maximum number of simultaneous operations typically matches the number of available cores. If the system load is particularly heavy or several cores are dedicated to other tasks, however, the operation queue may run fewer operations.</p><div class="importantbox"><a name="//apple_ref/doc/uid/10000057i-CH14-DontLinkElementID_9" title="Important:"></a><p><strong>Important:</strong>&nbsp;You should never modify an operation object after it has been added to a queue. While waiting in a queue, the operation could execute at any time. Changing its status while it is executing could have adverse effects. You can use the methods of the operation object to determine if the operation is running, waiting to run, or already finished.</p><p></p></div><p>If you want to remove an operation from a queue before it completes its task, you must cancel it. You can cancel individual operation objects by calling their <code>cancel</code> method or you can cancel all of the operation objects in a queue by calling the <code>cancelAllOperations</code> method of the queue object. You should cancel only operations that you no longer need to perform. Issuing a cancel command puts the operation object into the “cancelled” state, which prevents it from being run again.</p><p>For information about using operation queues, see <em><a href="../../../Reference/NSOperationQueue_class/index.html#//apple_ref/doc/uid/TP40004592" target="_top">NSOperationQueue Class Reference</a></em>. </p><a name="//apple_ref/doc/uid/10000057i-CH14-SW3" title="Running an Operation Object Directly"></a><h3>Running an Operation Object Directly</h3><p>It is possible to run operation objects directly and not use an operation queue. You might do so in cases where you want to run it either from the current thread or from a different thread. Or you might simply want to manage the execution of operations yourself without an operation queue. </p><p>To run an operation object directly, all you have to do is create the object, make sure it is ready, and then call its <code>start</code> method. It is important that an operation object is ready before you attempt to run it. The <code>isReady</code> method of <code>NSOperation</code> reports on the readiness of the operation, checking to make sure that any dependent operations have already finished. Once that method returns <code>YES</code>, you can call the <code>start</code> method to run the operation in the current thread. </p><div class="importantbox"><a name="//apple_ref/doc/uid/10000057i-CH14-DontLinkElementID_10" title="Important:"></a><p><strong>Important:</strong>&nbsp;You should always run an operation using the <code>start</code> method and not the <code>main</code> method. The default implementation of the <code>start</code> method updates the running state of the operation object, providing feedback to other dependent operations about when it is safe for them to execute. If you override the <code>start</code> method in your custom object, your implementation must maintain the running state as described in <span class="content_text"><a href="OperationObjects.html#//apple_ref/doc/uid/10000057i-CH14-SW10">“Maintaining KVO Compliance.”</a></span></p><p></p></div>

        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../AboutThreads/AboutThreads.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../CreatingThreads/CreatingThreads.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2008 Apple Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2008-02-08<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Cocoa/Conceptual/Multithreading/OperationObjects/OperationObjects.html%3Fid%3D10000057i-4.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Cocoa/Conceptual/Multithreading/OperationObjects/OperationObjects.html%3Fid%3D10000057i-4.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Cocoa/Conceptual/Multithreading/OperationObjects/OperationObjects.html%3Fid%3D10000057i-4.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>