<!-- Generated by Harlequin WebMaker 2.2.3 (23-Apr-1996)
LispWorks 3.2.2 -->
<HTML> <HEAD>
<TITLE>Creating and Using a Connection Listener(IM:N)</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING111></A>


<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->


<!-- Main Body -->

<CENTER>
<P>
<A HREF="Networking-110.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="Networking-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="Networking-304.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt= "Book Index"></A> <A HREF="Networking-112.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="Networking-2.html"><B>Networking</B></A> / <BR><DD><A HREF="Networking-98.html"><B>Chapter 5 - AppleTalk Data Stream Protocol (ADSP) </B></A> / <A HREF="Networking-107.html"><B>Using ADSP</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING111-0></A>
<H2><A NAME=MARKER-9-184></A><A NAME=MARKER-21-185></A>Creating and Using a Connection Listener</H2>
 <A NAME=MARKER-2-102></A>A connection listener is a special sort of ADSP connection end that cannot receive or transmit data streams or attention messages. The sole function of a connection listener <BR>is to wait passively to receive an open-connection request and to inform its client, the connection server, when it receives one. The connection server can then accept or deny the open-connection request. If it accepts the request, the connection server selects a socket to use as a connection end, establishes a connection end on that socket, and sends an acknowledgment and connection request back to the requesting connection end. The connection server can use the same socket as it used for the connection listener, or it <BR>can select a different socket as the connection end.<P>
 Use the following procedure to establish a connection listener and to use that connection listener to open a connection with a remote connection end:<P>
<OL>
<LI>Use the Device Manager's <CODE>OpenDriver</CODE> function to open the .MPP driver and then use the <CODE>OpenDriver</CODE> function to open the .DSP driver. The <CODE>OpenDriver</CODE> function returns the reference number for the .DSP driver. You must supply this reference number each time you call the .DSP driver.
<LI>Allocate nonrelocatable memory for a connection control block, which is described <BR>in <A HREF=Networking-100.html#MARKER-9-92>"Connections, Connection Ends, and Connection States" on page 5-6</A>. The CCB <BR>is 242 bytes. A connection listener does not need send and receive queues or an attention-message buffer. The memory that you allocate becomes the property of ADSP when you call the <CODE>dspCLInit</CODE> routine to establish a connection listener. You cannot write any data to this memory except by calling ADSP, and you must ensure that the memory remains locked until you call the <CODE>dspRemove</CODE> routine to eliminate the connection end. 
<LI>Call the <CODE>dspCLInit</CODE> routine to establish a connection listener. You must provide a pointer to the CCB. <P>
If there is a specific socket that you want to use for the connection listener, you can specify the socket number in the <CODE>localSocket</CODE> parameter. If you want ADSP to assign the socket for you, specify 0 for the <CODE>localSocket</CODE> parameter. ADSP returns the socket number when the <CODE>dspCLInit</CODE> routine completes execution.
<LI>If you wish, you can use the NBP routines to add the name and address of your connection listener to the node's names table. See the chapter "Name-Binding Protocol (NBP)" in this book for information on NBP.
<LI>Use the <CODE>dspCLListen</CODE> routine to cause the connection listener to wait for an open-<BR>connection request. Because the <CODE>dspCLListen</CODE> routine does not complete execution until it receives a connection request, you should call this routine asynchronously. <BR>You can specify a value for the <CODE>filterAddress</CODE> parameter to restrict the network number, node ID, or socket number from which you will accept an open-connection request. <P>
When the <CODE>dspCLListen</CODE> routine receives an open-connection request that meets <BR>the restrictions of the <CODE>filterAddress</CODE> parameter, it returns a <CODE>noErr</CODE> result code <BR>(if you executed the routine asynchronously, it places a <CODE>noErr</CODE> result code in the <CODE>ioResult</CODE> parameter) and places values in the parameter block for the <CODE>remoteCID</CODE>, <CODE>remoteAddress</CODE>, <CODE>sendSeq</CODE>, <CODE>sendWindow</CODE>, and <CODE>attnSendSeq</CODE> parameters. 
<LI>If you want to open the connection, call the <CODE>dspInit</CODE> routine to establish a connection end. You can use any available socket on the node for the connection end, including the socket that you used for the connection listener. Because a single socket can have more than one CCB connected with it, the socket can function simultaneously as a connection end and a connection listener. <P>
You can check the address of the remote socket to determine if it meets your criteria for a connection end. Although the <CODE>filterAddress</CODE> parameter to the <CODE>dspCLListen</CODE> routine provides some screening of socket addresses, it cannot check for network number ranges, for example, or for a specific set of socket numbers. If for some reason you want to deny the connection request, call the <CODE>dspDeny</CODE> routine, specifying the CCB of the connection listener in the <CODE>ccbRefNum</CODE> parameter. Because the <CODE>dspCLListen</CODE> routine completes execution when it receives an open-connection request, you must return to step 5 to wait for another connection request.
<LI>Call the <CODE>dspOpen</CODE> routine to open the connection. Specify the value <CODE>ocAccept</CODE> for the <CODE>ocMode</CODE> parameter and specify in the <CODE>ccbRefNum</CODE> parameter the reference number <BR>of the CCB for the connection end that you want to use. When you call the <CODE>dspOpen</CODE> routine, you must provide the values returned by the <CODE>dspCLListen</CODE> routine for <BR>the <CODE>remoteCID</CODE>, <CODE>remoteAddress</CODE>, <CODE>sendSeq</CODE>, <CODE>sendWindow</CODE>, and <CODE>attnSendSeq</CODE> parameters.<P>
You can poll the state field in the CCB to determine when the connection is open. Alternatively, you can check the result code for the <CODE>dspOpen</CODE> routine when the routine completes execution. If the routine returns the <CODE>noErr</CODE> result code, then the connection is open.
<LI>You can now send and receive data and attention messages over the connection, as described in <A HREF=Networking-110.html#MARKER-9-150>"Opening and Maintaining an ADSP Connection" beginning on page 5-13</A>. When you are ready to close the connection, you can use the <CODE>dspClose</CODE> or <CODE>dspRemove</CODE> routine, both of which are also described in the section <A HREF=Networking-109.html#MARKER-9-146>"Creating and Using a Connection Control Block."</A> 
<LI>When you are finished using the connection listener, you can use the <CODE>dspCLRemove</CODE> routine to eliminate it. Once you have called the <CODE>dspCLRemove</CODE> routine, you can release the memory you allocated for the connection listener's CCB.<P>
</OL>
 <A HREF=#MARKER-9-188>Listing 5-2</A> illustrates the use of ADSP to establish and use a connection listener. It opens the .MPP and .DSP drivers and <A NAME=MARKER-2-187></A>allocates memory for the CCB. Then it uses the <CODE>dspCLInit</CODE> routine to establish a connection listener, uses NBP to register the name of the connection end on the internet, and uses the <CODE>dspCLListen</CODE> routine to wait for a connection request. When the routine receives a connection request, it calls the <CODE>dspOpen</CODE> routine to complete the connection.<P>
<B>Listing 5-2  <A NAME=MARKER-9-188></A><A NAME=MARKER-21-189></A>Using ADSP to establish and use a connection listener</B><P>
<PRE>
VAR
   dspCCBPtr:     TPCCB;
   myDSPPBPtr:    DSPPBPtr;
   myMPPPBPtr:    MPPPBPtr;
   myNTEName:     NamesTableEntry;
   drvrRefNum:    Integer;
   mppRefNum:     Integer;
   connRefNum:    Integer;
   myErr:         OSErr;
BEGIN 
   myErr := OpenDriver('.MPP', mppRefNum);
                                 {open .MPP driver}
   IF myErr &lt;&gt; noErr THEN DoErr(myErr);
                                 {check and handle error}
   myErr := OpenDriver('.DSP', drvrRefNum);  
                                 {open .DSP driver}
   IF myErr &lt;&gt; noErr THEN DoErr(myErr);
                                 {check and handle error}
   {Allocate memory for data buffers.}
   dspCCBPtr := TPCCB(NewPtr(SizeOf(TRCCB)));
   myDSPPBPtr := DSPPBPtr(NewPtr(SizeOf(DSPParamBlock)));
   myMPPPBPtr := MPPPBPtr(NewPtr(SizeOf(MPPParamBlock)));
   WITH myDSPPBPtr^ DO           {set up dspCLInit parameters}
   BEGIN
      ioCRefNum := drvrRefNum;   {ADSP driver ref num}
      csCode := dspCLInit;
      ccbPtr := dspCCBPtr;       {pointer to CCB}
      localSocket := 0;          {local socket number}
   END;
   myErr := PBControl(ParmBlkPtr(myDSPPBPtr), FALSE);
                                 {establish a connection listener}
   IF myErr &lt;&gt; noErr THEN DoErr(myErr);   
                                 {check and handle error}
   connRefNum := myDSPPBPtr^.ccbRefNum;
                                 {save CCB ref num for later}
   NBPSetNTE(@myNTEName, 'The Object', 'The Type',
             '*', myDSPPBPtr^.localSocket);
                                 {set up NBP names table entry}
   WITH myMPPPBPtr^ DO           {set up PRegisterName parameters}
   BEGIN
      interval := 7;             {retransmit every 7*8=56 ticks }
      count := 3;                { and retry 3 times}
      entityPtr := @myNTEname;   {name to register}
      verifyFlag := 1;           {verify this name}
   END;
   myErr := PRegisterName(myMPPPBPtr, FALSE);
                                 {register this name}
   IF myErr &lt;&gt; noErr THEN DoErr(myErr);
                                 {check and handle error}
   WITH myDSPPBPtr^ DO           {set up dspCLListen parameters}
   BEGIN
      ioCRefNum := drvrRefNum;   {ADSP driver ref num}
      csCode := dspCLListen;
      ccbRefNum := connRefNum;   {connection ref num}
      filterAddress := AddrBlock(0);
                                 {connect with anybody}
   END;
   myErr := PBControl(ParmBlkPtr(myDSPPBPtr), TRUE);
                                 {listen for connection requests}
   WHILE myDSPPBPtr^.ioResult = 1 DO
   BEGIN
   {Return control to user while waiting for a connection }
   { request.}
      GoDoSomething;
   END;
   IF myErr &lt;&gt; noErr THEN DoErr(myErr);
                                 {check and handle error}
   
   WITH myDSPPBPtr^ DO           {set up dspInit parameters}
   BEGIN
      ioCRefNum := drvrRefNum;   {ADSP driver ref num}
      csCode := dspInit;
      ccbPtr := @dspCCB;         {pointer to CCB}
      userRoutine := @myConnectionEvtUserRoutine;
      sendQSize := qSize;        {size of send queue}
      sendQueue := dspSendQPtr;  {send-queue buffer}
      recvQSize := qSize;        {size of receive queue}
      recvQueue := dspRecvQPtr;  {receive-queue buffer}
      attnPtr := dspAttnBufPtr;  {receive-attention buffer}
      localSocket := 0;          {let ADSP assign socket}
   END;
   
   dspCCB.myA5 := SetCurrentA5;  {save A5 for the user routine}
      
   {Establish a connection end.}
   myErr := PBControl(ParmBlkPtr(myDSPPBPtr), FALSE);
   IF myErr &lt;&gt; noErr THEN DoErr(myErr);  
                                 {check and handle error}
   connRefNum := myDSPPBPtr^.ccbRefNum;
                                 {save CCB ref num for later}
   {You received a connection request: now open a connection. }
   { The dspCLListen call has returned values into the }
   { remoteCID, remoteAddress, sendSeq, sendWindow, }
   { and attnSendSeq fields of the parameter block.}
   
   WITH myDSPPBPtr^ DO           {set up dspOpen parameters}
   BEGIN
      ioCRefNum := drvrRefNum;   {ADSP driver ref num}
      csCode := dspOpen;
      ccbRefNum := connRefNum;   {connection ref num}
      ocMode := ocAccept;        {open connection mode}
      ocInterval := 0;           {use default retry interval}
      ocMaximum := 0;            {use default retry maximum}
   END;
   myErr := PBControl(ParmBlkPtr(myDSPPBPtr), FALSE); 
                                 {open a connection}
   IF myErr &lt;&gt; noErr THEN DoErr(myErr)
                                 {check and handle error}
END;     {MyCLADSP}
</PRE>
</BLOCKQUOTE>
<HR>
<center>
<A HREF="Networking-110.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="Networking-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="Networking-304.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt= "Book Index"></A> <A HREF="Networking-112.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="Networking-3.html">&copy; Apple Computer, Inc.</A><br>7 JUL 1996</center></font><P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML>  
