<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>SCSI Async Sample - /Src/DoSCSISynchronousIO.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../samplecode/LegacyTechnologies/idxHardwareDrivers-date.html">Hardware & Drivers</a> &gt; <A HREF="javascript:location.replace('index.html');">SCSI Async Sample</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/HardwareDrivers/idxSCSI-date.html" target="_blank">Hardware & Drivers > SCSI</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">SCSI Async Sample</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/Src/DoSCSISynchronousIO.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/Src/AsyncSCSIPresent.c</option>
<option value="listing2.html">/Src/ContinueTesting.c</option>
<option value="listing3.html">/Src/DialogUtilities.c</option>
<option value="listing4.html">/Src/DialogUtilities.h</option>
<option value="listing5.html">/Src/DisplayTestParameters.c</option>
<option value="listing6.html">/Src/DisplayTestResults.c</option>
<option value="listing7.html">/Src/DoSCSISynchronousIO.c</option>
<option value="listing8.html">/Src/GetDevicesToTest.c</option>
<option value="listing9.html">/Src/GetSCSICDBLength.c</option>
<option value="listing10.html">/Src/LogManager.c</option>
<option value="listing11.html">/Src/LogManager.h</option>
<option value="listing12.html">/Src/MicrosecondDelta.c</option>
<option value="listing13.html">/Src/MicrosecondTrap.h</option>
<option value="listing14.html">/Src/MicrosecondTrapPresent.c</option>
<option value="listing15.html">/Src/NewSCSIManagerPresent.c</option>
<option value="listing16.html">/Src/NumericFilter.c</option>
<option value="listing17.html">/Src/scsi.h</option>
<option value="listing18.html">/Src/SCSIAsyncSample.h</option>
<option value="listing19.html">/Src/SCSIAsyncSample.r</option>
<option value="listing20.html">/Src/SCSIAsyncSampleMain.c</option>
<option value="listing21.html">/Src/SCSIBusInquiry.c</option>
<option value="listing22.html">/Src/SCSIDefinitions.h</option>
<option value="listing23.html">/Src/SpinCursor.c</option>
<option value="listing24.html">/Src/StringFormat.c</option>
<option value="listing25.html">/Src/WindowUtilities.c</option></select>
				</p>
				</form>
				<p><strong><a href="SCSI_Async_Sample.zip">Download Sample</a></strong> (&#147;SCSI_Async_Sample.zip&#148;, 105.5K)<BR>
<strong><a href="SCSI_Async_Sample.dmg">Download Sample</a></strong> (&#147;SCSI_Async_Sample.dmg&#148;, 169.7K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/*                DoSCSISynchronousIO.c              *//* * DoSCSIExecIO.c * Copyright &copy; 1992-93 Apple Computer Inc. All Rights Reserved. * * Talk to the Macintosh SCSI Manager 4.3 using the &quot;new&quot; interface. This executes * a single SCSI Command on a device using parameters from the INFO record. Note: * this command is only used for dialog setup and always executes synchronously * with polled I/O and no disconnect. * * Calling Sequence: *    OSErr        DoSCSISynchronousIO( *        InfoPtr      infoPtr, *        SCSI_CommandPtr  commandPtr, *        unsigned long  scsiFlags, *        Ptr        bufferPtr, *        unsigned long  transferLength *      ); * The following information is taken from the InfoRecord: *        ScsiCmdBlock  *pb        -- the Scsi Command block *        unsigned long  pbSize      -- the size of the command block *        ProcPtr      ioCompletion  -- NULL for synch, else asynch *        DeviceIdent    deviceIdent    -- bus/target/LUN * After completion, the following information is stored in the InfoRecord *        unsigned short  stsByte      -- from Status phase *        unsigned short  msgByte      -- Command Complete message * Return codes: *  noErr      normal *  statusErr    Device returned &quot;Check condition&quot; and SCSI Manager was able *          to successfully issue Request Sense. There is data in the *          Sense Record, but you cannot assume that the original request *          succeeded. *  paramErr    Could not determine the command length. *  sc...      Other error */#include &quot;SCSIAsyncSample.h&quot;#include &lt;GestaltEqu.h&gt;#include &lt;Memory.h&gt;#include &lt;Events.h&gt;static void           NextFunction(void);    /* For HoldMemory size  */static Boolean          IsVirtualMemoryRunning(void);OSErrDoSCSISynchronousIO(     InfoPtr          infoPtr,    SCSI_CommandPtr      commandPtr,    unsigned long      scsiFlags,    Ptr            bufferPtr,    unsigned long      transferLength  ){    OSErr            status;    register short        i;    union {      SCSIAbortCommandPB    abortCommandPB;      SCSIResetBusPB      resetBusPB;      SCSIReleaseQPB      releaseQPB;    } pb;    auto void          *vmProtectedStackBase;  /* Last local var  */#define INFO  (*infoPtr)#define PB    (*INFO.pb)/* * These values are used to compute the size of the stack that we must hold in * protected (non-virtual) memory. kSCSIManagerStackEstimate is an estimate. */#define kSCSILocalVariableSize  ( \    (unsigned long) (((Ptr) &amp;infoPtr) - ((Ptr) &amp;vmProtectedStackBase))  \  )#define kSCSIManagerStackEstimate 512#define kSCSIProtectedStackSize (kSCSIManagerStackEstimate + kSCSILocalVariableSize)    status = noErr;    ClearMemory((Ptr) INFO.pb, INFO.pbSize);    ClearMemory((Ptr) INFO.vmHoldInfo, sizeof INFO.vmHoldInfo);    /*     * Setup the parameter block for the user's request.     */    PB.scsiPBLength = INFO.pbSize;    PB.scsiFunctionCode = SCSIExecIO;    PB.scsiCompletion = NULL;    PB.scsiDriverStorage = (unsigned char *) infoPtr; /* for IOCompletion  */    INFO.statusByte = 0xFF;          /* Illegal value for debugging  */    PB.scsiTimeout = INFO.completionTimeout;    PB.scsiDevice = INFO.deviceIdent;    PB.scsiCDBLength = GetSCSICDBLength(commandPtr);    if (PB.scsiCDBLength == 0) {      status = paramErr;      goto exit;    }    /*     * Copy the command block into the SCSI PB to simplify vm lockdown.     */    BlockMove(commandPtr, &amp;PB.scsiCDB, PB.scsiCDBLength);    /*     * Specify the transfer direction, if any. scsiFlags should be one of     *  scsiDirectionIn, scsiDirectionOut, or scsiDirectionNone     */    PB.scsiFlags = scsiFlags;    /* scsiDirectionIn or scsiDirectionOut  */    if (bufferPtr == NULL || transferLength == 0)      PB.scsiFlags = scsiDirectionNone;    else {      /*       * If the user specified the transfer quantum == 1, select &quot;polled&quot;       * transfers, otherwise, select &quot;blind.&quot;       */      PB.scsiTransferType = scsiTransferPolled;      PB.scsiDataPtr = (unsigned char *) bufferPtr;      PB.scsiDataLength = transferLength;      PB.scsiDataType = scsiDataBuffer;      PB.scsiHandshake[0] = 1;      PB.scsiHandshake[1] = 0;    }    PB.scsiSensePtr = (unsigned char *) &amp;INFO.senseData;    PB.scsiSenseLength = sizeof INFO.senseData;    /*     * The SCSI Manager &quot;freezes&quot; the device queue after a Check Condition     * (even if AutoSense was enabled). Disable this to prevent hangs.     */    PB.scsiFlags |= (scsiDontDisconnect | scsiSIMQNoFreeze);    /*     * We are now ready to perform the operation. If virtual memory is active     * however, we must lock down all memory segments that can be potentially     * &quot;touched&quot; while the SCSI request is being executed. All of this is     * needed for applications. For drivers, most of the following can be     * ignored as the driver code and driver-specific resources are stored in     * the System Heap, which is always &quot;held&quot; in physical memory.     */    if (gVirtualMemoryEnabled) {      /*       * Virtual memory is active. Lock all of the memory segments that we       * need in &quot;real&quot; memory (i.e. non-paged pool) for the duration of the       * call.       */      INFO.vmHoldInfo[kVMFunction].ptr = DoSCSISynchronousIO;      INFO.vmHoldInfo[kVMFunction].size =        (unsigned long) NextFunction - (unsigned long) DoSCSISynchronousIO;      INFO.vmHoldInfo[kVMStack].ptr = (void *)        (((unsigned long) &amp;vmProtectedStackBase)        - kSCSIManagerStackEstimate);      INFO.vmHoldInfo[kVMStack].size = kSCSIProtectedStackSize;      INFO.vmHoldInfo[kVMParam].ptr = INFO.pb;      INFO.vmHoldInfo[kVMParam].size = INFO.pbSize;      if (bufferPtr != NULL) {        INFO.vmHoldInfo[kVMBuffer].ptr = PB.scsiDataPtr;        INFO.vmHoldInfo[kVMBuffer].size = PB.scsiDataLength;      }      INFO.vmHoldInfo[kVMSense].ptr = PB.scsiSensePtr;      INFO.vmHoldInfo[kVMSense].size = PB.scsiSenseLength;      for (i = 0; i &lt; kVMSize; i++) {        if (INFO.vmHoldInfo[i].ptr != NULL) {          status = HoldMemory(                INFO.vmHoldInfo[i].ptr,                INFO.vmHoldInfo[i].size              );          if (status != noErr) {            while (i &lt; kVMSize)              INFO.vmHoldInfo[i++].ptr = NULL;            break;          }        }      }      if (status != noErr) {        /*         * Something failed. Unwind before exiting.         */        for (i = 0; i &lt; kVMSize; i++) {          if (INFO.vmHoldInfo[i].ptr != NULL) {            (void) UnholdMemory(                INFO.vmHoldInfo[i].ptr,                INFO.vmHoldInfo[i].size              );          }        }      }    }    /*     * Now, just call the New SCSI Manager.     */    if (status == noErr) {      status = SCSIAction((SCSI_PB *) &amp;PB);      if (PB.scsiCompletion == NULL) {        /*         * Synchronous request: The following should be         * moved to a &quot;default&quot; I/O Completion routine.         */        if (status == noErr)          status = PB.scsiResult;        /*         * These should never happen.         */        if (status == scsiRequestInProgress) {          CLEAR(pb.abortCommandPB);          pb.abortCommandPB.scsiPBLength = sizeof pb.abortCommandPB;          pb.abortCommandPB.scsiFunctionCode = SCSIAbortCommand;          pb.abortCommandPB.scsiIOptr = INFO.pb;          (void) SCSIAction((SCSI_PB *) &amp;pb.abortCommandPB);        }        if ((PB.scsiResultFlags &amp; scsiBusNotFree) != 0) {          CLEAR(pb.resetBusPB);          pb.resetBusPB.scsiPBLength = sizeof pb.resetBusPB;          pb.resetBusPB.scsiFunctionCode = SCSIResetBus;          (void) SCSIAction((SCSI_PB *) &amp;pb.resetBusPB);        }        if ((PB.scsiResultFlags &amp; scsiSIMQFrozen) != 0) {          CLEAR(pb.releaseQPB);          pb.releaseQPB.scsiPBLength = sizeof pb.releaseQPB;          pb.releaseQPB.scsiFunctionCode = SCSIReleaseQ;          (void) SCSIAction((SCSI_PB *) &amp;pb.releaseQPB);        }        for (i = 0; i &lt; kVMSize; i++) {          if (INFO.vmHoldInfo[i].ptr != NULL) {            (void) UnholdMemory(                INFO.vmHoldInfo[i].ptr,                INFO.vmHoldInfo[i].size              );          }        }        INFO.actualTransferCount =          PB.scsiDataLength - PB.scsiDataResidual;        if (status == scsiDataRunError         &amp;&amp; PB.scsiDataResidual != PB.scsiDataLength)          status = noErr;      }    }exit:  return (status);#undef PB}static void NextFunction(void) { }  /* Dummy function for MacSCSICommand size  */</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/SCSI_Async_Sample/listing7.html%3Fid%3DDTS10000022-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/SCSI_Async_Sample/listing7.html%3Fid%3DDTS10000022-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/SCSI_Async_Sample/listing7.html%3Fid%3DDTS10000022-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>