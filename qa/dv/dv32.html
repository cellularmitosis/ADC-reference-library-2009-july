<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"			"http://www.w3.org/TR/REC-html40/loose.dtd"><HTML><!--Template 06-20-02--><HEAD><LINK REL="stylesheet" HREF="../../adcstyle.css" TYPE="text/css"><LINK REL="stylesheet" HREF="../../style.css" TYPE="text/css">   <title>Technical Q&amp;A DV32: PrepareMemoryForIO and Execution Levels</title>   		<meta name="keywords" content="Mac OS 8 DMA hardware partial preparation drivers PrepareMemoryForIO ">	<meta name="Description" content="Technical Q&amp;A DV32: Q&amp;A gives background info on device driversthat control DMA hardware and also uses partial preparation.Q&amp;A then gives references for a solution to writing sucha driver and justifies why the solution should work explainingPrepareMemoryForIO along the way. "><meta name="categories" content="Devices"><meta name="week-posted" content="Jun 8, 1998 - Jun 12, 1998"><LINK REL="stylesheet" HREF="../../css/adcstyle.css" TYPE="text/css"><script language="JavaScript" type="text/javascript" src="../../js/adc.js"></script></HEAD><BODY BGCOLOR="#FFFFFF"><a name="//apple_ref/doc/uid/DTS10001173" title="PrepareMemoryForIO and Execution Levels"></a><!-- top_of_header_marker_comment --><!-- begin_header_information --><!--#include virtual="/adcnavbar" --><p><a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../technicalqas/index.html">Technical Q&As</a> &gt; <a href="../../technicalqas/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../technicalqas/LegacyTechnologies/idxHardwareDrivers-date.html">Hardware & Drivers</a> &gt; </p><div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="../../referencelibrary/HardwareDrivers/index.html" target="_blank">Reference Library > Hardware & Drivers</a></li>
	</ul>
</div>




</div></div></div><!-- end_header_information --><!-- bottom_of_header_marker_comment --><!-- top_of_titles_marker_comment --><CENTER><table width="600" cellpadding="0" cellspacing="0" border="0">
<tr><td align="left" scope="row">
<h1>
<div id="pagehead">Technical Q&amp;A DV32</div>
<div id="pageheadsub">PrepareMemoryForIO and Execution Levels</div>
</h1>
</td></tr></table></CENTER><!-- bottom_of_titles_marker_comment --><!-- begin_content --> <CENTER><TABLE BORDER=0 CELLPADDING=0 WIDTH=600><TR> <td align="left"><hr width=500 align=center><p id=p2>Q: I'm writing a native driver (a SCSI SIM)that controls DMA hardware and needs to use partial preparation. Howcan I do this without breaking the rules described in Table 9-2 of"Designing PCI Cards and Drivers for Power Macintosh Computers"?</p><p id=p4>A: The short answer is that you can't do thiswithout breaking the rules, but it's OK to break the rules in thiscase. A native SCSI SIM on the traditional Mac OS must call<CODE>PrepareMemoryForIO</CODE> at native hardware-interrupt level,and it is safe to do so. This is obviously going to require someexplanation. Hold on to your hats!</P><p id=p4>For background information on the problem, you should read thearticle<a href="http://developer.apple.com/dev/techsupport/develop/issue24/minow.html">TheNew Device Drivers: Memory Matters</A> (<I>develop</I> 24). This articledescribes the official algorithm for implementing partial preparationmechanism in the native driver model. However, there are two problemswith this algorithm:</P><OL>   <LI>It doesn't work (in practice) because it relies on software   interrupts, which are not implemented on the traditional Mac OS.   See   <a href="../../technotes/tn/tn1104.html">Technote   1104: Interrupt Safe Routines</A> for a discussion of this   restriction.</li>      <LI>It doesn't work (in theory) for devices on the page fault   path. This is because the algorithm requires the use of software   interrupts -- which can cause a page fault -- and a device on the   page fault path is not allowed to cause a page fault. This   restriction is described in the <I>develop</I>   <a href="http://developer.apple.com/dev/techsupport/develop/issue24/minow.html">    article</A> itself.</li></OL><p id=p4>So the algorithm described in<a href="http://developer.apple.com/dev/techsupport/develop/issue24/minow.html">TheNew Device Drivers: Memory Matters</A> is not valid for SCSI SIMs onthe traditional Mac OS. There is, however, a relatively simpleworkaround that does work in these circumstances. In the algorithmdescribed after Figure 2 of the <I>develop</I><a href="http://developer.apple.com/dev/techsupport/develop/issue24/minow.html"> article</A>, you can compress steps 2, 3 and 4 into one step,eliminating the use of secondary-interrupt and software-interruptlevel execution. As a result, your SIM calls<CODE>PrepareMemoryForIO</CODE> at native hardware-interrupt time.This is explicitly outlawed in Table 9-2 of "Designing PCI Cards andDrivers for Power Macintosh Computers," but is the only way thatworks.</P><p id=p4>The rest of this Q&amp;A is a justification of why this works. Tounderstand this discussion, you may need to reference<a href="../../technotes/tn/tn1094.html">Technote1094: Virtual Memory Application Compatibility</A>, which contains acomprehensive explanation of how virtual memory works on thetraditional Mac OS.</P><p id=p4>On the traditional Mac OS, <CODE>PrepareMemoryForIO</CODE> isactually implemented as a wrapper around standard Virtual MemoryManager routines. The specific routines of interest are<CODE>LockMemory</CODE> and <CODE>GetPhysical</CODE>. Theimplementation of <CODE>PrepareMemoryForIO</CODE> is, in itself,interrupt-safe; thus, calling <CODE>PrepareMemoryForIO</CODE> isallowed at any time calling the underlying Virtual MemoryManager routines is allowed.</P><TABLE BORDER=0 CELLPADDING=5 WIDTH=550> <TR> <td bgcolor="#e6e6e6" align=left>         <p id=p4>Note: On Mac OS 8.5 or higher, <CODE>PrepareMemoryForIO</CODE>         will call <CODE>LockMemory</CODE> or         <CODE>LockMemoryForOutput</CODE>, depending on the direction         of the request, as specified in the <CODE>options</CODE>         field of the <CODE>IOPreparationTable</CODE>. However, in         this context we can treat <CODE>LockMemory</CODE> and         <CODE>LockMemoryForOutput</CODE> as synonyms and ignore this         complication.</p>     </td></tr> </table> <p id=p4><a href="../../technotes/tn/tn1104.html">Technote1104: Interrupt Safe Routines</A> describes the interrupt-safe natureof <CODE>GetPhysical</CODE> and <CODE>LockMemory</CODE>. To summarizethe discussion in that Technote, <CODE>GetPhysical</CODE> is alwaysinterrupt-safe and <CODE>LockMemory</CODE> is interrupt-safe ifeither a) paging is safe, or b) you can guarantee that locking thememory will not cause any page faults.</P><p id=p4>In the case of a SCSI SIM, the traditional Mac OS guarantees thatany transfer buffer passed to the SIM is held resident in memory.This guarantee is maintained by two mechanisms:</P><OL>   <LI>The Virtual Memory Manager holds any transfer buffer passed to   a SCSI device driver. The details of this mechanism are covered in   the   <a href="../../technotes/tn/tn1094b.html#Implementation">VM   Implementation Details</A> section of   <a href="../../technotes/tn/tn1094b.html">Technote   1094</A>.</li>      <LI>The programming rules for SCSI Manager require that any   program making direct SCSI calls must hold all transfer buffers   passed to SCSI Manager. This requirement is explicitly spelt out   in the   <a href="../../technotes/tn/tn1094b.html#Programming1">Direct   SCSI Manager or ATA Manager Calls</A> section of   <a href="../../technotes/tn/tn1094b.html">Technote   1094</A>.</li></OL><p id=p4>So, as the author of a SCSI SIM, you are guaranteed that transferbuffers passed to your SIM are held resident. This implies that it'salways safe to call <CODE>LockMemory</CODE> on those transferbuffers, even at hardware-interrupt time. This, in turn, implies thatit is always safe to prepare those transfer buffers using<CODE>PrepareMemoryForIO</CODE>, even at hardware-interrupt time.</P></td></tr></table></CENTER><!-- end_content --><!-- begin_date --><H4 ALIGN=center>[Jun 08 1998]</H4><!-- end_date --><!-- begin_footer_information -->	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/qa/dv/dv32.html%3Fid%3DDTS10001173-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/qa/dv/dv32.html%3Fid%3DDTS10001173-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/qa/dv/dv32.html%3Fid%3DDTS10001173-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>
<!--#include virtual="/includes/footer"--><!-- end_footer_information --> <hr width=500 align=center> </BODY> </HTML>